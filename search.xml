<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聊聊V8引擎的垃圾回收]]></title>
    <url>%2F2018%2F04%2F14%2Fv8_garbage_collection%2F</url>
    <content type="text"><![CDATA[前言我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~ 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 为什么要有垃圾回收在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。 不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。 内存结构分配由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在64位系统下大约为1.4GB，在32位系统下大约为700MB。 在NodeJS环境中，我们可以通过process.memoryUsage()来查看内存分配。 process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，含义如下： 1234567rss（resident set size）：所有内存占用，包括指令区和堆栈heapTotal：V8引擎可以分配的最大堆内存，包含下面的 heapUsedheapUsed：V8引擎已经分配使用的堆内存external： V8管理C++对象绑定到JavaScript对象上的内存 以上所有内存单位均为字节（Byte）。 如果说想要扩大Node可用的内存空间，可以使用Buffer等堆外内存内存，这里不详细说明了，大家有兴趣可以去看一些资料。 下面是Node的整体架构图，有助于大家理解上面的内容： 123456789Node Standard Library: 是我们每天都在用的标准库，如Http, Buffer 模块Node Bindings: 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务第三层是支撑 Node.js 运行的关键，由 C/C++ 实现：1. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机2. Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力3. C-ares：提供了异步处理 DNS 相关的能力4. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力 垃圾回收机制1. 如何判断是否可以回收1.1 标记清除当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。 （1）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。 （2）然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记 （3）此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。 （4）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 活动对象就是上面的root，如果不清楚活动对象的可以先查一下资料，当一个对象和其关联对象不再通过引用关系被当前root引用了，这个对象就会被垃圾回收。 1.2 引用计数引用计数的垃圾收集策略不太常见。含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。 如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。 当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。 循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用，看个例子：1234567function foo () &#123; var objA = new Object(); var objB = new Object(); objA.otherObj = objB; objB.anotherObj = objA;&#125; 这个例子中，objA和objB通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2。 在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是问题。 但在采用引用次数策略的实现中，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0。 加入这个函数被重复多次调用，就会导致大量内存无法回收。为此，Netscape在Navigator 4.0中也放弃了引用计数方式，转而采用标记清除来实现其垃圾回收机制。 还要注意的是，我们大部分人时刻都在写着循环引用的代码，看下面这个例子，相信大家都这样写过：1234var el = document.getElementById('#el');el.onclick = function (event) &#123; console.log('element was clicked');&#125; 我们为一个元素的点击事件绑定了一个匿名函数，我们通过event参数是可以拿到相应元素el的信息的。 大家想想，这是不是就是一个循环引用呢？el有一个属性onclick引用了一个函数（其实也是个对象），函数里面的参数又引用了el，这样el的引用次数一直是2，即使当前这个页面关闭了，也无法进行垃圾回收。 如果这样的写法很多很多，就会造成内存泄露。我们可以通过在页面卸载时清除事件引用，这样就可以被回收了：123456789101112var el = document.getElementById('#el');el.onclick = function (event) &#123; console.log('element was clicked');&#125;// ...// ...// 页面卸载时将绑定的事件清空window.onbeforeunload = function()&#123; el.onclick = null;&#125; V8垃圾回收策略自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。 所以，V8采用了一种代回收的策略，将内存分为两个生代：新生代（new generation）和老生代（old generation）。 新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升，后面我会详细说明。 分代内存默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。 新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。 新生代1. 分配方式新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。 2. 算法新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。 Cheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。 处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。 我画了一套详细的流程图，接下来我会结合流程图来详细说明Cheney算法是怎么工作的。垃圾回收在下面我统称为 GC（Garbage Collection）。 step1. 在From空间中分配了3个对象A、B、C step2. GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象 step3. 将活跃对象A、C从From空间复制到To空间 step4. 清空From空间的全部内存 step5. 交换From空间和To空间 step6. 在From空间中又新增了2个对象D、E step7. 下一轮GC进来发现对象D没有引用了，做标记 step8. 将活跃对象A、C、E从From空间复制到To空间 step9. 清空From空间全部内存 step10. 继续交换From空间和To空间，开始下一轮 通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。 由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。 3. 晋升当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。 对象从新生代移动到老生代的过程叫作晋升。 对象晋升的条件主要有两个： 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。 老生代1. 介绍在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题： 由于存活对象较多，复制存活对象的效率会很低。 采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。 所以，V8在老生代中主要采用了Mark-Sweep和Mark-Sweep相结合的方式进行垃圾回收。 2. Mark-SweepMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。 与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。 也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。 我们还是通过流程图来看一下： step1. 老生代中有对象A、B、C、D、E、F step2. GC进入标记阶段，将A、C、E标记为存活对象 step3. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间 可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。 如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 2. Mark-Compact为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。 Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示： step1. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样） step2. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样） step3. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间 step4. GC进入清除阶段，将边界另一侧的内存一次性全部回收 3. 两者结合在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。 由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。 总结V8的垃圾回收机制分为新生代和老生代。 新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。 老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。 以上就是本文的全部内容，书写过程中参考了很多中外文章，参考书籍包括朴大大的《深入浅出NodeJS》以及《JavaScript高级程序设计》等。我们这里并没有对具体的算法实现进行探讨，感兴趣的朋友可以继续深入研究一下。 最后，谢谢大家能够读到这里，如果文中有任何不明确或错误的地方，欢迎给我留言~~ 参考链接https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8http://alinode.aliyun.com/blog/14http://www.ruanyifeng.com/blog/2017/04/memory-leak.htmlhttps://segmentfault.com/a/1190000000440270]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>V8</tag>
        <tag>垃圾回收</tag>
        <tag>Scavenge</tag>
        <tag>Mark-Sweep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾调用和尾递归]]></title>
    <url>%2F2018%2F04%2F10%2Ftail_call%2F</url>
    <content type="text"><![CDATA[尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: , 依次举例：123const a = x =&gt; x ? f() : g();// f() 和 g() 都在尾部。 12345678910111213141516const a = () =&gt; f() || g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return fResult; &#125; else &#123; return g(); // tail call &#125;&#125;// 只有当f()的结果为falsey的时候，g()才是尾调用 12345678910111213141516const a = () =&gt; f() &amp;&amp; g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return g(); // tail call &#125; else &#123; return fResult; &#125;&#125;// 只有当f()的结果为truthy的时候，g()才是尾调用 12345678910const a = () =&gt; (f() , g());// g()是尾调用// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; f(); return g();&#125; 2. 尾调用优化函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：12345function foo () &#123; console.log(111); &#125;function bar () &#123; foo(); &#125;function baz () &#123; bar(); &#125;baz(); 造成这种结果是因为每个函数在调用另一个函数的时候，并没有 return 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。 baz() 里面调用了 bar() 函数，并没有 return 该调用，所以在调用栈中保持自己的调用帧，同时 bar() 函数的调用帧在调用栈中生成，同理，bar() 函数又调用了 foo() 函数，最后执行到 foo() 函数的时候，没有再调用其他函数，这里没有显示声明 return，所以这里默认 return undefined。 foo() 执行完了，销毁调用栈中自己的记录，依次销毁 bar() 和 baz() 的调用帧，最后完成整个流程。 如果对上面的例子做如下修改：12345function foo () &#123; console.log(111); &#125;function bar () &#123; return foo(); &#125;function baz () &#123; return bar(); &#125;baz(); 这里要注意：尾调用优化只在严格模式下有效。 在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈： func.arguments: 表示对 func最近一次调用所包含的参数 func.caller: 引用对 func最近一次调用的那个函数 在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。 如果尾调用优化生效，流程图就会变成这样： 我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。 这就叫做尾调用优化，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。 尾递归1. 定义先来看一下递归，当一个函数调用自身，就叫做递归。123function foo () &#123; foo();&#125; 上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。 那么什么是尾递归？前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做尾递归。123function foo () &#123; return foo();&#125; 2. 作用那么尾递归相比递归而言，有哪些不同呢？我们通过下面这个求阶乘的例子来看一下：12345678function factorial (num) &#123; if (num === 1) return 1; return num * factorial(num - 1);&#125;factorial(5); // 120factorial(10); // 3628800factorial(500000); // Uncaught RangeError: Maximum call stack size exceeded 上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。 这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。 如果用尾递归来计算阶乘呢？123456789101112131415'use strict';function factorial (num, total) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5, 1); // 120factorial(10, 1); // 3628800factorial(500000, 1); // 分情况// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js// node最新版本已经移除了--harmony_tailcalls功能 通过尾递归，我们把复杂度从O(n)降低到了O(1)，如果数据足够大的话，会节省很多的计算时间。由此可见，尾调用优化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。 避免改写递归函数尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的factorial()函数改写一样。 这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？解决这个问题的办法有两个： 1. ES6参数默认值123456789'use strict';function factorial (num, total = 1) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 2. 用一个符合语义的函数去调用改写后的尾递归函数1234567891011function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;function factorial (num) &#123; return tailFactorial(num, 1);&#125;factorial(5); // 120factorial(10); // 3628800 上面这种写法其实有点类似于做了一个函数柯里化，但不完全符合柯里化的概念。函数柯里化是指把接受多个参数的函数转换为接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数。 概念看着很绕口，我们来个例子感受一下：1234567891011121314151617// 普通加法函数function add (x, y, z) &#123; return x + y + z;&#125;add(1, 2, 3); // 6// 改写为柯里化加法函数function add (x) &#123; return function (y) &#123; return function (z) &#123; return x + y + z; &#125; &#125;&#125;add(1)(2)(3); // 6 可以看到，柯里化函数通过闭包找到父作用域里的变量，最后依次相加输出结果。通过这个例子，可能看不出为什么要用柯里化，有什么好处，这个我们以后再谈，这里先引出一个概念。 是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 如果用柯里化改写求阶乘的例子：12345678910111213141516171819202122232425262728293031323334353637383940// 柯里化函数function curry (fn) &#123; var _fnArgLength = fn.length; function wrap (...args) &#123; var _args = args; var _argLength = _args.length; // 如果传的是所有参数，直接返回fn调用 if (_fnArgLength === _argLength) &#123; return fn.apply(null, args); &#125; function act (...args) &#123; _args = _args.concat(args); if (_args.length === _fnArgLength) &#123; return fn.apply(null, _args); &#125; return act; &#125; return act; &#125; return wrap;&#125;// 尾递归函数function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;// 改写var factorial = curry(tailFactorial);factorial(5)(1); // 120factorial(10)(1); // 3628800 这是符合柯里化概念的写法，在阮一峰老师的文章中是这样写的：1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 我个人认为，这种写法其实不是柯里化，因为并没有将多参数的tailFacrotial改写为接受单参数的形式，只是换了一种写法，和下面这样写意义是一样的：1234567891011function factorial (num) &#123; return tailFactorial(num, 1);&#125;function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 结束这篇文章我们主要讨论了尾调用优化和柯里化。要注意的是，经过测试，Chrome和Firefox并没有对尾调用进行优化，Safari对尾调用进行了优化。Node高版本也已经去除了通过–harmony_tailcalls参数启用尾调用优化。 有任何问题，欢迎大家留言讨论~~ 参考链接http://www.ruanyifeng.com/blog/2015/04/tail-call.htmlhttps://juejin.im/post/5a4d898a518825698e7277d1https://github.com/lamdu/lamdu/issues/90]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>尾调用</tag>
        <tag>尾递归</tag>
        <tag>函数式</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 karma + jasmine 测试环境]]></title>
    <url>%2F2018%2F04%2F03%2Ffront_end_test_karma_jasmine%2F</url>
    <content type="text"><![CDATA[在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。 在 init 时会让你选择一些配置项： test framework我这里选择的是jasmine，它是一款JavaScript断言测试库use Require.js根据个人情况，我选择的是nocapture any browsers automatically选择浏览器，我选择的是无头浏览器PhantomJSlocation of your source files为空any of files included by the previous patterns be excluted为空karma to watch all files and run the tests on change是否监测，我选择的是no 在选择完所有配置项后，会自动生成karma.conf.js配置文件。 根据配置项的选择安装插件（1） 测试框架选择的是jasmine，安装步骤如下：1$ npm install jasmine-core karma-jasmine -D 这里要装两个，一个是jasmine的核心，另一个是karma对jasmine的封装。 （2） 浏览器选择的是PhantomJS，安装步骤如下：1$ npm install karma-phantomjs-launcher -D （3） 如果涉及到对以ES6编写的代码进行测试，就要安装Babel及其相关插件：12$ npm install babel-cli babel-preset-env babel-plugin-transform-es2015-modules-umd -D$ npm install karma-babel-preprocessor -D （4） 安装生成代码覆盖率报告的插件：1$ npm install karma-coverage -D 修改karma配置文件123456789101112131415161718192021222324252627282930// karma.conf.jsmodule.exports = function(config) &#123; config.set(&#123; basePath: '', frameworks: ['jasmine'], files: [ './src/**/*.js', './test/**/*.spec.js' ], exclude: [ ], preprocessors: &#123; './src/**/*.js': ['babel'], './test/**/*.spec.js': ['babel', 'coverage'] &#125;, reporters: ['progress', 'coverage'], coverageReporter: &#123; type: 'html', dir: 'coverage/' &#125;, port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: ['PhantomJS'], singleRun: true, concurrency: Infinity &#125;)&#125; 修改Babel配置文件：123456// .babelrc&#123; "presets": ["env"], "plugins": ["transform-es2015-modules-umd"], "auxiliaryCommentBefore": "istanbul ignore next"&#125; 写测试文件1234567891011// PraiseButton.spec.jsimport PraiseButton from '../src/PraiseButton.js';describe('测试点赞组件', function () &#123; it('addOne() 函数', function () &#123; var testPraiseButton = new PraiseButton(); testPraiseButton.addOne(); expect(testPraiseButton.countNum).toBe(1); &#125;);&#125;); 运行测试1$ karma start 结束按照上述步骤，大家应该可以配置好自己的 karma + jasmine 测试环境，如果遇到问题或者文中有写错的地方，欢迎大家来讨论。文章末尾是需要安装模块的链接，大家可以一键直达。 参考链接karma官网https://karma-runner.github.io/2.0/intro/installation.htmlkarma-clihttps://www.npmjs.com/package/karma-clikarma-jasminehttps://www.npmjs.com/package/karma-jasminejasmine-corehttps://www.npmjs.com/package/jasmine-corekarma-coveragehttps://www.npmjs.com/package/karma-coverage]]></content>
      <categories>
        <category>前端测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>karma</tag>
        <tag>jasmine</tag>
        <tag>phantomJS</tag>
        <tag>Babel</tag>
        <tag>ES6</tag>
        <tag>System</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 07 - 标签声明（Label Statement）]]></title>
    <url>%2F2018%2F03%2F10%2Fjavascript_07_label_statement%2F</url>
    <content type="text"><![CDATA[引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？ 再看一个例子，你也一定见到过这样的写法：12345// 假设str是你通过ajax接收到的JSON串var str = '&#123;"name": "liu", "age": 20&#125;';var obj = eval('(' + str + ')');console.log(obj); 那么，你有没有想过 eval 里面为什么要加上括号呢？如果不加又是什么情况？（提前剧透，不加括号这里会报错哦）。 接着往下看，当你读完这篇文章的时候，心中的疑惑会完全解开。 Label Statement学过C语言的同学知道，C的语法中有一个语句叫：goto，同时老师也多次强调不让我们使用goto语句，因为会大大影响程序的可读性和可维护性。 我们先来看一段C语言的goto代码：12345678910111213void main()&#123; int a=2, b=3; if(a&gt;b) &#123; goto aa; &#125; printf("hello"); aa: printf("s"); return 0;&#125; 当 a &lt; b 的时候，这里会打印字符串 “hello”，然后结束。当 a &gt; b 的时候，由于goto语句的作用，就会跳过 print(“hello”)，直接跳到 aa 标签声明的代码块中，打印字符 “s”，然后结束。 这就是goto语句的作用，通过标签声明一个代码块，然后在任何地方都可以执行 goto ‘labe’ 来进行程序跳转。 显而易见，这样的写法，违背了程序顺序执行的原则，会跳来跳去，最后导致根本无法维护，所以，记住老师的话，不要使用 goto 语句。 那么，看完了C语言中的 goto 语句，和我们的 JavaScript 又有什么关系呢？这就引出了今天的主题：Label Statement，它就是 JS 中的 goto 语句。 用法首先明确一个原则，在JavaScript中，语句优先。也就是说，如果一段代码既能够以语句的方式解析，也能用语法的方式解析，在JS中，会优先按语句来解析。 1&#123; a : 1 &#125; 上面这段代码，在JS中的执行结果是什么呢？大家思考2分钟…. 好，2分钟已过，大家有结果了吗？千万不要在浏览器的控制台中去写这段代码，虽然结果和你开始想的结果一样，但是，它是错误的。 这是在console控制台中执行的结果： 这是在watch中的执行结果： 可以看到两个结果是不一样的。console是经过处理的这里不能相信，watch是直接JS的运行环境执行后的结果，是正确的。 为什么 { a : 1 } 结果会是 1 呢？ 我换一个写法：123&#123; a : 1&#125; 相信有的同学已经明白了，在JS中，{}既可以代表代码块，又可以作为Object的语法标志。那么我们前面说过，JS是语句优先的，当一段代码既可以按照语句解析，又可以按照语法解析的时候，会优先按语句解析。 当把{}当做是代码块的时候，里面的 a : 1，是不是很像C语言goto语句的标签声明呢？开头我们提出的第一个问题，如果用这种方式来解决，代码如下：1234567891011aa : &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) break aa; &#125; &#125;&#125;console.log('done'); aa是标签声明，包裹一个代码块，break 的作用是跳出当前的循环，本来是无法跳出外面那层for循环的，但是 break aa，这里跳出了整个代码块。 当然，这种写法是完全不提倡的，这里只是用来说明JS中的Label Statement这个特性，大家千万不要这样写代码。 再来看开头提出的第二个问题：12345// 假设str是你通过ajax接收到的JSON串var str = '&#123;"name": "liu", "age": 20&#125;';var obj = eval('(' + str + ')');console.log(obj); 我们知道，eval(str)会把接收到的字符串在当前上下文中执行，如果不加括号：1eval('&#123;"name": "liu", "age": 20&#125;&#125;') 这里的执行语句就会变成：123&#123; "name" : "liu", "age" : 20&#125; {}按照语句解析，执行里面的逗号表达式，我们知道逗号表达式要求每一项都必须是表达式，输出最后一项的结果，而这里不满足要求，所以会报错。 但是加上括号就变成了这样：123(&#123; "name" : "liu", "age" : 20&#125;) 小括号可以把里面的内容当做表达式来解析，那么里面的内容就是一个对象了。 这也是立即执行函数的原理：123(function () &#123; console.log('IIFE');&#125;)() 小括号把函数声明变成了函数表达式，后面再跟一个小括号表示调用。 结束这里通过几个例子，引出了 JavaScript 的标签声明语句（Label Statement），从而解释了一些我们常用写法的原理。 以后万一有人问你为什么 eval() 解析JSON要加括号呢？这回知道怎么说了吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Label Statement</tag>
        <tag>C语言</tag>
        <tag>Goto语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML - 移动端 meta viewport]]></title>
    <url>%2F2017%2F12%2F10%2Fhtml_meta_viewport%2F</url>
    <content type="text"><![CDATA[我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。 CSS 像素（css pixel） / 密度独立像素（density independent pixels - dip）CSS 像素是 web 编程中的概念，是抽象的，不是实际存在的。它是独立于设备用于逻辑上衡量像素的单位，所以又叫密度独立像素。dip 有时候也缩写为 dp 。 屏幕尺寸指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。 屏幕像素密度（pixels per inch - ppi）指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的 ppi = √(1920^2+1080^2) / 5.5 ≈ 401ppi 。也就是说它每英寸可以显示 440 个物理像素点。 设备像素比指物理像素和密度独立像素的比值。window.devicePixelRatio = 物理像素 / dip。可以通过 window.devicePixelRatio 获得，该属性被所有WebKit浏览器以及Opera所支持。 viewportviewport 是指 web 页面上用户的可见区域。 viewport 的大小是和设备相关的，在移动端例如手机上，viewport 的大小是比 PC 端要小的，一般无论手机还是平板，默认的 viewport 大小都是 980px 。刚开始 web 页面仅仅是在 PC 端进行查看的，但是后来随着移动互联网的发展，越来越多的 web 访问是通过移动端进行的，但是因为 PC 的 viewport 要比移动端大，所以为了快速修复这个问题，移动端的浏览器默认只是把整个页面等比例缩小到移动端的 viewport 大小。 这样做的后果就是，用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。 那么回到我们最开始写的 meta 标签：1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; device-width 是指这个设备最理想的 viewport 宽度。iPhone6 之前的 device-width 都是 320px ，iPhone6 是 375px ，iPhone6 Plus 是 414px ，而这个 device-width 是和 CSS像素（也叫密度独立像素 dip）是相同的。也就是说，web 页面中的 CSS像素的值等于 device-width 时，对应到手机上就是占满全屏的宽度。 安卓手机的 device-width 有320px、360px 和 384px 等等，不同的设备 device-width 是不一样的。 initial-scale=1.0 是指初始化的时候缩放大小是1，也就是不缩放。 user-scalable=0 是指禁止用户进行缩放。 maximum-scale=1.0 是指用户最大缩放大小是1，其实在禁止用户缩放以后，这一句可以省略。 在设计人员为移动端设计页面的时候经常可以听到2倍图和3倍图这些词语，这又是什么意思呢，我们以 iPhone6 举例： iPhone6 的分辨率（也就是物理像素）是 1334*750 像素，它的 device-width 是 375px 。 如果我们将屏幕横向分成 375 份，CSS 中 1px 占用的1份，因为屏幕就那么大，CSS中 width 等于 375px 时横向就会占满全屏，但是实际上存在的物理像素点横向是750个 ，所以在我们写 CSS 时 1px 对应到屏幕上是占用了2个物理像素点。 如果我们不写 width=device-width 这一句的话，默认 viewport 宽是 980px 。那么把 iPhone6 的屏幕横向分成980份，CSS 中 1px 占用1份，但是真正的像素点横向只有750个，这就意味着，实际上渲染出来的宽度是 75/98 个像素大小（只是理论上）。 设计人员在设计原型图的时候以 750px 的宽度为基准，我们在写 CSS的时候缩写一半来使用，但是在渲染的时候 1px 等于 2px 的物理像素，所以整个图片还是按 750px 的宽度来显示的，不会失真。 如果设计人员以 375px 的宽度为基准，那么我们在使用的时候直接把设计图中的像素宽度用在 CSS 中，那么在渲染的时候，1px 等于 2px 的物理像素，相当于图片会放大2倍，就会产生失真。 总结在添加 之后，移动端的 viewport 宽度会从默认的 980px 变成各个设备的 device-width 。 CSS 中的 100% 就等于 device-width 。 知道了这些，我们就可以结合别的知识，为页面进行响应式布局了。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>meta</tag>
        <tag>viewport</tag>
        <tag>pt</tag>
        <tag>dip</tag>
        <tag>ppi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 06 - 变量对象]]></title>
    <url>%2F2017%2F08%2F10%2Fjavascript_06_variable_object%2F</url>
    <content type="text"><![CDATA[上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明： Variable Object 就代表变量对象。Scope Chain 代表作用域链。thisValue 代表神秘的 this 。 作用域链和 this 留到后面再讲，今天我们先来弄明白变量对象。 变量对象 A variable object is a scope of data related with the execution context. It’s a special object associated with the context and which stores variables and function declarations are being defined within the context. 变量对象(variable object) 是与执行上下文相关的数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 变量对象（Variable Object – 简写 VO）是一个抽象的概念，指代与执行上下文相关的特殊对象，它存储着在上下文中声明的： 变量（var） 函数声明 （function declaration，简写 FD） 函数的形参（arguments） 我们假设变量对象为一个普通 ECMAScript 对象：1VO = &#123;&#125;; 就像前面讲过的，VO 是执行上下文的一个属性：12345activeExecutionContext = &#123; VO: &#123; // 上下文数据 （vars, FD, arguments） &#125;&#125; 因为变量对象是一个抽象的概念，所以并不能通过变量对象的名称直接访问，但是却可以通过别的方法来间接访问变量对象，例如在全局上下文环境的变量对象会有一个属性 window (DOM 中) 可以引用变量对象自身，全局上下文环境的另一个属性 this 也指向全局上下文环境的变量对象。 举个例子：1234567891011var a = 2;function foo (num) &#123; var b = 5;&#125;(function exp () &#123; console.log(111);&#125;)foo(10); 这里对应的变量对象是：123456789101112131415161718// 全局上下文环境的变量对象VO(globalContext) = &#123; // 一些全局环境初始化时系统自动创建的属性： Math、String、Date、parseInt等等 ··· // 全局上下文的变量对象中有一个属性可以访问到自身，在浏览器中这个属性是 window ，在 node 中这个属性是 global window: global // 自己定义的属性 a: 10, foo: &lt;reference to function&gt;&#125;;// foo 函数上下文的变量对象VO(foo functionContext) = &#123; num: 10, b: 5&#125;; 注意：函数表达式并不包括在变量对象中。 不同执行上下文中的变量对象执行上下文包括：全局上下文、函数上下文和 eval() 上下文。 全局上下文中的变量对象这里我们先来了解一下什么是全局对象：12全局对象（global object）是指在进入任何执行上下文之前就已经创建了的对象。这个对象只有一份，它的属性在程序中的任何地方都可以访问，全局对象的生命周期终止于程序退出的那一刻。 全局对象初始化时系统将创建并初始化一系列原始属性，例如：Math、String、Date、parseInt、window等等，之后是我们在全局上下文中自己定义的全局变量。在 DOM 中，全局对象的 window 属性可以引用全局对象自身，全局上下文环境的 this 属性也可以引用全局对象。1234567891011121314151617// 全局执行上下文环境EC(globalContext) = &#123; // 全局对象（全局上下文环境的变量对象） global: &#123; Math: &lt;...&gt;, String: &lt;...&gt;, ... ... window: global // 引用全局对象自身 &#125;, // this 属性 this: global // 作用域链 ...&#125; 举个例子：12345var a = 10;console.log(a); // 10console.log(window.a); // 10console.log(this.a); // 10 因此，在全局上下文环境中，变量对象用全局对象来表示。 函数上下文中的变量对象在函数上下文中，变量对象用活动对象 AO（Active Object）来表示。1VO(functionContext) = AO 活动对象是在进入函数上下文时刻被创建的，它是通过函数的 arguments 属性进行初始化。arguments 也是一个对象。12345AO = &#123; arguments: &#123; ... &#125;&#125; arguments 是活动对象的一个属性，它也是一个对象，包括以下属性： callee - 指向当前函数的引用 length - 真正传递的参数个数 properties-indexes - index 是字符串类型的整数，例如”1”: “aa”，类似于数组类型，也可以通过arguments[1]来访问，但是不能用数组的方法（push, pop等等）。另外，properties-indexes 的值和实际传递进来的参数之间是共享的，一个改变，另一个也随之改变。 举个例子：123456789101112131415161718192021222324252627282930function foo (x, y, z) &#123; // 声明的函数参数数量 console.log(foo.length); // 3 // 实际传递进来的参数数量 console.log(arguments.length); // 2 // arguments 的 callee 属性指向当前函数 console.log(arguments.callee === foo) // true // 参数共享 console.log(x === arguments[0]); // true console.log(x); // 10 arguments[0] = 20; console.log(x); // 20 x = 30; console.log(arguments[0]); // 30 // 但是注意，没有传递进来的参数 z ，和第3个索引值是不共享的 z = 40; console.log(arguments[2]); // undefined arguments[2] = 50; console.log(z); // 40&#125;foo(10, 20); 代码是如何被处理的在第1节中我们讲过js 代码的编译过程，其中有一步叫作预编译，是说在代码执行前的几微秒会首先对代码进行编译，形成词法作用域，然后执行。 那么执行上下文的代码就就可以分成两个阶段来处理： 进入执行上下文（预编译） 执行代码 而变量对象的修改变化和这两个阶段是紧密相关的。并且所有类型的执行上下文都会有这2个阶段。 进入执行上下文当引擎进入执行上下文时（代码还未执行），VO 里已经包含了一些属性： 函数的所有形参（如果是函数执行上下文）由名称和对应值组成的一个变量对象的属性被创建，如果没有传递对应的实参，那么由名称和 undefined 组成的一种变量对象的属性也会被创建。 所有的函数声明（Function Declaration - FD）由名称和对应值（函数对象 function object）组成的一个变量对象的属性被创建，如果变量对象已经存在相同名称函数的属性，则完全替换这个属性。 所有的变量声明（Variable Declaration - var）由名称和对应值（在预编译阶段所有变量值都是 undefined）组成的一个变量对象的属性被创建，如果变量名和已经声明的形参或者函数相同，则变量名不会干扰已经存在的这类属性，如果已经存在相同的变量名，则跳过当前声明的变量名。 注意：变量碰到相同名称的变量是忽略，函数碰到相同名称的函数是覆盖。 举个例子：1234567891011function foo (a, b) &#123; var c = 5; function bar () &#123;&#125;; var d = function _d () &#123;&#125;; (function f () &#123;&#125;);&#125;foo(10); 当进入带有实参10的 foo 函数上下文时（预编译时，此时代码还没有执行），AO 结构如下：12345678AO(foo) = &#123; a: 10, b: undefined, c: undefined, bar: &lt;reference to FunctionDelcaration "bar"&gt;, d: undefined &#125;; 注意，函数表达式 f 并不包含在活动对象 AO 内。也就是说，只有函数声明会被包含在变量对象 VO 里面，函数表达式并不会影响变量对象。 行内函数表达式 _d 则只能在该函数内部可以使用， 也不会包含在 VO 内。 这之后，就会进入第2个阶段，代码执行阶段。 代码执行在这个阶段，AO/VO 已经有了属性（并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined）。 AO 在代码执行阶段被修改如下：12AO['c'] = 5;AO['d'] = &lt;reference to FunctionDelcaration "_d"&gt; 再次要提醒大家，因为函数表达式 _d 已经保存到了声明的变量 d 上面，所以变量 d 仍然存在于 VO/AO 中。我们可以通 d() 来执行函数。但是函数表达式 f 却不存在于 VO/AO 中，也就是说，如果我们想尝试调用 f 函数，不管在函数定义前还是定义后，都会出现一个错误”f is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。 再来一个经典例子：12345678910console.log(x); // functionvar x = 10;console.log(x); // 10x = 20;function x () &#123;&#125;;console.log(x); // 20 这里为什么是这样的结果呢？ 上边我们说过，在代码执行之前的预编译，会为变量对象生成一些属性，先是形参，再是函数声明，最后是变量，并且变量并不会影响同名的函数声明。 所以，在进入执行上下文时，AO/VO 结构如下：12345AO = &#123; x: &lt;reference to FunctionDeclaration "x"&gt; // 在碰到变量声明 x 时，因为已经存在了函数声明 x ，所以会忽略&#125; 紧接着，在代码执行阶段，AO/VO 被修改如下：12AO['x'] = 10;AO['x'] = 20; 希望大家可以好好理解变量对象，对于理解我们后边要讲的作用域链有很大的帮助。 变量有一些文章说过： 不管是使用 var 关键字（在全局上下文）还是不使用 var 关键字（在任何地方），都可以声明一个变量。 请记住，这是错误的观念。 任何时候，变量都只能通过使用 var 关键字来声明（ES6 之前）。 1a = 10; 上面的赋值语句，仅仅是给全局对象创建了一个新属性（在在非严格模式，严格模式下会报错），但注意，它不是变量。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript 规范中变量的概念。 让我们通过一个例子来看一下两者的区别：12345console.log(a); // undefinedconsole.log(b); // 报错，b is not definedb = 10;var a = 20; 只要我们很好的理解了：变量对象、预编译阶段和执行代码阶段，就可以迅速的给出答案。 预编译（进入上下文）阶段：123VO = &#123; a: undefined&#125; 我们可以看到，因为 b 不是通过 var 声明的，所以这个阶段根本就没有 b ，b 只有在代码执行阶段才会出现。但是在这个例子中，还没有执行到 b 那就已经报错了。 我们稍微更改一下示例代码：123456789console.log(a); // undefinedb = 10;console.log(b); // 10 代码执行阶段被创建console.log(window.b); // 10console.log(this.b); // 10var a = 20;console.log(a); // 20 代码执行阶段被修改 关于变量，还有一个很重要的知识点。 变量不能用 delete 操作符来删除。1234567891011121314a = 10;console.log(window.a); // 10console.log(delete a); // trueconsole.log(window.a); // undefinedvar b = 20;console.log(window.b); // 20console.log(delete b); // falseconsole.log(window.b); // 20 注意：这个规则在 eval() 上下文中不起作用。 123456eval('var a = 10;');console.log(window.a); // 10console.log(delete a); // trueconsole.log(window.a); // undefined 总结这一节中我们讲了变量对象，下一节就是我们的重头戏 - 作用域链。希望大家可以持续关注我，我们一起进步。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>执行上下文</tag>
        <tag>变量对象</tag>
        <tag>Execution Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 05 - 执行上下文]]></title>
    <url>%2F2017%2F06%2F03%2Fjavascript_05_execution_context%2F</url>
    <content type="text"><![CDATA[在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。 可执行代码有几种前面说到当引擎执行到可执行代码的时候，就会将当前上下文压入上下文栈中。那么可执行的代码又分为几种？ 在这里，我们先假设定义执行上下文栈是一个数组：1EC = []; 第一种可执行代码 – 全局代码：全局类型代码是在加载外部的 js 文件或者本地 标签中的代码。注意，在全局代码中，并不包含定义在全局环境 function 内的代码。 程序启动后进入初始化全局环境：123EC = [ globalContext]; 第二种可执行代码 – 函数代码：当定义的函数被执行时，就进入了函数代码，当前函数上下文被压入 EC 栈中。注意，在函数代码中，也不包含定义在该函数内部环境 function 内的代码。 例如：123456789var a = 10;function foo () &#123; var b = 20; foo();&#125;foo(); 这个例子中的 EC 是什么样子的呢？ 1234567891011121314151617181920212223242526272829// 初始化EC = [ globalContext];// 第一次调用 foo 函数EC = [ &lt;foo&gt; functionContext, globalContext];// 在 foo 内递归调用自己EC = [ &lt;foo&gt; functionContext - recursively, &lt;foo&gt; functionContext, globalContext];// 继续递归调用自己EC = [ ...... &lt;foo&gt; functionContext - recursively2, &lt;foo&gt; functionContext - recursively, &lt;foo&gt; functionContext, globalContext];// 递归会不断调用下去，因为没有结束条件，所以这是一个死循环// 所以，EC 只会不断增加新的上下文，但是却不会退出 只有每次 return 的时候，才会退出当前执行上下文，相应上下文会从栈中弹出，栈指针会自动移动位置。 注意，当函数没有明确指明 return 什么的时候，默认 return undefined 。 如果有抛出的异常没有被截获的话，也有可能从一个或多个执行上下文中退出。当所有代码执行完以后，EC 中只会包含全局上下文（global context），当程序退出以后，全局上下文也会退出。 第三种可执行代码 – eval 代码：eval 函数在调用的时候会产生上下文。例如：12345678eval('var a = 10');(function foo () &#123; eval('var b = 20');&#125;());alert(a); // 10alert(b); // ReferenceError，b is not defined 这个例子中 EC 的变化如下：123456789101112131415161718192021222324252627282930313233343536373839// 初始化EC = [ globalContext];// eval('var a = 10');EC = [ evalContext, globalContext];// eval 执行完毕EC = [ globalContext];// 立即执行函数 fooEC = [ &lt;foo&gt; functionContext, globalContext];// eval('var b = 20');EC = [ evalContext, &lt;foo&gt; functionContext, globalContext];// eval 执行完毕EC = [ &lt;foo&gt; functionContext, globalContext];// foo 执行完毕EC = [ globalContext]; 这就是一个典型的逻辑调用上下文栈。 在 setTimeout 和 setInterval 函数中的第一个参数也可以传入代码字符串，但是这个一般不会这么去用，所以这里也就不讨论了。 结论执行上下文环境是我们了解变量对象和作用域链的基础，大家一定要好好理解（其实也并不难），下一节我们来讨论变量对象，相信会让大家有一定的收获。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 04 - 提升]]></title>
    <url>%2F2017%2F05%2F10%2Fjavascript_04__variable_lifting%2F</url>
    <content type="text"><![CDATA[到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。 声明提升先看代码：12345a = 2;var a;console.log(a); 大家认为这里会输出什么？ 有一些人认为是 undefined ，因为 var a; 是在 a = 2; 之后，所以会觉得 undefined 覆盖了 a 的值。但是，真正的结果是 2 。 再看一段代码：1234567891011121314console.log(a);var a = 2;``` 鉴于上一个例子，有些人会认为这里会输出 2 ，也有人认为由于 a 在使用前并没有声明，所以这里会报错。但是，这里的结果是 undefined 。之前讨论编译器的时候，我们知道 JS 引擎会在解释代码之前首先对其进行编译。编译阶段的第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。因此，正确的思路是，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。当你看到 ***var a = 2;*** 时，JavaScript 实际上会将其看成两个声明：***var a;*** 和 ***a = 2;*** 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。所以，在第一个例子中，代码的等价形式是这样的： var a; a = 2; console.log(a);1第二个例子中，代码的等价形式是这样的： var a; console.log(a); a = 2;12345这个过程就好像是变量和函数声明从它们的代码中出现的位置被“移动”到了最上面。这个过程就叫作“提升”。**注意**，只有声明本身会被提升，而赋值操作和其他运行逻辑都会停留在原地，想象一下，如果提升会改变代码的执行顺序，那么会造成非常严重的破坏。还有一点，函数声明会被提升，但是函数表达式不会被提升。 foo(); // 报错，TypeError: foo is not a function，因为这里 foo 是 undefined，并不是一个函数 var foo = function foo() { // something else}123这段程序中的变量标识符 foo 被提升并分配给所在的作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError 。但是，foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会被赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，所以会抛出 TypeError 异常。同时，即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： foo();bar(); var foo = function bar () { // something else};1这段代码经过提升后，实际上等价于： var foo; foo();bar(); foo = function () { var bar = …self… // something else};12345### 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节是，**函数声明会首先被提升，然后才是变量。**考虑如下代码： foo(); // 1 var foo; function foo () { console.log(1);} foo = function () { console.log(2);};1这里会输出 1 而不是 2 。这段代码其实等价于： function foo () { console.log(1);} foo(); // 1 foo = function () { console.log(2);};123***var foo;*** 尽管出现在 function foo() &#123;...&#125; 声明之前，但是它是重复声明，所以会被编译器忽略，因为函数声明会被提升到变量声明之前。注意，尽管重复的 var 声明会被忽略，但重复的函数声明却会覆盖前一个同名函数。 foo(); // 3 function foo () { console.log(1);} var foo = function () { console.log(2);}; foo(); // 2 function foo () { cosole.log(3);}1这个例子充分说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。上面那个例子，等价于： function foo () { cosole.log(3);} foo(); // 3 foo = function () { console.log(2);}; foo(); // 212还有一些人会犯如下错误： foo(); // 2 var a = true; if (a) { function foo () { console.log(1); }} else { function foo () { console.log(2); }}1因为 if 并没有块作用域，所以这里的函数声明会提升到其作用域最前边，而后一个 function 声明会覆盖前一个，所以这里结果是 2 。这里代码等价如下： function foo () { console.log(2);} var a; foo(); // 2 a = true; if (a) { } else { }` 总结我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a; 和 a = 2; 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被处理（预编译）。可以将这个过程想象成所有的声明（变量和函数）都会被“移动”到各自的作用域的最顶端，这个过程叫作提升。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 03 - 函数作用域和块作用域]]></title>
    <url>%2F2017%2F04%2F10%2Fjavascript_03__function_scope%2F</url>
    <content type="text"><![CDATA[在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上 在这段代码中，函数 foo 的作用域包含了标识符a、b、c 和 bar ，函数 bar 的作用域中又包含别的标识符。 由于标识符 a、b、c 和 bar都属于函数 foo 的作用域，所以在全局作用域中访问会报错，因为它们都没有定义，但是在函数 foo 内部，这些标识符都是可以访问的，这就是函数作用域。 为什么要有这些作用域当我们用作用域把代码包起来的时候，其实就是对它们进行了“隐藏”，让我们对其有控制权，想让谁访问就可以让谁访问，想禁止访问也很容易。 想像一下，如果所有的变量和函数都在全局作用域中，当然我们可以在内部的嵌套作用域中访问它们，但是因为暴露了太多的变量或函数，它们可能被有意或者无意的篡改，以非预期的方式使用，这就导致我们的程序会出现各种各样的问题，严重会导致数据泄露，造成无法挽回的后果。 例如：123456789var obj = &#123; a: 2, getA: function () &#123; return this.a; &#125;&#125;;obj.a = 4;obj.getA(); // 4 这个例子中，我们可以任意修改对象 obj 内部的值，在某种情况下这并不是我们所期望的，采用函数作用域就可以解决这个问题，私有化变量 a 。12345678910111213141516var obj = (function () &#123; var a = 2; return &#123; getA: function () &#123; return a; &#125;, setA: function (val) &#123; a = val; &#125; &#125;&#125;());obj.a = 4;obj.getA(); // 2obj.setA(8);obj.getA(); // 8 这里通过立即执行函数（IIFE）返回一个对象，只能通过对象内的方法对变量 a 进行操作，其实这里有闭包的存在，这个我们在以后会深入讨论。 “隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，冲突会导致变量的值被意外覆盖。 例如：123456789101112function foo () &#123; function bar (a) &#123; i = 3; // 修改了 for 循环所属作用域中的 i console.log(a + i); &#125; for (var i = 0; i &lt; 10; i++) &#123; bar(i * 2); // 这里因为 i 总会被设置为 3 ，导致无限循环 &#125;&#125;foo(); bar(…) 内部的赋值表达式 i = 3 意外的覆盖了声明在 foo(…) 内部 for 循环中的 i ，在这个例子中因为 i 始终被设置为 3 ，永远满足小于 10 这个条件，导致无限循环。 bar(…) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3; 就可以满足这个要求。另外一种方法是采用一个完全不同的标识符名称，比如 var j = 3; 。但是软件设计在某种情况下可能自然而然的要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。 总结来说，作用域可以起到两个作用： 私有化变量或函数 规避同名冲突 函数声明和函数表达式如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 函数声明举个例子：123function foo () &#123; // something else&#125; 这就是一个函数声明。 函数表达式分为匿名函数表达式和具名函数表达式。 对于函数表达式来说，最熟悉的场景可能就是回调参数了，例如：123setTimeout(function () &#123; console.log("I wait for one second.")&#125;, 1000); 这个叫作匿名函数表达式，因为 function ()… 没有名称标识符。函数表达式可以是匿名的，但是函数声明不可以省略函数名，在 javascript 中这是非法的。 匿名函数表达式书写简便，但是它也有几个缺点需要注意： 匿名函数在浏览器栈追踪中不会显示出有意义的函数名，这会加大调试难度。 如果没有函数名，当函数需要引用自身的时候就只能使用已经不是标准的 arguments.callee 来引用，比如递归。在事件触发后的事件监听器中也有可能需要通过函数名来解绑自身。 匿名函数对代码的可读性和可理解性有一定的影响。一个有意义的函数名可以让代码不言自明。 具名函数表达式又叫行内函数表达式，例如：123setTimeout(function timerHandler () &#123; console.log("I wait for one second.")&#125;, 1000); 这样，在函数内部需要引用自身的时候就可以通过函数名来引用，当然要注意，这个函数名只能在这个函数内部使用，在函数外使用时未定义的。 立即执行函数表达式（IIFE）IIFE 全写是 Immediately Invoked Function Expression，立即执行函数。12345678var a = 2;(function foo () &#123; var a = 3; console.log(a); // 3&#125;)();console.log(a); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个函数表达式，通过在末尾加上另一对 ( ) 括号可以立即执行这个函数，比如 (function () {})() 。第一个 ( ) 将函数变成函数表达式，第二个 ( ) 执行了这个函数。 也有另外一种立即执行函数的写法，(function () {}()) 也可以立即执行这个函数。12345678var a = 2;(function foo () &#123; var a = 3; console.log(a); // 3&#125;());console.log(a); // 2 这两种写法功能是完全一样的，具体看大家使用。 IIFE 的另一种普遍的进阶用法是把它们当做函数调用并传递参数进去。123456789var a = 2;(function (global) &#123; var a = 3; console.log(a); // 3 console.log(global.a) // 2&#125;)(window);console.log(a); // 2 我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递你需要的任何东西，并将变量命名为任何你觉得合适的文字。这对于改进代码风格是非常有帮助的。 这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖的异常（这并不常见）。将一个参数命名为 undefined ，但是并不传入任何值，这样就可以保证在代码块中 undefined 的标识符的值就是 undefined 。12345678undefined = true;(function IIFE (undefined) &#123; var a; if (a === undefined) &#123; console.log("Undefined is safe here.") &#125;&#125;()); 块作用域ES5 及以前 JavaScript 中具有块作用域的只有 with 和 try…catch 语句，在 ES6 及以后的版本添加了具有块作用域的变量标识符 let 和 const 。 with123456789101112var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); // 2 console.log(b); // 3&#125;console.log(a); // 报错，a is not definedconsole.log(b); // 报错，a is not defined 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 try…catch1234567try &#123; undefined(); // 非法操作&#125; catch (err) &#123; console.log(err); // 正常执行&#125;console.log(err); // 报错，err is not defined try/catch 中的 catch 分句会创建一个块作用域，其中的变量声明仅在 catch 内部有效。 letlet 关键字可以将变量绑定到任意作用域中（通常是 {…} 内部）。换句话说，let 为其声明的变量隐式的劫持了所在的块作用域。1234567891011var foo = true;if (foo) &#123; let a = 2; var b = 2; console.log(a); // 2 console.log(b); // 2&#125;console.log(b); // 2console.log(a); // 报错，a is not defined 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些代码块作用域中有绑定的变量，并且习惯性的移动这些块或者将其包含到其他块中，就会导致代码混乱。 为块作用域显示的创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。12345678var foo = true;if (foo) &#123; &#123; let a = 2; console.log(a); // 2 &#125;&#125; 在代码的任意位置都可以使用 {…} 括号来为 let 创建一个用于绑定的块。 还有一点要注意的是，在使用 var 进行变量声明的时候会存在变量提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会存在作用域提升，声明的变量在被运行之前，并不存在。123456789console.log(a); // undefinedconsole.log(b); // 报错， b is not defined// 在浏览器中运行这段代码时，因为前面报错了，所以不会看到接下来打印的结果，但是理论上就是这样的结果var a = 2;console.log(a); // 2 let b = 4;console.log(b); // 4 2.3.1 垃圾收集另一个块作用域非常有用的原因和闭包及垃圾内存的回收机制有关。举个例子：12345678910111213function processData (data) &#123; // do something&#125;var bigData = &#123;...&#125;;processData(bigData);var btn = document.getElementById('my_button');btn.addEventListener('click', function () &#123; console.log('button clicked');&#125;, false); 这个按钮点击事件的回调函数中并不需要 bigData 这个非常占内存的数据，理论上来说，当 processData 函数处理完之后，这个占有大量空间的数据结构就可以被垃圾回收了。但是，由于这个事件回调函数形成了一个覆盖当前作用域的闭包，JavaScript 引擎极有可能依然保存着这个数据结构（取决于具体实现）。 使用块作用域可以解决这个问题，可以让引擎清楚的知道没有必要继续保存这个 bigData 。123456789101112131415function processData (data) &#123; // do something&#125;&#123; let bigData = &#123;...&#125;; processData(bigData);&#125;var btn = document.getElementById('my_button');btn.addEventListener('click', function () &#123; console.log('button clicked');&#125;, false); 2.3.2 let 循环一个 let 可以发挥优势的典型例子就是 for 循环。12345678910var lists = document.getElementsByTagName('li');for (let i = 0, length = lists.length; i &lt; length; i++) &#123; console.log(i); lists[i].onclick = function () &#123; console.log(i); // 点击每个 li 元素的时候，都是相对应的 i 值，而不像用 var 声明 i 的时候，因为没有块作用域，所以在回调函数通过闭包查找 i 的时候找到的都是最后的 i 值 &#125;;&#125;;console.log(i); // 报错，i is not defined for 循环头部的 let 不仅将 i 绑定到 fir 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保上一个循环迭代结束时的值重新进行赋值。 当然，我们在 for 循环中使用 var 时也可以通过立即执行函数形成一个新的闭包来解决这个问题。123456789var lists = document.getElementsByTagName('li');for (var i = 0, length = lists.length; i &lt; length; i++) &#123; lists[i].onclick = (function (j) &#123; return function () &#123; console.log(j); &#125; &#125;(i));&#125; 或者123456789var lists = document.getElementsByTagName('li');for (var i = 0, length = lists.length; i &lt; length; i++) &#123; (function (i) &#123; lists[i].onclick = function () &#123; console.log(i); &#125; &#125;(i));&#125; 其实原理无非就是，为每个迭代创建新的闭包，立即执行函数执行完后本来应该销毁变量，释放内存，但是因为这里有回调函数的存在，所以形成了闭包，然后通过形参进行同名变量覆盖，所以找到的 i 值就是每个迭代新闭包中的形参 i 。 const除了 let 以外，ES6 还引入了 const ，同样可以用来创建作用域变量，但其值是固定的（常亮）。之后任何试图修改值的操作都会引起错误。123456789101112var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常亮 a = 3; // 正常 b = 4; // 报错，TypeError: Assignment to constant variable&#125;console.log(a); // 3console.log(b); // 报错， b is not defined 和 let 一样，const 声明的变量也不存在“变量提升”。 总结函数是 JavaScript 中最常见的作用域单元。块作用域指的是变量和函数不仅可以属于所处的函数作用域，也可以属于某个代码块。 本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用哪种作用域，创造可读、可维护的优良代码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 02 - 词法作用域]]></title>
    <url>%2F2017%2F03%2F05%2Fjavascript_02_static_scope%2F</url>
    <content type="text"><![CDATA[两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。 举个例子：12345678910111213var a = 2;function foo1 () &#123; console.log(a);&#125;function foo2 () &#123; var a = 10; foo1();&#125;foo2(); 这里输出结果是多少呢？ 注意，这里结果打印的是 2。 可能会有一些同学认为是 10，那就是没有搞清楚词法作用域的概念。前边介绍了，词法作用域只取决于代码书写时的位置，那么在这个例子中，函数 foo1 定义时的位置决定了它的作用域，通过下图理解： foo1 和 foo2 都是分别定义在全局作用域中的函数，它们是并列的，所以在 foo1 的作用域链中并不包含 foo2 的作用域，虽然在 foo2 中调用了 foo1，但是 foo1 对变量 a 进行 RHS 查询时，在自己的作用域没有找到，引擎会去 foo1 的上级作用域（也就是全局作用域）中查找，而并不会去 foo2 的作用域中查找，最终在全局作用域中找到 a 的值为 2。 总结来说，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法JavaScript 中有 3 种方式可以用来“欺骗词法”，动态改变作用域。 第一种： eval JavaScript 中 eval(…) 函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 在执行 eval(…) 之后的代码时，引擎并不知道或在意前面的代码是以动态形式插入进来并对词法作用域环境进行修改的，引擎只会像往常一样正常进行词法作用域的查找。 举个例子：123456789function foo (str) &#123; eval(str); // "欺骗"词法 console.log(a);&#125;var a = 2;foo("var a = 10;"); 如大家所想，输出结果为 10。因为 eval(“var a = 10;”) 在 foo 的作用域中新创建了一个同名变量 a，引擎在 foo 作用域中对 a 进行 RHS 查询，找到了新定义的 a，值为 10，所以不再向上查找全局作用域中的 a，所以导致输出结果为 10，这就是 eval(…) 的作用。 在严格模式下，eval(…) 在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。 1234567891011'use strict;'function foo (str) &#123; eval(str); // eval() 有自己的作用域，所以并不会修改 foo 的词法作用域 console.log(a);&#125;var a = 2;foo("var a = 10;"); 这里输出结果为 2。 JavaScript 中还有一些功能和 eval(…) 类似的函数，例如 setTimeout(…) 和 setInterval(…) 的第一个参数可以是一个字符串，字符串的内容可以解释为一段动态生成的代码。这些功能已经过时并且不被提倡，最好不要使用它们。new Function(…) 函数的最后一个参数也可以接受代码字符串，并将其转化为动态生成的函数，也尽量避免使用。 在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。 第二种： withwith 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 举个例子：123456789101112var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); // 2 console.log(b); // 3 c = 4; &#125;;console.log(c); // 4, c 被泄露到全局作用域上 如上所示，我们对 c 进行 LHS 查询，因为在 with 引入的新作用域中没有找到 c，所以向上一级作用域（这里是全局作用域）查找，也没有找到，在非严格模式下，在全局对象中新建了一个属性 c 并赋值为 4。 with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会限制在这个块作用域中，而是被添加到 with 所处的函数作用域中。 严格模式下，with 被完全禁止使用。1234567891011121314'use strict';var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); console.log(b); c = 4; &#125;;console.log(c); 第三种： try…catchtry…catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。 举个例子：12345678910try &#123; foo();&#125; catch (err) &#123; console.log(err); var a = 2; // 打印出 "ReferenceError: foo is not defined at &lt;anonymous&gt;:2:4"&#125;console.log(a); // 2 当 try 中的代码出现错误时，就会进入 catch 块，此时会把异常对象添加到作用域链的最前端，类似于 with 一样，catch 中定义的局部变量也都会添加到包含 try…catch 的函数作用域（或全局作用域）中。 性能JavaScript 引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数定义的位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了 eval(…)、with 和 try…catch ，它只能简单的假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(…) 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了这些动态添加作用域的代码，所有的优化可能都是无意义的，因此最简单的做法就是完全不进行任何优化。 如果代码中大量使用 eval(…) 和 with，那么运行起来一定会变得非常缓慢。 结论很多时候我们对代码的分析出错，就是源于对词法作用域的忽略，所以让我们重新审视代码，继续努力！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 01 - 编译原理和作用域]]></title>
    <url>%2F2017%2F02%2F10%2Fjavascript_01_principles_of_compiler%2F</url>
    <content type="text"><![CDATA[在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。 编译原理大家通常把 javascript 归类为一种“动态”或“解释执行”的语言，但事实上，它是一门编译语言，但和传统的编译语言不同，它不是提前编译的，编译结果也不能进行移植。 在传统编译语言中，程序在执行之前会经历三个步骤，统称为“编译”： 分词/词法分析这个过程会把字符串分解成有意义的代码块，这些代码块被称为词法单元。例如 var a = 5; 这段程序通常会被分解成下面这些词法单元： var、a、=、5、; 。空格是否会被当成词法单元取决于空格在这门语言中是否有意义。 解析/语法分析这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。var a = 5; 的抽象语法树中可能如下图所示： 代码生成将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。简单来说，就是通过某种方法可以将 var a = 5; 的 AST 转化为一组机器指令，用来创建一个叫做 a 的变量（包括分配内存等），并将一个值 5 存储在 a 中。 比起那些编译过程只有三个步骤的语言的编译器来说，javascript 引擎要复杂的多。例如，在词法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 首先我们要清楚，javaScript 引擎不会有太多的时间来进行优化（相对于其它语言的编译器来说），因为与其它语言不同，javascript 的编译过程不是发生在构建之前的。 对于 javascript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在我们将要讨论的作用域背后，javascript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至重新编译）来保证性能最佳。 总结来说，任何 javascript 代码片段在执行前都要进行编译（预编译）。因此，javascript 编译器首先会对 var a = 5; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。 三位好友要真正理解作用域，我们首先要知道 javascript 中有三位好朋友： 引擎从头到尾负责整个 javascript 程序的编译及执行过程。 编译器负责语法分析及代码生成。 作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 当遇见 var a = 5; 这一段代码时，其实执行了两个步骤： （1）var a; 编译器会询问作用域是否已经有一个该名称的变量存在于同一作用域的集合中。如果是，编译器会忽略该声明，继续进行编译，否则它会要求在当前作用域的集合中声明一个新的变量，并命名为 a 。（2）a = 5; 编译器会为引擎生成运行时所需的代码，这些代码用来处理 a = 5; 这个赋值操作。引擎运行时会首先询问作用域，在当前作用域的集合中是否存在一个叫作 a 的变量，如果是，引擎就会使用这个变量。如果否，引擎会继续向父级作用域中查找，直到找到全局作用域，如果在全局作用域中仍没有找到 a ，那么在非严格模式下，引擎会为全局对象新建一个属性 a ，并将其赋值为5，在严格模式下，引擎会报错误 ReferenceError: a is not defined。 总结来说，变量的赋值会执行两个操作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在当前作用域中查找该变量（找不到就向上一级作用域查找），如果能够找到就会对它赋值。 LHS 和 RHS前面说到引擎在为变量赋值的时候会在作用域中查找变量，但是执行怎样的查找，用什么方式，会对最终的查找结果造成影响。 在 var a = 5; 这个例子中，引擎会对 a 进行 LHS 查询，当然，另外一个查找类型叫作 RHS。 对变量进行赋值所执行的查询叫 LHS。找到并使用变量值所执行的查询叫 RHS。 举个例子：12345678910function foo(a) &#123; // 这里隐式包含了 a = 2 这个赋值，所以对 a 进行了 LHS 查询 var b = a; // 这里对 a 进行了 RHS 查询，找到 a 的值，然后对 b 进行 LHS 查询，把 2 赋值给 b return a + b; // 这里包含了对 a 和 b 进行的 RHS 查询&#125;var c = foo(2);// 这里首先对 foo 进行 RHS 查询，找到它是一个函数，然后对 c 进行 LHS 查询把 foo 赋值给 c 所以上面的例子共包含 3 个 LHS 查询和 4 个 RHS 查询，你们都找对了吗？ 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 举个例子：1234567function foo(a) &#123; console.log(a + b);&#125;var b = 2;foo(2); // 4 这里对 b 进行的 RHS 查询在 foo 作用域中无法找到，但可以在上一级作用域（这个例子中就是全局作用域）中找到。 总结来说，遍历嵌套作用域链的规则很简单：引擎从当前执行的作用域中开始查找变量，如果都找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 总结编译器、引擎和作用域是 javascript 代码执行的基础，掌握好这些会对我们深入学习 javascript 起到事半功倍的效果，我们的学习之路才刚刚开始，大家加油！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
