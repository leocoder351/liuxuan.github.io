<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript数据结构02 - 栈]]></title>
    <url>%2F2018%2F07%2F25%2Fjavascript_data_structure_02_stack%2F</url>
    <content type="text"><![CDATA[![label-statement](http://image.liuxuan.site/blog/20180725/stack.jpg?imageView2/1/w/1000/h/400) ## 一、定义 ### 1.1 背景 通过前面一节[《JavaScript数据结构01 - 数组》](https://blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/)我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。 有两种数据结构类似于数组，但在添加和删除元素时更为可控。 它们就是**栈和队列**。 ### 1.2 概念 **栈**是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作**栈顶**，另一端就叫**栈底**。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。 ## 二、栈的实现 ### 2.1 创建一个类来表示栈 这里我还是用构造函数的形式来书写，大家有兴趣可以用ES6的Class来重写一遍。 123456789101112// Stack类function Stack () &#123; this.items = []; this.push = push; this.pop = pop; this.peek = peek; this.isEmpty = isEmpty; this.clear = clear; this.size = size; this.print = print;&#125; 栈里面有一些声明的方法： - push(element)：添加一个（或几个）新元素到栈顶 - pop()：移除栈顶的元素，同时返回被移除的元素 - peek()：返回栈顶的元素，不对栈做任何修改 - isEmpty()：如果栈里没有任何元素就返回true，否则返回false - clear()：移除栈里的所有元素 - size()：返回栈里的元素个数 ### 2.2 实现栈中的辅助方法 12345678910111213141516171819202122232425262728293031323334// 添加新元素到栈顶function push (element) &#123; this.items.push(element);&#125;// 移除栈顶元素，同时返回被移除的元素function pop () &#123; return this.items.pop();&#125;// 查看栈顶元素function peek () &#123; return this.items[this.items.length - 1];&#125;// 判断是否为空栈function isEmpty () &#123; return this.items.length === 0;&#125;// 清空栈function clear () &#123; this.items = [];&#125;// 查询栈的长度function size () &#123; return this.items.length;&#125;// 打印栈里的元素function print () &#123; console.log(this.items.toString());&#125; ### 2.3 创建实例进行测试 12345678910111213141516// 创建Stack实例var stack = new Stack();console.log(stack.isEmpty()); // truestack.push(5); // undefinedstack.push(8); // undefinedconsole.log(stack.peek()); // 8stack.push(11); // undefinedconsole.log(stack.size()); // 3console.log(stack.isEmpty()); // falsestack.push(15); // undefinedstack.pop(); // 15console.log(stack.size()); // 3stack.print(); // 5,8,11stack.clear(); // undefinedconsole.log(stack.size()); // 0 ## 三、结束 本文会同步到我的[个人博客](https://blog.liuxuan.site)，完整代码可以到我的[github仓库查看](https://github.com/leocoder351/data-structure)，如果对你有帮助的话欢迎点一个Star~~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据结构01 - 数组]]></title>
    <url>%2F2018%2F07%2F25%2Fjavascript_data_structure_01_array%2F</url>
    <content type="text"><![CDATA[![label-statement](http://image.liuxuan.site/blog/20180725/array.jpg?imageView2/1/w/1000/h/400) ## 一、创建数组 #### 1.1 使用Array构造函数 123var arr1 = new Array(); // 创建一个空数组var arr2 = new Array(10); // 创建一个包含20项的数组var arr3 = new Array('liu', 'wang', 'li'); // 创建一个包含3个字符串的数组 #### 1.2 使用数组字面量表示法 123var arr1 = []; // 创建一个空数组var arr2 = [10]; // 创建一个包含1项的数组var arr3 = ['liu', 'wang', 'li']; // 创建一个包含3个字符串的数组 ## 二、常用数组方法 |方法名|描述| |------|----| |join|把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔| |pop|删除并返回数组的最后一个元素| |push|向数组的末尾添加一个或更多元素，并返回新的长度| |shift|删除并返回数组的第一个元素| |unshift|向数组的开头添加一个或更多元素，并返回新的长度| |slice|从某个已有的数组返回指定的元素| |indexOf|返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1| |lastIndexOf|返回在数组中搜索到的与给定参数相等的元素的索引里的最大的值，没有找到则返回-1| |sort|对数组的元素进行排序| |splice|删除元素，并向数组添加新元素| |toString|把数组转换为字符串，并返回结果| |toLocaleString|把数组转换为本地字符串，并返回结果| |valueOf|返回数组对象的原始值| |forEach|对数组中的每一项运行指定函数，这个方法没有返回值| |concat|连接2个或更多数组，并返回结果| |every|对数组中的每一项运行指定函数，如果该函数对每一项都返回true，则返回true| |some|对数组中的每一项运行指定函数，如果任一项返回true，则返回true| |filter|对数组中的每一项运行指定函数，返回该函数会返回true的项组成的数组| |reverse|颠倒数组中元素的顺序| |map|对数组中的每一项运行指定函数，返回每次函数调用的结果组成的数组| |reduce|接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值| |reduceRight|接收一个函数作为累加器，数组中的每个值（从右到左）开始缩减，最终计算为一个值| **PS：原始值是指固定而简单的值，存放在栈中的简单数据段，它们的值直接存储在变量访问的位置。** JavaScript中有五种原始类型，也叫基本类型： **Number、String、Boolean、Undefined、Null** ## 三、演示实例 #### 3.1 join **定义和用法** join()方法用于把数组中的所有元素放入一个字符串。 元素是通过指定的分隔符进行分隔的。 **语法** > arrayObject.join(separator) |参数|描述| |---|----| |seperator|可选。指定要使用的分隔符，如果省略该参数，则使用逗号作为分隔符| **返回值** 返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。 1234567891011121314var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";var str1 = arr.join();var str2 = arr.join('');var str3 = arr.join(' ');var str4 = arr.join('-');console.log(str1); // "Geroge,John,Thomas"console.log(str2); // "GerogeJohnThomas"console.log(str3); // "Geroge John Thomas"console.log(str4); // "Geroge-John-Thomas" #### 3.2 pop **定义和用法** pop()方法用于删除并返回数组的最后一个元素。 **语法** > arrayObject.pop() **返回值** arrayObject 的最后一个元素。 **说明** pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 12345678var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.pop()); // "Thomas"console.log(arr); // ["Geroge", "Thomas"] #### 3.3 push **定义和用法** push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。 **语法** > arrayObject.push(newElement1, newElement2, ..., newElementX) |参数|描述| |---|----| |newElement1|必需。要添加到数组末尾的第一个元素| |newElement2|可选。要添加到数组末尾的第二个元素| |newElementX|可选。可添加多个元素| **返回值** 把指定的值添加到数组后的新长度。 **说明** push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 12345678910var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.push("James")); // 4console.log(arr); // ["Geroge", "John", "Thomas", "James"]console.log(arr.push("Peter", "Sara")); // 6console.log(arr); // ["Geroge", "John", "Thomas", "James", "Peter", "Sara"] #### 3.4 shift **定义和用法** shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 **语法** > arrayObject.shift() **返回值** 数组原来的第一个元素的值。 **说明** 如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。 12345678var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.shift()); // "Geroge"console.log(arr); // ["John", "Thomas"] #### 3.5 unshift **定义和用法** unshift()方法可向数组的开头添加一个或多个元素，并返回新的长度。 **语法** > arrayObject.unshift(newElement1, newElement2, ..., newElementX) |参数|描述| |---|----| |newElement1|必需。要添加到数组开头的第一个元素| |newElement2|可选。要添加到数组开头的第二个元素| |newElementX|可选。可添加多个元素| **返回值** arrayObject 的新长度。 **说明** unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。 12345678910var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.unshift("James")); // 4console.log(arr); // ["James", "Geroge", "John", "Thomas"]console.log(arr.unshift("Peter", "Sara")); // 6console.log(arr); // ["Peter", "Sara", "James", "Geroge", "John", "Thomas"] #### 3.6 slice **定义和用法** slice()方法可从已有的数组中返回选定的元素。slice()方法不改变原数组。 **语法** > arrayObject.slice(start, end) |参数|描述| |-------|----| |start|必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。| |end|可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从start到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。| **返回值** 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 **说明** 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 12345678910111213141516var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"]console.log(arr.slice(0)); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"]console.log(arr.slice(1)); // ["John", "Thomas", "James", "Adrew", "Martin"]console.log(arr.slice(1, 3)); // ["John", "Thomas"]console.log(arr.slice(1, -2)); // ["John", "Thomas", "James"]console.log(arr.slice(-1, -2)); // []console.log(arr.slice(-2, -1)); // ["Adrew"]console.log(arr); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"] #### 3.7 indexOf **定义和用法** indexOf()方法可返回某个指定的值在数组中首次出现的位置。从左往右找，找不到返回-1。 **语法** > arrayObject.indexOf(searchValue, fromIndex) |参数|描述| |-------|----| |searchValue|必需。规定需检索的值。| |fromIndex|可选的整数参数，开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0| 1234567891011121314var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr.indexOf('Thomas')); // 2console.log(arr.indexOf('Thomas', 2)); // 2console.log(arr.indexOf('Thomas', 3)); // -1console.log(arr.indexOf('Thomas', -4)); // 2console.log(arr.indexOf('Thomas', -3)); // -1console.log(arr.indexOf('Peter')); // -1 #### 3.8 lastIndexOf **定义和用法** lastIndexOf()方法可返回某个指定的值在数组中首次出现的位置。从右往左找，找不到返回-1。 **语法** > arrayObject.indexOf(searchValue, fromIndex) |参数|描述| |-------|----| |searchValue|必需。规定需检索的值。| |fromIndex|可选的整数参数，从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找| 123456789101112131415var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr.lastIndexOf('Thomas')); // 2console.log(arr.lastIndexOf('Thomas', 2)); // 2console.log(arr.lastIndexOf('Thomas', 3)); // 2console.log(arr.lastIndexOf('Thomas', 1)); // -1console.log(arr.lastIndexOf('Thomas', -4)); // 2console.log(arr.lastIndexOf('Thomas', -3)); // 2console.log(arr.lastIndexOf('Peter')); // -1 #### 3.9 sort **定义和用法** sort()方法用于对数组的元素进行排序。 **语法** > arrayObject.sort(sortby) |参数|描述| |-------|----| |sortby|可选。规定排序顺序。必须是函数。| **返回值** 对数组的引用。请注意，数组在原数组上进行排序，不生成副本。 **说明** 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说的更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以方便比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b，其返回值如下： - 若a小于b，在排序后的数组中a应该出现在b之前，则返回一个小于0的值。 - 若a等于b，则返回0。 - 若a大于b，则返回一个大于0的值。 即顺序 return a - b; 倒序 return b - a; a在b前返回负数，a在b后返回正数 1234567891011var arr = new Array(6);arr[0] = "10";arr[1] = "5";arr[2] = "40";arr[3] = "25";arr[4] = "1000";arr[5] = "1";console.log(arr); // ["10", "5", "40", "25", "1000", "1"]console.log(arr.sort()); // ["1", "10", "1000", "25", "40", "5"]console.log(arr); // ["1", "10", "1000", "25", "40", "5"] 1234567891011121314151617181920var arr = new Array(6);arr[0] = "10";arr[1] = "5";arr[2] = "40";arr[3] = "25";arr[4] = "1000";arr[5] = "1";function orderNumber (a, b) &#123; return a - b;&#125;function descOrderNumber (a, b) &#123; return b - a;&#125;console.log(arr); // ["10", "5", "40", "25", "1000", "1"]console.log(arr.sort(orderNumber)); // ["1", "5", "10", "25", "40", "1000"]console.log(arr.sort(descOrderNumber)); // ["1000", "40", "25", "10", "5", "1"]console.log(arr); // ["1000", "40", "25", "10", "5", "1"] #### 3.10 splice **定义和用法** splice()方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。 **语法** > arrayObject.splice(index, howmany, item1, ......, itemX) |参数|描述| |-------|----| |index|必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。| |howmany|必需。要删除的项目数量。如果设置为0，则不会删除项目。| |item1,......,itemX|可选。向数组添加的新项目。| **返回值** |类型|描述| |-------|----| |Array|包含被删除项目的新数组，如果有的话。| **说明** splice()方法可删除从index处开始的0个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从arrayObject中删除了元素，则返回的是含有被删除的元素的数组。 12345678910111213var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"] console.log(arr.splice(1, 1, 'Peter', 'Sara')); // ["John"]console.log(arr); // ["Geroge", "Peter", "Sara", "Thomas", "James", "Adrew", "Martin"]console.log(arr.splice(1, 0, 'Ella')); // []console.log(arr); // ["Geroge", "Ella", "Peter", "Sara", "Thomas", "James", "Adrew", "Martin"] #### 3.11 toString **定义和用法** toString()方法可把数组转换为字符串，并返回结果。 **语法** > arrayObject.toString() **返回值** arrayObject的字符串表示。返回值与没有参数的join()方法返回的字符串相同。 **说明** 当数组用于字符串环境时，JavaScript会调用这一方法将数组自动转换成字符串。但是在某些情况下，需要显式地调用该方法。 1234567var arr = new Array(4);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr[3] = 20;console.log(arr.toString()); // "Geroge,John,Thomas,20" #### 3.12 toLocaleString **定义和用法** toLocaleString()方法可把数组转换为本地字符串，并返回结果。 **语法** > arrayObject.toLocaleString() **返回值** arrayObject的本地字符串表示。 **说明** 首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。 1234567var arr = new Array(4);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr[3] = 20;console.log(arr.toLocaleString()); // "Geroge,John,Thomas,20" #### 3.13 valueOf **定义和用法** valueOf()方法返回Array对象的原始值。该原始值由Array对象派生的所有对象继承。valueOf(）方法通常由JavaScript在后台自动调用，并不显式地出现在代码中。 **语法** > arrayObject.valueOf() 1234567var arr = new Array(4);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr[3] = 20;console.log(arr.valueOf()); // ["Geroge", "John", "Thomas", 20] #### 3.14 forEach **定义和用法** forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。forEach()对于空数组是不会执行回调函数的。 **语法** > arrayObject.forEach(function (value, index, arr) {}, thisValue) |参数|描述| |-------|----| |function(currentValue, index, arr)|必需。数组中每个元素需要调用的函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。| |thisValue|可选。传递给函数的值一般用'this'值。如果这个参数为空，严格模式下把'undefined'会传递给'this'值，普通模式下传入'window'。| 123456789101112131415161718var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr.forEach(function (value, index, arr) &#123; console.log(value); // "Geroge" "John" "Thomas" console.log(index); // 0 1 2 console.log(arr); // ["Geroge", "John", "Thomas"] console.log(this); // window&#125;);arr.forEach(function (value, index, arr) &#123; console.log(value); // "Geroge" "John" "Thomas" console.log(index); // 0 1 2 console.log(arr); // ["Geroge", "John", "Thomas"] console.log(this); // ["Geroge", "John", "Thomas"]&#125;, arr); #### 3.15 concat **定义和用法** concat()方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 **语法** > arrayObject.concat(arrayX,arrayX,......,arrayX) |参数|描述| |---|---| |arrayX|必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 **返回值** 返回一个新的数组。该数组是通过把所有arrayX参数添加到arrayObject中生成的。如果要进行concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。 123var a = [1, 2, 3];console.log(a.concat(4, 5, [6, 7], 8, 9)); // [1, 2, 3, 4, 5, 6, 7, 8, 9] #### 3.16 every **定义和用法** every()方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。 every()方法使用指定函数检测数组中的所有元素： - 如果数组中检测到有一个元素不满足，则整个表达式返回false，且剩余的元素不会再进行检测。 - 如果所有元素都满足条件，则返回true。 注意：every()不会对空数组进行检测。 注意：every()不会改变原始数组。 **语法** > arrayObject.every(function (currentValue, index, arr) {}, thisValue) |参数|描述| |---|---| |function (currentValue, index, arr)|必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。| |thisValue|可选。对象作为该执行回调时使用，传递给函数。 **说明** 有一个返回false，则整个every()返回值为false，并且不会执行后续其他项的回调函数。 空数组的every()直接返回true。 1234567891011121314var ages = [10, 20, 24, 32, 40];var result = ages.every(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // falseages = [];result = ages.every(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // true #### 3.17 some **定义和用法** some()方法用于检测数组所有元素是否满足指定条件（通过函数提供）。 every()方法会依次执行数组的每个元素： - 如果有一个元素满足条件，则表达式返回true，剩余的元素不会再执行检测。 - 如果没有满足条件的元素，则返回false。 注意：some()不会对空数组进行检测。 注意：some()不会改变原始数组。 **语法** > arrayObject.some(function (currentValue, index, arr) {}, thisValue) |参数|描述| |---|---| |function (currentValue, index, arr)|必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。| |thisValue|可选。对象作为该执行回调时使用，传递给函数。 **说明** 有一个返回true，则整个some()返回值为true，并且不会执行后续其他项的回调函数。 空数组的some()直接返回false。 1234567891011121314var ages = [10, 20, 24, 32, 40];var result = ages.some(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // trueages = [];result = ages.some(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // false #### 3.18 filter **定义和用法** filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测。 注意：filter()不会改变原始数组。 **语法** > arrayObject.filter(function (currentValue, index, arr) {}, thisValue) |参数|描述| |---|---| |function (currentValue, index, arr)|必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。| |thisValue|可选。对象作为该执行回调时使用，传递给函数。 **说明** 将所有返回true的数组项取出来组成一个新的数组。 123456789101112131415var ages = [10, 20, 24, 32, 40];var result = ages.filter(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // [32, 40]console.log(ages); // [10, 20, 24, 32, 40]ages = [];result = ages.filter(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // [] #### 3.19 reverse **定义和用法** reverse()方法用于颠倒数组中元素的顺序。会改变原数组。 **语法** > arrayObject.reverse() 12345678var arr = new Array(3);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.reverse()); // ["Thomas", "John", "Geroge"]console.log(arr); // ["Thomas", "John", "Geroge"] #### 3.20 map **定义和用法** map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map()方法按照原始数组元素顺序依次处理元素。 注意：map()不会对空数组进行检测。 注意：map()不会改变原始数组。 **语法** > arrayObject.map(function (currentValue, index, arr) {}, thisValue) |参数|描述| |---|---| |function (currentValue, index, arr)|必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。| |thisValue|可选。对象作为该执行回调时使用，传递给函数。 12345678var numbers = [65, 20, 11, 5];var arr = numbers.map(function (value, index, arr) &#123; return value * 2;&#125;)console.log(numbers); // [65, 20, 11, 5]console.log(arr); // [130, 40, 22, 10] #### 3.21 reduce **定义和用法** reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 注意：reduce()对于空数组是不会执行回调函数的。 **语法** > arrayObject.reduce(function (total, currentValue, currentIndex, arr) {}, initialValue) |参数|描述| |---|---| |function (total, currentValue, currentIndex, arr)|必需。函数，数组中的每个元素都会执行这个函数。total: 必需。初始值，或者计算结束后的返回值。currentValue: 必需。当前元素。currentIndex: 可选。当前元素的索引。arr: 可选。当前元素所属的数组对象。| |initialValue|可选。传递给函数的初始值。| 12345678910111213141516171819var numbers = [15, 2, 1, 7];var total = numbers.reduce(function (total, currentValue) &#123; console.log(total); // 15 17 18 25 console.log(currentValue); // 2 1 7 return total + currentValue;&#125;);console.log(total); // 25console.log(numbers); // [15, 2, 1, 7]total = numbers.reduce(function (total, currentValue) &#123; console.log(total); // 20 35 37 38 45 console.log(currentValue); // 15 2 1 7 return total + currentValue;&#125;, 20);console.log(total); // 45console.log(numbers); // [15, 2, 1, 7] #### 3.22 reduceRight **定义和用法** reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。 注意：reduceRight()对于空数组是不会执行回调函数的。 **语法** > arrayObject.reduceRight(function (total, currentValue, currentIndex, arr) {}, initialValue) |参数|描述| |---|---| |function (total, currentValue, currentIndex, arr)|必需。函数，数组中的每个元素都会执行这个函数。total: 必需。初始值，或者计算结束后的返回值。currentValue: 必需。当前元素。currentIndex: 可选。当前元素的索引。arr: 可选。当前元素所属的数组对象。| |initialValue|可选。传递给函数的初始值。| 12345678910111213141516171819var numbers = [15, 2, 1, 7];var total = numbers.reduceRight(function (total, currentValue) &#123; console.log(total); // 7 8 10 25 console.log(currentValue); // 1 2 15 return total + currentValue;&#125;);console.log(total); // 25console.log(numbers); // [15, 2, 1, 7]total = numbers.reduceRight(function (total, currentValue) &#123; console.log(total); // 20 27 28 30 45 console.log(currentValue); // 7 1 2 15 return total + currentValue;&#125;, 20);console.log(total); // 45console.log(numbers); // [15, 2, 1, 7] ## 三、结束 本文会同步到我的[个人博客](https://blog.liuxuan.site)，完整代码可以到我的[github仓库查看](https://github.com/leocoder351/data-structure)，如果对你有帮助的话欢迎点一个Star~~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript异步编程]]></title>
    <url>%2F2018%2F07%2F20%2Fjavascript_asynchronous_programming%2F</url>
    <content type="text"><![CDATA[前言从我们一开始学习JavaScript的时候就听到过一段话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。 但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。 本文也会同步到我的个人网站。 正文Step1 - 回调函数回调函数大家肯定都不陌生，从我们写一段最简单的定时器开始：123setTimeout(function () &#123; console.log('Time out');&#125;, 1000); 定时器里面的匿名函数就是一个回调函数，因为在JS中函数是一等公民，所以它可以像其他变量一样作为参数进行传递。这样看来，通过回调函数来处理异步挺好的，写着也顺手，为什么要用别的方法呢？ 我们来看这样一个需求： 上面是微信小程序的登录时序图，我们的需求和它类似但又有些差别，想要获取一段业务数据，整个过程分为3步： 调用秘钥接口，获取key 携带key调用登录接口，获取token和userId 携带token和userId调用业务接口，获取数据 可能上述步骤和实际业务中的有些出入，但是却可以用来说明问题，请大家谅解。 我们写一段代码来实现上述需求： 123456789101112131415161718192021222324252627282930313233343536373839404142let key, token, userId;$.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; key = data; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; token = data.token; userId = data.userId; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: token, userId: userId &#125;, success: function (data) &#123; console.log('业务数据：', data); &#125;, error: function (err) &#123; console.log(err); &#125; &#125;); &#125;, error: function (err) &#123; console.log(err); &#125; &#125;); &#125;, error: function (err) &#123; console.log(err); &#125;&#125;); 可以看到，整段代码充满了回调嵌套，代码不仅在纵向扩展，横向也在扩展。我相信，对于任何人来说，调试起来都会很困难，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以查看流程，而最终的结果藏在整段代码的中间位置。真实的JavaScript程序代码可能要混乱的多，使得这种追踪难度会成倍增加。这就是我们常说的回调地狱（Callback Hell）。 为什么会出现这种现象？ 如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，我们还采用回调的方式来处理异步的话，就会出现回调地狱。 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码的难度很大，很容易产生Bug。 这里我们引出了回调函数解决异步的第1个问题：回调地狱。 回调函数还会存在别的问题吗？让我们再深入思考一下回调的概念：12345678// A$.ajax(&#123; ... success: function (...) &#123; // C &#125;&#125;);// B A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。 但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。 这种情况称为控制反转，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。 既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的： 调用回调过早 调用回调过晚 调用回调次数太多或者太少 未能把所需的参数成功传给你的回调函数 吞掉可能出现的错误或异常 …… 这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。 这里，我们引出了回调函数处理异步的第二个问题：控制反转。 综上，回调函数处理异步流程存在2个问题： 1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符2. 缺乏可信任性： 控制反转导致的一系列信任问题 那么如何来解决这两个问题，先驱者们开始了探索之路…… Step2 - Promise开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转。 至于Promise是什么，大家肯定都有所了解，这里是PromiseA+规范，ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，它是一种规范，是一套处理JavaScript异步的机制。 我们把上面那个多层回调嵌套的例子用Promise的方式重构：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970let getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; let key = data; resolve(key); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getDataPromise = function (data) &#123; let token = data.token; let userId = data.userId; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: token, userId: userId &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;getKeyPromise() .then(function (key) &#123; return getTokenPromise(key); &#125;) .then(function (data) &#123; return getDataPromise(data); &#125;) .then(function (data) &#123; console.log('业务数据：', data); &#125;) .catch(function (err) &#123; console.log(err); &#125;); 可以看到，Promise在一定程度上其实改善了回调函数的书写方式，最明显的一点就是去除了横向扩展，无论有再多的业务依赖，通过多个then(…)来获取数据，让代码只在纵向进行扩展；另外一点就是逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。 所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。 这里我想主要讨论的是，Promise是如何解决控制反转带来的信任缺失问题。 首先明确一点，Promise可以保证以下情况，引用自JavaScript | MDN： 在JavaScript事件队列的当前运行完成之前，回调函数永远不会被调用 通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用 通过多次调用 .then，可以添加多个回调函数，它们会按照插入顺序并且独立运行 下面我们针对前面提过的回调函数处理异步导致的一系列信任问题来讨论，如果是用Promise来处理，是否还会存在这些问题，当然前提是实现的Promise完全遵循PromiseA+规范。 调用过早当使用回调函数的时候，我们无法保证或者不知道第三方对于回调函数的调用是何种形式的，如果它在某种情况下是立即完成以同步的方式来调用，那可能就会导致我们代码中的逻辑错误。 但是，根据PromiseA+规范，Promise就不必担心这种问题，因为即使是立即完成的Promise（类似于new Promise(function (resolve, reject) {resolve(2);})），也无法被同步观察到。 也就是说，对一个Promise调用then(…)的时候，即使这个Promise已经决议，提供给then(…)的回调也总会在JavaScript事件队列的当前运行完成后，再被调用，即异步调用。 调用过晚当Promise创建对象调用resolve(…)或reject(…)时，这个Promise通过then(…)注册的回调函数就会在下一个异步时间点上被触发。 并且，这个Promise上的多个通过then(…)注册的回调都会在下一个异步时间点上被依次调用，这些回调中的任意一个都无法影响或延误对其他回调的调用。 举例如下：1234567891011p.then(function () &#123; p.then(function () &#123; console.log('C'); &#125;); console.log('A');&#125;).then(funtion () &#123; console.log('B');&#125;);// 打印 A B C 通过这个例子可以看到，C无法打断或抢占B，所以Promise没有调用过晚的现象，只要你注册了then(…)，就肯定会按顺序依次调用，因为这就是Promise的运作方式。 回调未调用没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议（如果它决议了的话）。如果你对一个Promise注册了一个成功回调和拒绝回调，那么Promise在决议的时候总会调用其中一个。 当然，如果你的回调函数本身包含JavaScript错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。 123456p.then(function (data) &#123; console.log(data); foo.bar(); // 这里没有定义foo，所以这里会报Type Error, foo is not defined&#125;, function (err) &#123;&#125;); 调用次数太多或者太少根据PromiseA+规范，回调被调用的正确次数应该是1次。“太少”就是不调用，前面已经解释过了。 “太多”的情况很容易解释，Promise的定义方式使得它只能被决议一次。如果处于多种原因，Promise创建代码试图调用多次resolve(…)或reject(…)，或者试图两者都调用，那么这个Promise将只会接受第一次决议，并默默忽略任何后续调用。 由于Promise只能被决议一次，所以任何通过then(…)注册的回调就只会被调用一次。 未能传递参数值如果你没有把任何值传递给resolve(…)或reject(…)，那么这个值就是undefined。但不管这个值是什么，它都会被传给所有注册在then(…)中的回调函数。 如果使用多个参数调用resolve(…)或reject(…)，那么第一个参数之后的所有参数都会被忽略。如果要传递多个值，你就必须把它们封装在单个值中进行传递，比如一个数组或对象。 吞掉可能出现的错误或异常如果在Promise的创建过程中或在查看其决议结果的过程中的任何时间点上，出现了一个JavaScript异常错误，比如一个TypeError或ReferenceError，这个异常都会被捕捉，并且会使这个Promise被拒绝。 举例如下：12345678910var p = new Promise(function (resolve, reject) &#123; foo.bar(); // foo未定义 resolve(2);&#125;);p.then(function (data) &#123; console.log(data); // 永远也不会到达这里&#125;, function (err) &#123; console.log(err); // err将会是一个TypeError异常对象来自foo.bar()这一行&#125;); foo.bar()中发生的JavaScript异常导致了Promise的拒绝，你可以捕捉并对其作出响应。 不是所有的thenable都可以信任到目前为止，我们讨论了使用Promise可以避免上述多种由控制反转导致的信任问题。但是，你肯定也注意到了，Promise并没有完全摆脱回调，它只是改变了传递回调的位置。我们并不是把回调传递给foo(…)让第三方去执行，而是从foo(…)得到某个东西（Promise对象），然后把回调传递给这个东西。 但是，为什么这就比单纯使用回调更值得信任呢？如何能够确定返回的这个东西实际上就是一个可信任的Promise呢？ Promise对于这个问题已经有了解决方案，ES6实现的Promise的解决方案就是Promise.resolve(…)。 如果向Promise.resolve(…)传递一个非Promise，非thenable得立即值，就会得到一个用这个值填充的Promise。 举例如下：1234567var p1 = new Promise(function (resolve, reject) &#123; resolve(2);&#125;);var p2 = Promise.resolve(2);// 这里p1和p2的效果是一样的 而如果向Promise.resolve(…)传递一个真正的Promise，就只会返回同一个Promise。 1234var p1 = Promise.resolve(2);var p2 = Promise.resolve(p1);p1 === p2; // true 更重要的是，如果向Promise.resolve(…)传递了一个非Promise的thenable值，前者就会试图展开这个值，而且展开过程中会持续到提取出一个具体的非类Promise的最终值。 举例如下：12345678910111213var p = &#123; then: function (cb, errCb) &#123; cb(2); errCb('haha'); &#125;&#125;;// 这可以工作，因为函数是一等公民，可以当做参数进行传递p.then(function (data) &#123; console.log(data); // 2&#125;, function (err) &#123; console.log(err); // haha&#125;); 这个p是一个thenable，但不是一个真正的Promise，其行为和Promise并不完全一致，它同时触发了成功回调和拒绝回调，它是不可信任的。 尽管如此，我们还是都可以把这样的p传给Promise.resolve(…)，然后就会得到期望中的规范化后的安全结果：123456Promise.resolve(p) .then(function (data) &#123; console.log(data); // 2 &#125;, function (err) &#123; console.log(err); // 永远不会到达这里 &#125;); 因为前面讨论过，一个Promise只接受一次决议，如果多次调用resolve(…)或reject(…)，后面的会被自动忽略。 Promise.resolve(…)可以接受任何thenable，将其解封为它的非thenable值。从Promise.resolve(…)得到的是一个真正的Promise，是一个可以信任的值。如果你传入的已经是真正的Promise，那么你得到的就是它本身，所以通过Promise.resolve(…)过滤来获得可信任性完全没有坏处。 综上，我们明确了，使用Promise处理异步可以解决回调函数控制反转带来的一系列信任问题。很好，我们又向前迈了一步。 Step3 - 生成器Gererator在Step1中，我们确定了用回调表达异步流程的两个关键问题： 基于回调的异步不符合大脑对任务步骤的规范方式 由于控制反转，回调并不是可信任的 在Step2中，我们详细介绍了Promise是如何把回调的控制反转又反转过来，恢复了可信任性。 现在，我们把注意力转移到一种顺序、看似同步的异步流程控制表达风格，这就是ES6中的生成器（Gererator）。 可迭代协议和迭代器协议了解Generator之前，必须先了解ES6新增的两个协议：可迭代协议和迭代器协议。 可迭代协议可迭代协议运行JavaScript对象去定义或定制它们的迭代行为，例如（定义）在一个for…of结构中什么值可以被循环（得到）。以下内置类型都是内置的可迭代对象并且有默认的迭代行为： Array Map Set String TypedArray 函数的Arguments对象 NodeList对象 注意，Object不符合可迭代协议。 为了变成可迭代对象，一个对象必须实现@@iterator方法，意思是这个对象（或者它原型链prototype chain上的某个对象）必须有一个名字是Symbol.iterator的属性： 属性 值 [Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议 当一个对象需要被迭代的时候（比如开始用于一个for…of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。 迭代器协议迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值。当一个对象被认为是一个迭代器时，它实现了一个next()的方法并且拥有以下含义：| 属性 | 值 ||——|—|| next | 返回一个对象的无参函数，被返回对象拥有两个属性： 1. done（boolean） - 如果迭代器已经经过了被迭代序列时为true。这时value可能描述了该迭代器的返回值 - 如果迭代器可以产生序列中的下一个值，则为false。这等效于连同done属性也不指定。 2. value - 迭代器返回的任何JavaScript值。done为true时可以忽略。 | 使用可迭代协议和迭代器协议的例子：123456789101112131415161718var str = 'hello';// 可迭代协议使用for...of访问typeof str[Symbol.iterator]; // 'function'for (var s of str) &#123; console.log(s); // 分别打印 'h'、'e'、'l'、'l'、'o'&#125;// 迭代器协议next方法var iterator = str[Symbol.iterator]();iterator.next(); // &#123;value: "h", done: false&#125;iterator.next(); // &#123;value: "e", done: false&#125;iterator.next(); // &#123;value: "l", done: false&#125;iterator.next(); // &#123;value: "l", done: false&#125;iterator.next(); // &#123;value: "o", done: false&#125;iterator.next(); // &#123;value: undefined, done: true&#125; 我们自己实现一个对象，让其符合可迭代协议和迭代器协议：1234567891011121314151617181920212223242526var something = (function () &#123; var nextVal; return &#123; // 可迭代协议，供for...of消费 [Symbol.iterator]: function () &#123; return this; &#125;, // 迭代器协议，实现next()方法 next: function () &#123; if (nextVal === undefined) &#123; nextVal = 1; &#125; else &#123; nextVal = (3 * nextVal) + 6; &#125; return &#123;value: nextVal, done: false&#125;; &#125; &#125;;&#125;)();something.next().value; // 1something.next().value; // 9something.next().value; // 33something.next().value; // 105 用Generator实现异步如果我们用Generator改写上面回调嵌套的例子会是什么样的呢？见代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function getKey () &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; key = data; it.next(key); &#125; error: function (err) &#123; console.log(err); &#125; &#125;);&#125;function getToken (key) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; loginData = data; it.next(loginData); &#125; error: function (err) &#123; console.log(err); &#125; &#125;);&#125;function getData (loginData) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: loginData.token, userId: loginData.userId &#125;, success: function (busiData) &#123; it.next(busiData); &#125; error: function (err) &#123; console.log(err); &#125; &#125;);&#125;function *main () &#123; let key = yield getKey(); let LoginData = yield getToken(key); let busiData = yield getData(loginData); console.log('业务数据：', busiData);&#125;// 生成迭代器实例var it = main();// 运行第一步it.next();console.log('不影响主线程执行'); 我们注意*main()生成器内部的代码，不看yield关键字的话，是完全符合大脑思维习惯的同步书写形式，把异步的流程封装到外面，在成功的回调函数里面调用it.next()，将传回的数据放到任务队列里进行排队，当JavaScript主线程空闲的时候会从任务队列里依次取出回调任务执行。 如果我们一直占用JavaScript主线程的话，是没有时间去执行任务队列中的任务：12345// 运行第一步it.next();// 持续占用JavaScript主线程while(1) &#123;&#125;; // 这里是拿不到异步数据的，因为没有机会去任务队列里取任务执行 综上，生成器Generator解决了回调函数处理异步流程的第一个问题：不符合大脑顺序、线性的思维方式。。 Step4 - Async/Await上面我们介绍了Promise和Generator，把这两者结合起来，就是Async/Await。 Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。 我们把最开始的例子用Async/Await的方式改写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; let key = data; resolve(key); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getDataPromise = function (data) &#123; let token = data.token; let userId = data.userId; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: token, userId: userId &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;async function main () &#123; let key = await getKeyPromise(); let loginData = await getTokenPromise(key); let busiData = await getDataPromise(loginData); console.log('业务数据：', busiData);&#125;main();console.log('不影响主线程执行'); 可以看到，使用Async/Await，完全就是同步的书写方式，逻辑和数据依赖都非常清楚，只需要把异步的东西用Promise封装出去，然后使用await调用就可以了，也不需要像Generator一样需要手动控制next()执行。 Async/Await是Generator和Promise的组合，完全解决了基于回调的异步流程存在的两个问题，可能是现在最好的JavaScript处理异步的方式了。 总结本文通过四个阶段来讲述JavaScript异步编程的发展历程： 第一个阶段 - 回调函数，但会导致两个问题: 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 缺乏可信任性： 控制反转导致的一系列信任问题 第二个阶段 - Promise，Promise是基于PromiseA+规范的实现，它很好的解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来。 第三个阶段 - 生成器函数Generator，使用Generator，可以让我们用同步的方式来书写代码，解决了顺序性的问题，但是需要手动去控制next(…)，将回调成功返回的数据送回JavaScript主流程中。 第四个阶段 - Async/Await，Async/Await结合了Promise和Generator，在await后面跟一个Promise，它会自动等待Promise的决议值，解决了Generator需要手动控制next(…)执行的问题，真正实现了用同步的方式书写异步代码。 我们可以看到，每项技术的突破都是为了解决现有技术存在的一些问题，它是循序渐进的，我们在学习的过程中，要真正去理解这项技术解决了哪些痛点，它为什么会存在，这样会有益于我们构建体系化的知识，同时也会更好的去理解这门技术。 最后，希望大家可以通过这篇文章对JavaScript异步编程有一个更宏观的体系化的了解，我们一起进步。 参考： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>异步编程</tag>
        <tag>Promise</tag>
        <tag>Generator</tag>
        <tag>Async/Await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看图学HTTPS]]></title>
    <url>%2F2018%2F05%2F21%2Flearn_https_through_photos%2F</url>
    <content type="text"><![CDATA[前言之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。 我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。 本文也会同步到我的个人网站。 正文HTTP是什么样的？HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述： 客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。 加个密呢？因为上图中数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密，如下图： 这种加密方式叫做：对称加密。加密和解密用同一个秘钥的加密方式叫做对称加密。 好了，我们对数据进行加密了，问题解决了吗？ 多个客户端怎么办？这是一个客户端，但是在WWW上，是成千上万的客户端，情况会怎样呢？ 为所有的客户端都应用同一个秘钥A，这种方式很显然是不合理的，破解了一个用户，所有的用户信息都会被盗取。 想一想，是不是还有别的办法呢？ 相信大家都可以想到，如果对每一个客户端都用不同的秘钥进行传输是不是就解决这个问题了： 对称加密秘钥如何传输？我们对每个客户端应用不同的对称加密秘钥，那么这个秘钥客户端或者服务端是如何知道的呢，只能是在一端生成一个秘钥，然后通过HTTP传输给另一端： 那么这个传输秘钥的过程，又如何保证加密？如果被中间人拦截，秘钥也会被获取。也许你会说，对秘钥再进行加密，那又如何保证对秘钥加密的过程，是加密的呢？ 好像我们走入了 while(1)，出不来了。 非对称加密在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫非对称加密，比如RSA。非对称加密会有一对秘钥：公钥和私钥。公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。 私钥只保存在服务器端，公钥可以发送给所有的客户端。 在传输公钥的过程中，肯定也会有被中间人获取的风险，但在目前的情况下，至少可以保证客户端通过公钥加密的内容，中间人是无法破解的，因为私钥只保存在服务器端，只有私钥可以破解公钥加密的内容。 现在我们还存在一个问题，如果公钥被中间人拿到篡改呢： MITM：Man-in-the-MiddleAttack 客户端拿到的公钥是假的，如何解决这个问题？ 第三方认证公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。 在HTTPS中，使用 证书 + 数字签名 来解决这个问题。 这里假设加密方式是MD5，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名。 数字证书 = 网站信息 + 数字签名 假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。 浏览器安装后会内置一些权威第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等，验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。 为什么要有签名？大家可以想一下，为什么要有数字签名这个东西呢？ 第三方认证机构是一个开放的平台，我们可以去申请，中间人也可以去申请呀： 如果没有签名，只对网站信息进行第三方机构私钥加密的话，会存在下面的问题： 因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。 对称加密在安全的拿到服务器的公钥之后，客户端会随机生成一个对称秘钥，使用服务器公钥加密，传输给服务端，此后，相关的 Application Data 就通过这个随机生成的对称秘钥进行加密/解密，服务器也通过该对称秘钥进行解密/加密： 整体流程图HTTPS = HTTP + TLS/SSL HTTPS中具体的内容还有很多，可以通过下图做一个参考： 总结HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。 参考文章https://en.wikipedia.org/wiki/HTTPShttps://www.instantssl.com/https-tutorials/what-is-https.htmlhttps://tasaid.com/blog/20161003001126.htmlhttps://www.west.cn/faq/list.asp?unid=1346https://www.cnblogs.com/zhangshitong/p/6478721.htmlhttps://www.wired.com/2016/04/hacker-lexicon-what-is-https-encryption/]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>HTTPS</tag>
        <tag>SSL/TLS</tag>
        <tag>非对称加密</tag>
        <tag>对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊V8引擎的垃圾回收]]></title>
    <url>%2F2018%2F04%2F14%2Fv8_garbage_collection%2F</url>
    <content type="text"><![CDATA[前言我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~ 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 为什么要有垃圾回收在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。 不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。 内存结构分配由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在64位系统下大约为1.4GB，在32位系统下大约为700MB。 在NodeJS环境中，我们可以通过process.memoryUsage()来查看内存分配。 process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，含义如下： 1234567rss（resident set size）：所有内存占用，包括指令区和堆栈heapTotal：V8引擎可以分配的最大堆内存，包含下面的 heapUsedheapUsed：V8引擎已经分配使用的堆内存external： V8管理C++对象绑定到JavaScript对象上的内存 以上所有内存单位均为字节（Byte）。 如果说想要扩大Node可用的内存空间，可以使用Buffer等堆外内存内存，这里不详细说明了，大家有兴趣可以去看一些资料。 下面是Node的整体架构图，有助于大家理解上面的内容： 123456789Node Standard Library: 是我们每天都在用的标准库，如Http, Buffer 模块Node Bindings: 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务第三层是支撑 Node.js 运行的关键，由 C/C++ 实现：1. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机2. Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力3. C-ares：提供了异步处理 DNS 相关的能力4. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力 垃圾回收机制1. 如何判断是否可以回收1.1 标记清除当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。 （1）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。 （2）然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记 （3）此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。 （4）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 活动对象就是上面的root，如果不清楚活动对象的可以先查一下资料，当一个对象和其关联对象不再通过引用关系被当前root引用了，这个对象就会被垃圾回收。 1.2 引用计数引用计数的垃圾收集策略不太常见。含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。 如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。 当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。 循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用，看个例子：1234567function foo () &#123; var objA = new Object(); var objB = new Object(); objA.otherObj = objB; objB.anotherObj = objA;&#125; 这个例子中，objA和objB通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2。 在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是问题。 但在采用引用次数策略的实现中，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0。 加入这个函数被重复多次调用，就会导致大量内存无法回收。为此，Netscape在Navigator 4.0中也放弃了引用计数方式，转而采用标记清除来实现其垃圾回收机制。 还要注意的是，我们大部分人时刻都在写着循环引用的代码，看下面这个例子，相信大家都这样写过：1234var el = document.getElementById('#el');el.onclick = function (event) &#123; console.log('element was clicked');&#125; 我们为一个元素的点击事件绑定了一个匿名函数，我们通过event参数是可以拿到相应元素el的信息的。 大家想想，这是不是就是一个循环引用呢？el有一个属性onclick引用了一个函数（其实也是个对象），函数里面的参数又引用了el，这样el的引用次数一直是2，即使当前这个页面关闭了，也无法进行垃圾回收。 如果这样的写法很多很多，就会造成内存泄露。我们可以通过在页面卸载时清除事件引用，这样就可以被回收了：123456789101112var el = document.getElementById('#el');el.onclick = function (event) &#123; console.log('element was clicked');&#125;// ...// ...// 页面卸载时将绑定的事件清空window.onbeforeunload = function()&#123; el.onclick = null;&#125; V8垃圾回收策略自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。 所以，V8采用了一种代回收的策略，将内存分为两个生代：新生代（new generation）和老生代（old generation）。 新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升，后面我会详细说明。 分代内存默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。 新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。 新生代1. 分配方式新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。 2. 算法新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。 Cheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。 处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。 我画了一套详细的流程图，接下来我会结合流程图来详细说明Cheney算法是怎么工作的。垃圾回收在下面我统称为 GC（Garbage Collection）。 step1. 在From空间中分配了3个对象A、B、C step2. GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象 step3. 将活跃对象A、C从From空间复制到To空间 step4. 清空From空间的全部内存 step5. 交换From空间和To空间 step6. 在From空间中又新增了2个对象D、E step7. 下一轮GC进来发现对象D没有引用了，做标记 step8. 将活跃对象A、C、E从From空间复制到To空间 step9. 清空From空间全部内存 step10. 继续交换From空间和To空间，开始下一轮 通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。 由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。 3. 晋升当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。 对象从新生代移动到老生代的过程叫作晋升。 对象晋升的条件主要有两个： 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。 老生代1. 介绍在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题： 由于存活对象较多，复制存活对象的效率会很低。 采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。 所以，V8在老生代中主要采用了Mark-Sweep和Mark-Sweep相结合的方式进行垃圾回收。 2. Mark-SweepMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。 与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。 也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。 我们还是通过流程图来看一下： step1. 老生代中有对象A、B、C、D、E、F step2. GC进入标记阶段，将A、C、E标记为存活对象 step3. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间 可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。 如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 2. Mark-Compact为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。 Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示： step1. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样） step2. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样） step3. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间 step4. GC进入清除阶段，将边界另一侧的内存一次性全部回收 3. 两者结合在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。 由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。 总结V8的垃圾回收机制分为新生代和老生代。 新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。 老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。 以上就是本文的全部内容，书写过程中参考了很多中外文章，参考书籍包括朴大大的《深入浅出NodeJS》以及《JavaScript高级程序设计》等。我们这里并没有对具体的算法实现进行探讨，感兴趣的朋友可以继续深入研究一下。 最后，谢谢大家能够读到这里，如果文中有任何不明确或错误的地方，欢迎给我留言~~ 参考链接https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8http://alinode.aliyun.com/blog/14http://www.ruanyifeng.com/blog/2017/04/memory-leak.htmlhttps://segmentfault.com/a/1190000000440270]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>V8</tag>
        <tag>垃圾回收</tag>
        <tag>Scavenge</tag>
        <tag>Mark-Sweep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾调用和尾递归]]></title>
    <url>%2F2018%2F04%2F10%2Ftail_call%2F</url>
    <content type="text"><![CDATA[尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: , 依次举例：123const a = x =&gt; x ? f() : g();// f() 和 g() 都在尾部。 12345678910111213141516const a = () =&gt; f() || g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return fResult; &#125; else &#123; return g(); // tail call &#125;&#125;// 只有当f()的结果为falsey的时候，g()才是尾调用 12345678910111213141516const a = () =&gt; f() &amp;&amp; g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return g(); // tail call &#125; else &#123; return fResult; &#125;&#125;// 只有当f()的结果为truthy的时候，g()才是尾调用 12345678910const a = () =&gt; (f() , g());// g()是尾调用// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; f(); return g();&#125; 2. 尾调用优化函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：12345function foo () &#123; console.log(111); &#125;function bar () &#123; foo(); &#125;function baz () &#123; bar(); &#125;baz(); 造成这种结果是因为每个函数在调用另一个函数的时候，并没有 return 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。 baz() 里面调用了 bar() 函数，并没有 return 该调用，所以在调用栈中保持自己的调用帧，同时 bar() 函数的调用帧在调用栈中生成，同理，bar() 函数又调用了 foo() 函数，最后执行到 foo() 函数的时候，没有再调用其他函数，这里没有显示声明 return，所以这里默认 return undefined。 foo() 执行完了，销毁调用栈中自己的记录，依次销毁 bar() 和 baz() 的调用帧，最后完成整个流程。 如果对上面的例子做如下修改：12345function foo () &#123; console.log(111); &#125;function bar () &#123; return foo(); &#125;function baz () &#123; return bar(); &#125;baz(); 这里要注意：尾调用优化只在严格模式下有效。 在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈： func.arguments: 表示对 func最近一次调用所包含的参数 func.caller: 引用对 func最近一次调用的那个函数 在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。 如果尾调用优化生效，流程图就会变成这样： 我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。 这就叫做尾调用优化，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。 尾递归1. 定义先来看一下递归，当一个函数调用自身，就叫做递归。123function foo () &#123; foo();&#125; 上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。 那么什么是尾递归？前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做尾递归。123function foo () &#123; return foo();&#125; 2. 作用那么尾递归相比递归而言，有哪些不同呢？我们通过下面这个求阶乘的例子来看一下：12345678function factorial (num) &#123; if (num === 1) return 1; return num * factorial(num - 1);&#125;factorial(5); // 120factorial(10); // 3628800factorial(500000); // Uncaught RangeError: Maximum call stack size exceeded 上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。 这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。 如果用尾递归来计算阶乘呢？123456789101112131415'use strict';function factorial (num, total) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5, 1); // 120factorial(10, 1); // 3628800factorial(500000, 1); // 分情况// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js// node最新版本已经移除了--harmony_tailcalls功能 通过尾递归，我们把复杂度从O(n)降低到了O(1)，如果数据足够大的话，会节省很多的计算时间。由此可见，尾调用优化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。 避免改写递归函数尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的factorial()函数改写一样。 这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？解决这个问题的办法有两个： 1. ES6参数默认值123456789'use strict';function factorial (num, total = 1) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 2. 用一个符合语义的函数去调用改写后的尾递归函数1234567891011function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;function factorial (num) &#123; return tailFactorial(num, 1);&#125;factorial(5); // 120factorial(10); // 3628800 上面这种写法其实有点类似于做了一个函数柯里化，但不完全符合柯里化的概念。函数柯里化是指把接受多个参数的函数转换为接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数。 概念看着很绕口，我们来个例子感受一下：1234567891011121314151617// 普通加法函数function add (x, y, z) &#123; return x + y + z;&#125;add(1, 2, 3); // 6// 改写为柯里化加法函数function add (x) &#123; return function (y) &#123; return function (z) &#123; return x + y + z; &#125; &#125;&#125;add(1)(2)(3); // 6 可以看到，柯里化函数通过闭包找到父作用域里的变量，最后依次相加输出结果。通过这个例子，可能看不出为什么要用柯里化，有什么好处，这个我们以后再谈，这里先引出一个概念。 是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 如果用柯里化改写求阶乘的例子：12345678910111213141516171819202122232425262728293031323334353637383940// 柯里化函数function curry (fn) &#123; var _fnArgLength = fn.length; function wrap (...args) &#123; var _args = args; var _argLength = _args.length; // 如果传的是所有参数，直接返回fn调用 if (_fnArgLength === _argLength) &#123; return fn.apply(null, args); &#125; function act (...args) &#123; _args = _args.concat(args); if (_args.length === _fnArgLength) &#123; return fn.apply(null, _args); &#125; return act; &#125; return act; &#125; return wrap;&#125;// 尾递归函数function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;// 改写var factorial = curry(tailFactorial);factorial(5)(1); // 120factorial(10)(1); // 3628800 这是符合柯里化概念的写法，在阮一峰老师的文章中是这样写的：1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 我个人认为，这种写法其实不是柯里化，因为并没有将多参数的tailFacrotial改写为接受单参数的形式，只是换了一种写法，和下面这样写意义是一样的：1234567891011function factorial (num) &#123; return tailFactorial(num, 1);&#125;function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 结束这篇文章我们主要讨论了尾调用优化和柯里化。要注意的是，经过测试，Chrome和Firefox并没有对尾调用进行优化，Safari对尾调用进行了优化。Node高版本也已经去除了通过–harmony_tailcalls参数启用尾调用优化。 有任何问题，欢迎大家留言讨论~~ 参考链接http://www.ruanyifeng.com/blog/2015/04/tail-call.htmlhttps://juejin.im/post/5a4d898a518825698e7277d1https://github.com/lamdu/lamdu/issues/90]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>尾调用</tag>
        <tag>尾递归</tag>
        <tag>函数式</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 karma + jasmine 测试环境]]></title>
    <url>%2F2018%2F04%2F03%2Ffront_end_test_karma_jasmine%2F</url>
    <content type="text"><![CDATA[在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。 在 init 时会让你选择一些配置项： test framework我这里选择的是jasmine，它是一款JavaScript断言测试库use Require.js根据个人情况，我选择的是nocapture any browsers automatically选择浏览器，我选择的是无头浏览器PhantomJSlocation of your source files为空any of files included by the previous patterns be excluted为空karma to watch all files and run the tests on change是否监测，我选择的是no 在选择完所有配置项后，会自动生成karma.conf.js配置文件。 根据配置项的选择安装插件（1） 测试框架选择的是jasmine，安装步骤如下：1$ npm install jasmine-core karma-jasmine -D 这里要装两个，一个是jasmine的核心，另一个是karma对jasmine的封装。 （2） 浏览器选择的是PhantomJS，安装步骤如下：1$ npm install karma-phantomjs-launcher -D （3） 如果涉及到对以ES6编写的代码进行测试，就要安装Babel及其相关插件：12$ npm install babel-cli babel-preset-env babel-plugin-transform-es2015-modules-umd -D$ npm install karma-babel-preprocessor -D （4） 安装生成代码覆盖率报告的插件：1$ npm install karma-coverage -D 修改karma配置文件123456789101112131415161718192021222324252627282930// karma.conf.jsmodule.exports = function(config) &#123; config.set(&#123; basePath: '', frameworks: ['jasmine'], files: [ './src/**/*.js', './test/**/*.spec.js' ], exclude: [ ], preprocessors: &#123; './src/**/*.js': ['babel'], './test/**/*.spec.js': ['babel', 'coverage'] &#125;, reporters: ['progress', 'coverage'], coverageReporter: &#123; type: 'html', dir: 'coverage/' &#125;, port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: ['PhantomJS'], singleRun: true, concurrency: Infinity &#125;)&#125; 修改Babel配置文件：123456// .babelrc&#123; "presets": ["env"], "plugins": ["transform-es2015-modules-umd"], "auxiliaryCommentBefore": "istanbul ignore next"&#125; 写测试文件1234567891011// PraiseButton.spec.jsimport PraiseButton from '../src/PraiseButton.js';describe('测试点赞组件', function () &#123; it('addOne() 函数', function () &#123; var testPraiseButton = new PraiseButton(); testPraiseButton.addOne(); expect(testPraiseButton.countNum).toBe(1); &#125;);&#125;); 运行测试1$ karma start 结束按照上述步骤，大家应该可以配置好自己的 karma + jasmine 测试环境，如果遇到问题或者文中有写错的地方，欢迎大家来讨论。文章末尾是需要安装模块的链接，大家可以一键直达。 参考链接karma官网https://karma-runner.github.io/2.0/intro/installation.htmlkarma-clihttps://www.npmjs.com/package/karma-clikarma-jasminehttps://www.npmjs.com/package/karma-jasminejasmine-corehttps://www.npmjs.com/package/jasmine-corekarma-coveragehttps://www.npmjs.com/package/karma-coverage]]></content>
      <categories>
        <category>前端测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>karma</tag>
        <tag>jasmine</tag>
        <tag>phantomJS</tag>
        <tag>Babel</tag>
        <tag>ES6</tag>
        <tag>System</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 07 - 标签声明（Label Statement）]]></title>
    <url>%2F2018%2F03%2F10%2Fjavascript_07_label_statement%2F</url>
    <content type="text"><![CDATA[引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？ 再看一个例子，你也一定见到过这样的写法：12345// 假设str是你通过ajax接收到的JSON串var str = '&#123;"name": "liu", "age": 20&#125;';var obj = eval('(' + str + ')');console.log(obj); 那么，你有没有想过 eval 里面为什么要加上括号呢？如果不加又是什么情况？（提前剧透，不加括号这里会报错哦）。 接着往下看，当你读完这篇文章的时候，心中的疑惑会完全解开。 Label Statement学过C语言的同学知道，C的语法中有一个语句叫：goto，同时老师也多次强调不让我们使用goto语句，因为会大大影响程序的可读性和可维护性。 我们先来看一段C语言的goto代码：12345678910111213void main()&#123; int a=2, b=3; if(a&gt;b) &#123; goto aa; &#125; printf("hello"); aa: printf("s"); return 0;&#125; 当 a &lt; b 的时候，这里会打印字符串 “hello”，然后结束。当 a &gt; b 的时候，由于goto语句的作用，就会跳过 print(“hello”)，直接跳到 aa 标签声明的代码块中，打印字符 “s”，然后结束。 这就是goto语句的作用，通过标签声明一个代码块，然后在任何地方都可以执行 goto ‘labe’ 来进行程序跳转。 显而易见，这样的写法，违背了程序顺序执行的原则，会跳来跳去，最后导致根本无法维护，所以，记住老师的话，不要使用 goto 语句。 那么，看完了C语言中的 goto 语句，和我们的 JavaScript 又有什么关系呢？这就引出了今天的主题：Label Statement，它就是 JS 中的 goto 语句。 用法首先明确一个原则，在JavaScript中，语句优先。也就是说，如果一段代码既能够以语句的方式解析，也能用语法的方式解析，在JS中，会优先按语句来解析。 1&#123; a : 1 &#125; 上面这段代码，在JS中的执行结果是什么呢？大家思考2分钟…. 好，2分钟已过，大家有结果了吗？千万不要在浏览器的控制台中去写这段代码，虽然结果和你开始想的结果一样，但是，它是错误的。 这是在console控制台中执行的结果： 这是在watch中的执行结果： 可以看到两个结果是不一样的。console是经过处理的这里不能相信，watch是直接JS的运行环境执行后的结果，是正确的。 为什么 { a : 1 } 结果会是 1 呢？ 我换一个写法：123&#123; a : 1&#125; 相信有的同学已经明白了，在JS中，{}既可以代表代码块，又可以作为Object的语法标志。那么我们前面说过，JS是语句优先的，当一段代码既可以按照语句解析，又可以按照语法解析的时候，会优先按语句解析。 当把{}当做是代码块的时候，里面的 a : 1，是不是很像C语言goto语句的标签声明呢？开头我们提出的第一个问题，如果用这种方式来解决，代码如下：1234567891011aa : &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) break aa; &#125; &#125;&#125;console.log('done'); aa是标签声明，包裹一个代码块，break 的作用是跳出当前的循环，本来是无法跳出外面那层for循环的，但是 break aa，这里跳出了整个代码块。 当然，这种写法是完全不提倡的，这里只是用来说明JS中的Label Statement这个特性，大家千万不要这样写代码。 再来看开头提出的第二个问题：12345// 假设str是你通过ajax接收到的JSON串var str = '&#123;"name": "liu", "age": 20&#125;';var obj = eval('(' + str + ')');console.log(obj); 我们知道，eval(str)会把接收到的字符串在当前上下文中执行，如果不加括号：1eval('&#123;"name": "liu", "age": 20&#125;&#125;') 这里的执行语句就会变成：123&#123; "name" : "liu", "age" : 20&#125; {}按照语句解析，执行里面的逗号表达式，我们知道逗号表达式要求每一项都必须是表达式，输出最后一项的结果，而这里不满足要求，所以会报错。 但是加上括号就变成了这样：123(&#123; "name" : "liu", "age" : 20&#125;) 小括号可以把里面的内容当做表达式来解析，那么里面的内容就是一个对象了。 这也是立即执行函数的原理：123(function () &#123; console.log('IIFE');&#125;)() 小括号把函数声明变成了函数表达式，后面再跟一个小括号表示调用。 结束这里通过几个例子，引出了 JavaScript 的标签声明语句（Label Statement），从而解释了一些我们常用写法的原理。 以后万一有人问你为什么 eval() 解析JSON要加括号呢？这回知道怎么说了吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Label Statement</tag>
        <tag>C语言</tag>
        <tag>Goto语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML - 移动端 meta viewport]]></title>
    <url>%2F2017%2F12%2F10%2Fhtml_meta_viewport%2F</url>
    <content type="text"><![CDATA[我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。 CSS 像素（css pixel） / 密度独立像素（density independent pixels - dip）CSS 像素是 web 编程中的概念，是抽象的，不是实际存在的。它是独立于设备用于逻辑上衡量像素的单位，所以又叫密度独立像素。dip 有时候也缩写为 dp 。 屏幕尺寸指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。 屏幕像素密度（pixels per inch - ppi）指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的 ppi = √(1920^2+1080^2) / 5.5 ≈ 401ppi 。也就是说它每英寸可以显示 440 个物理像素点。 设备像素比指物理像素和密度独立像素的比值。window.devicePixelRatio = 物理像素 / dip。可以通过 window.devicePixelRatio 获得，该属性被所有WebKit浏览器以及Opera所支持。 viewportviewport 是指 web 页面上用户的可见区域。 viewport 的大小是和设备相关的，在移动端例如手机上，viewport 的大小是比 PC 端要小的，一般无论手机还是平板，默认的 viewport 大小都是 980px 。刚开始 web 页面仅仅是在 PC 端进行查看的，但是后来随着移动互联网的发展，越来越多的 web 访问是通过移动端进行的，但是因为 PC 的 viewport 要比移动端大，所以为了快速修复这个问题，移动端的浏览器默认只是把整个页面等比例缩小到移动端的 viewport 大小。 这样做的后果就是，用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。 那么回到我们最开始写的 meta 标签：1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; device-width 是指这个设备最理想的 viewport 宽度。iPhone6 之前的 device-width 都是 320px ，iPhone6 是 375px ，iPhone6 Plus 是 414px ，而这个 device-width 是和 CSS像素（也叫密度独立像素 dip）是相同的。也就是说，web 页面中的 CSS像素的值等于 device-width 时，对应到手机上就是占满全屏的宽度。 安卓手机的 device-width 有320px、360px 和 384px 等等，不同的设备 device-width 是不一样的。 initial-scale=1.0 是指初始化的时候缩放大小是1，也就是不缩放。 user-scalable=0 是指禁止用户进行缩放。 maximum-scale=1.0 是指用户最大缩放大小是1，其实在禁止用户缩放以后，这一句可以省略。 在设计人员为移动端设计页面的时候经常可以听到2倍图和3倍图这些词语，这又是什么意思呢，我们以 iPhone6 举例： iPhone6 的分辨率（也就是物理像素）是 1334*750 像素，它的 device-width 是 375px 。 如果我们将屏幕横向分成 375 份，CSS 中 1px 占用的1份，因为屏幕就那么大，CSS中 width 等于 375px 时横向就会占满全屏，但是实际上存在的物理像素点横向是750个 ，所以在我们写 CSS 时 1px 对应到屏幕上是占用了2个物理像素点。 如果我们不写 width=device-width 这一句的话，默认 viewport 宽是 980px 。那么把 iPhone6 的屏幕横向分成980份，CSS 中 1px 占用1份，但是真正的像素点横向只有750个，这就意味着，实际上渲染出来的宽度是 75/98 个像素大小（只是理论上）。 设计人员在设计原型图的时候以 750px 的宽度为基准，我们在写 CSS的时候缩写一半来使用，但是在渲染的时候 1px 等于 2px 的物理像素，所以整个图片还是按 750px 的宽度来显示的，不会失真。 如果设计人员以 375px 的宽度为基准，那么我们在使用的时候直接把设计图中的像素宽度用在 CSS 中，那么在渲染的时候，1px 等于 2px 的物理像素，相当于图片会放大2倍，就会产生失真。 总结在添加 之后，移动端的 viewport 宽度会从默认的 980px 变成各个设备的 device-width 。 CSS 中的 100% 就等于 device-width 。 知道了这些，我们就可以结合别的知识，为页面进行响应式布局了。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>meta</tag>
        <tag>viewport</tag>
        <tag>pt</tag>
        <tag>dip</tag>
        <tag>ppi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 06 - 变量对象]]></title>
    <url>%2F2017%2F08%2F10%2Fjavascript_06_variable_object%2F</url>
    <content type="text"><![CDATA[上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明： Variable Object 就代表变量对象。Scope Chain 代表作用域链。thisValue 代表神秘的 this 。 作用域链和 this 留到后面再讲，今天我们先来弄明白变量对象。 变量对象 A variable object is a scope of data related with the execution context. It’s a special object associated with the context and which stores variables and function declarations are being defined within the context. 变量对象(variable object) 是与执行上下文相关的数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 变量对象（Variable Object – 简写 VO）是一个抽象的概念，指代与执行上下文相关的特殊对象，它存储着在上下文中声明的： 变量（var） 函数声明 （function declaration，简写 FD） 函数的形参（arguments） 我们假设变量对象为一个普通 ECMAScript 对象：1VO = &#123;&#125;; 就像前面讲过的，VO 是执行上下文的一个属性：12345activeExecutionContext = &#123; VO: &#123; // 上下文数据 （vars, FD, arguments） &#125;&#125; 因为变量对象是一个抽象的概念，所以并不能通过变量对象的名称直接访问，但是却可以通过别的方法来间接访问变量对象，例如在全局上下文环境的变量对象会有一个属性 window (DOM 中) 可以引用变量对象自身，全局上下文环境的另一个属性 this 也指向全局上下文环境的变量对象。 举个例子：1234567891011var a = 2;function foo (num) &#123; var b = 5;&#125;(function exp () &#123; console.log(111);&#125;)foo(10); 这里对应的变量对象是：123456789101112131415161718// 全局上下文环境的变量对象VO(globalContext) = &#123; // 一些全局环境初始化时系统自动创建的属性： Math、String、Date、parseInt等等 ··· // 全局上下文的变量对象中有一个属性可以访问到自身，在浏览器中这个属性是 window ，在 node 中这个属性是 global window: global // 自己定义的属性 a: 10, foo: &lt;reference to function&gt;&#125;;// foo 函数上下文的变量对象VO(foo functionContext) = &#123; num: 10, b: 5&#125;; 注意：函数表达式并不包括在变量对象中。 不同执行上下文中的变量对象执行上下文包括：全局上下文、函数上下文和 eval() 上下文。 全局上下文中的变量对象这里我们先来了解一下什么是全局对象：12全局对象（global object）是指在进入任何执行上下文之前就已经创建了的对象。这个对象只有一份，它的属性在程序中的任何地方都可以访问，全局对象的生命周期终止于程序退出的那一刻。 全局对象初始化时系统将创建并初始化一系列原始属性，例如：Math、String、Date、parseInt、window等等，之后是我们在全局上下文中自己定义的全局变量。在 DOM 中，全局对象的 window 属性可以引用全局对象自身，全局上下文环境的 this 属性也可以引用全局对象。1234567891011121314151617// 全局执行上下文环境EC(globalContext) = &#123; // 全局对象（全局上下文环境的变量对象） global: &#123; Math: &lt;...&gt;, String: &lt;...&gt;, ... ... window: global // 引用全局对象自身 &#125;, // this 属性 this: global // 作用域链 ...&#125; 举个例子：12345var a = 10;console.log(a); // 10console.log(window.a); // 10console.log(this.a); // 10 因此，在全局上下文环境中，变量对象用全局对象来表示。 函数上下文中的变量对象在函数上下文中，变量对象用活动对象 AO（Active Object）来表示。1VO(functionContext) = AO 活动对象是在进入函数上下文时刻被创建的，它是通过函数的 arguments 属性进行初始化。arguments 也是一个对象。12345AO = &#123; arguments: &#123; ... &#125;&#125; arguments 是活动对象的一个属性，它也是一个对象，包括以下属性： callee - 指向当前函数的引用 length - 真正传递的参数个数 properties-indexes - index 是字符串类型的整数，例如”1”: “aa”，类似于数组类型，也可以通过arguments[1]来访问，但是不能用数组的方法（push, pop等等）。另外，properties-indexes 的值和实际传递进来的参数之间是共享的，一个改变，另一个也随之改变。 举个例子：123456789101112131415161718192021222324252627282930function foo (x, y, z) &#123; // 声明的函数参数数量 console.log(foo.length); // 3 // 实际传递进来的参数数量 console.log(arguments.length); // 2 // arguments 的 callee 属性指向当前函数 console.log(arguments.callee === foo) // true // 参数共享 console.log(x === arguments[0]); // true console.log(x); // 10 arguments[0] = 20; console.log(x); // 20 x = 30; console.log(arguments[0]); // 30 // 但是注意，没有传递进来的参数 z ，和第3个索引值是不共享的 z = 40; console.log(arguments[2]); // undefined arguments[2] = 50; console.log(z); // 40&#125;foo(10, 20); 代码是如何被处理的在第1节中我们讲过js 代码的编译过程，其中有一步叫作预编译，是说在代码执行前的几微秒会首先对代码进行编译，形成词法作用域，然后执行。 那么执行上下文的代码就就可以分成两个阶段来处理： 进入执行上下文（预编译） 执行代码 而变量对象的修改变化和这两个阶段是紧密相关的。并且所有类型的执行上下文都会有这2个阶段。 进入执行上下文当引擎进入执行上下文时（代码还未执行），VO 里已经包含了一些属性： 函数的所有形参（如果是函数执行上下文）由名称和对应值组成的一个变量对象的属性被创建，如果没有传递对应的实参，那么由名称和 undefined 组成的一种变量对象的属性也会被创建。 所有的函数声明（Function Declaration - FD）由名称和对应值（函数对象 function object）组成的一个变量对象的属性被创建，如果变量对象已经存在相同名称函数的属性，则完全替换这个属性。 所有的变量声明（Variable Declaration - var）由名称和对应值（在预编译阶段所有变量值都是 undefined）组成的一个变量对象的属性被创建，如果变量名和已经声明的形参或者函数相同，则变量名不会干扰已经存在的这类属性，如果已经存在相同的变量名，则跳过当前声明的变量名。 注意：变量碰到相同名称的变量是忽略，函数碰到相同名称的函数是覆盖。 举个例子：1234567891011function foo (a, b) &#123; var c = 5; function bar () &#123;&#125;; var d = function _d () &#123;&#125;; (function f () &#123;&#125;);&#125;foo(10); 当进入带有实参10的 foo 函数上下文时（预编译时，此时代码还没有执行），AO 结构如下：12345678AO(foo) = &#123; a: 10, b: undefined, c: undefined, bar: &lt;reference to FunctionDelcaration "bar"&gt;, d: undefined &#125;; 注意，函数表达式 f 并不包含在活动对象 AO 内。也就是说，只有函数声明会被包含在变量对象 VO 里面，函数表达式并不会影响变量对象。 行内函数表达式 _d 则只能在该函数内部可以使用， 也不会包含在 VO 内。 这之后，就会进入第2个阶段，代码执行阶段。 代码执行在这个阶段，AO/VO 已经有了属性（并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined）。 AO 在代码执行阶段被修改如下：12AO['c'] = 5;AO['d'] = &lt;reference to FunctionDelcaration "_d"&gt; 再次要提醒大家，因为函数表达式 _d 已经保存到了声明的变量 d 上面，所以变量 d 仍然存在于 VO/AO 中。我们可以通 d() 来执行函数。但是函数表达式 f 却不存在于 VO/AO 中，也就是说，如果我们想尝试调用 f 函数，不管在函数定义前还是定义后，都会出现一个错误”f is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。 再来一个经典例子：12345678910console.log(x); // functionvar x = 10;console.log(x); // 10x = 20;function x () &#123;&#125;;console.log(x); // 20 这里为什么是这样的结果呢？ 上边我们说过，在代码执行之前的预编译，会为变量对象生成一些属性，先是形参，再是函数声明，最后是变量，并且变量并不会影响同名的函数声明。 所以，在进入执行上下文时，AO/VO 结构如下：12345AO = &#123; x: &lt;reference to FunctionDeclaration "x"&gt; // 在碰到变量声明 x 时，因为已经存在了函数声明 x ，所以会忽略&#125; 紧接着，在代码执行阶段，AO/VO 被修改如下：12AO['x'] = 10;AO['x'] = 20; 希望大家可以好好理解变量对象，对于理解我们后边要讲的作用域链有很大的帮助。 变量有一些文章说过： 不管是使用 var 关键字（在全局上下文）还是不使用 var 关键字（在任何地方），都可以声明一个变量。 请记住，这是错误的观念。 任何时候，变量都只能通过使用 var 关键字来声明（ES6 之前）。 1a = 10; 上面的赋值语句，仅仅是给全局对象创建了一个新属性（在在非严格模式，严格模式下会报错），但注意，它不是变量。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript 规范中变量的概念。 让我们通过一个例子来看一下两者的区别：12345console.log(a); // undefinedconsole.log(b); // 报错，b is not definedb = 10;var a = 20; 只要我们很好的理解了：变量对象、预编译阶段和执行代码阶段，就可以迅速的给出答案。 预编译（进入上下文）阶段：123VO = &#123; a: undefined&#125; 我们可以看到，因为 b 不是通过 var 声明的，所以这个阶段根本就没有 b ，b 只有在代码执行阶段才会出现。但是在这个例子中，还没有执行到 b 那就已经报错了。 我们稍微更改一下示例代码：123456789console.log(a); // undefinedb = 10;console.log(b); // 10 代码执行阶段被创建console.log(window.b); // 10console.log(this.b); // 10var a = 20;console.log(a); // 20 代码执行阶段被修改 关于变量，还有一个很重要的知识点。 变量不能用 delete 操作符来删除。1234567891011121314a = 10;console.log(window.a); // 10console.log(delete a); // trueconsole.log(window.a); // undefinedvar b = 20;console.log(window.b); // 20console.log(delete b); // falseconsole.log(window.b); // 20 注意：这个规则在 eval() 上下文中不起作用。 123456eval('var a = 10;');console.log(window.a); // 10console.log(delete a); // trueconsole.log(window.a); // undefined 总结这一节中我们讲了变量对象，下一节就是我们的重头戏 - 作用域链。希望大家可以持续关注我，我们一起进步。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>执行上下文</tag>
        <tag>变量对象</tag>
        <tag>Execution Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 05 - 执行上下文]]></title>
    <url>%2F2017%2F06%2F03%2Fjavascript_05_execution_context%2F</url>
    <content type="text"><![CDATA[在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。 可执行代码有几种前面说到当引擎执行到可执行代码的时候，就会将当前上下文压入上下文栈中。那么可执行的代码又分为几种？ 在这里，我们先假设定义执行上下文栈是一个数组：1EC = []; 第一种可执行代码 – 全局代码：全局类型代码是在加载外部的 js 文件或者本地 标签中的代码。注意，在全局代码中，并不包含定义在全局环境 function 内的代码。 程序启动后进入初始化全局环境：123EC = [ globalContext]; 第二种可执行代码 – 函数代码：当定义的函数被执行时，就进入了函数代码，当前函数上下文被压入 EC 栈中。注意，在函数代码中，也不包含定义在该函数内部环境 function 内的代码。 例如：123456789var a = 10;function foo () &#123; var b = 20; foo();&#125;foo(); 这个例子中的 EC 是什么样子的呢？ 1234567891011121314151617181920212223242526272829// 初始化EC = [ globalContext];// 第一次调用 foo 函数EC = [ &lt;foo&gt; functionContext, globalContext];// 在 foo 内递归调用自己EC = [ &lt;foo&gt; functionContext - recursively, &lt;foo&gt; functionContext, globalContext];// 继续递归调用自己EC = [ ...... &lt;foo&gt; functionContext - recursively2, &lt;foo&gt; functionContext - recursively, &lt;foo&gt; functionContext, globalContext];// 递归会不断调用下去，因为没有结束条件，所以这是一个死循环// 所以，EC 只会不断增加新的上下文，但是却不会退出 只有每次 return 的时候，才会退出当前执行上下文，相应上下文会从栈中弹出，栈指针会自动移动位置。 注意，当函数没有明确指明 return 什么的时候，默认 return undefined 。 如果有抛出的异常没有被截获的话，也有可能从一个或多个执行上下文中退出。当所有代码执行完以后，EC 中只会包含全局上下文（global context），当程序退出以后，全局上下文也会退出。 第三种可执行代码 – eval 代码：eval 函数在调用的时候会产生上下文。例如：12345678eval('var a = 10');(function foo () &#123; eval('var b = 20');&#125;());alert(a); // 10alert(b); // ReferenceError，b is not defined 这个例子中 EC 的变化如下：123456789101112131415161718192021222324252627282930313233343536373839// 初始化EC = [ globalContext];// eval('var a = 10');EC = [ evalContext, globalContext];// eval 执行完毕EC = [ globalContext];// 立即执行函数 fooEC = [ &lt;foo&gt; functionContext, globalContext];// eval('var b = 20');EC = [ evalContext, &lt;foo&gt; functionContext, globalContext];// eval 执行完毕EC = [ &lt;foo&gt; functionContext, globalContext];// foo 执行完毕EC = [ globalContext]; 这就是一个典型的逻辑调用上下文栈。 在 setTimeout 和 setInterval 函数中的第一个参数也可以传入代码字符串，但是这个一般不会这么去用，所以这里也就不讨论了。 结论执行上下文环境是我们了解变量对象和作用域链的基础，大家一定要好好理解（其实也并不难），下一节我们来讨论变量对象，相信会让大家有一定的收获。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 04 - 提升]]></title>
    <url>%2F2017%2F05%2F10%2Fjavascript_04__variable_lifting%2F</url>
    <content type="text"><![CDATA[到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。 声明提升先看代码：12345a = 2;var a;console.log(a); 大家认为这里会输出什么？ 有一些人认为是 undefined ，因为 var a; 是在 a = 2; 之后，所以会觉得 undefined 覆盖了 a 的值。但是，真正的结果是 2 。 再看一段代码：1234567891011121314console.log(a);var a = 2;``` 鉴于上一个例子，有些人会认为这里会输出 2 ，也有人认为由于 a 在使用前并没有声明，所以这里会报错。但是，这里的结果是 undefined 。之前讨论编译器的时候，我们知道 JS 引擎会在解释代码之前首先对其进行编译。编译阶段的第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。因此，正确的思路是，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。当你看到 ***var a = 2;*** 时，JavaScript 实际上会将其看成两个声明：***var a;*** 和 ***a = 2;*** 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。所以，在第一个例子中，代码的等价形式是这样的： var a; a = 2; console.log(a);1第二个例子中，代码的等价形式是这样的： var a; console.log(a); a = 2;12345这个过程就好像是变量和函数声明从它们的代码中出现的位置被“移动”到了最上面。这个过程就叫作“提升”。**注意**，只有声明本身会被提升，而赋值操作和其他运行逻辑都会停留在原地，想象一下，如果提升会改变代码的执行顺序，那么会造成非常严重的破坏。还有一点，函数声明会被提升，但是函数表达式不会被提升。 foo(); // 报错，TypeError: foo is not a function，因为这里 foo 是 undefined，并不是一个函数 var foo = function foo() { // something else}123这段程序中的变量标识符 foo 被提升并分配给所在的作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError 。但是，foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会被赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，所以会抛出 TypeError 异常。同时，即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： foo();bar(); var foo = function bar () { // something else};1这段代码经过提升后，实际上等价于： var foo; foo();bar(); foo = function () { var bar = …self… // something else};12345### 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节是，**函数声明会首先被提升，然后才是变量。**考虑如下代码： foo(); // 1 var foo; function foo () { console.log(1);} foo = function () { console.log(2);};1这里会输出 1 而不是 2 。这段代码其实等价于： function foo () { console.log(1);} foo(); // 1 foo = function () { console.log(2);};123***var foo;*** 尽管出现在 function foo() &#123;...&#125; 声明之前，但是它是重复声明，所以会被编译器忽略，因为函数声明会被提升到变量声明之前。注意，尽管重复的 var 声明会被忽略，但重复的函数声明却会覆盖前一个同名函数。 foo(); // 3 function foo () { console.log(1);} var foo = function () { console.log(2);}; foo(); // 2 function foo () { cosole.log(3);}1这个例子充分说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。上面那个例子，等价于： function foo () { cosole.log(3);} foo(); // 3 foo = function () { console.log(2);}; foo(); // 212还有一些人会犯如下错误： foo(); // 2 var a = true; if (a) { function foo () { console.log(1); }} else { function foo () { console.log(2); }}1因为 if 并没有块作用域，所以这里的函数声明会提升到其作用域最前边，而后一个 function 声明会覆盖前一个，所以这里结果是 2 。这里代码等价如下： function foo () { console.log(2);} var a; foo(); // 2 a = true; if (a) { } else { }` 总结我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a; 和 a = 2; 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被处理（预编译）。可以将这个过程想象成所有的声明（变量和函数）都会被“移动”到各自的作用域的最顶端，这个过程叫作提升。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 03 - 函数作用域和块作用域]]></title>
    <url>%2F2017%2F04%2F10%2Fjavascript_03__function_scope%2F</url>
    <content type="text"><![CDATA[在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上 在这段代码中，函数 foo 的作用域包含了标识符a、b、c 和 bar ，函数 bar 的作用域中又包含别的标识符。 由于标识符 a、b、c 和 bar都属于函数 foo 的作用域，所以在全局作用域中访问会报错，因为它们都没有定义，但是在函数 foo 内部，这些标识符都是可以访问的，这就是函数作用域。 为什么要有这些作用域当我们用作用域把代码包起来的时候，其实就是对它们进行了“隐藏”，让我们对其有控制权，想让谁访问就可以让谁访问，想禁止访问也很容易。 想像一下，如果所有的变量和函数都在全局作用域中，当然我们可以在内部的嵌套作用域中访问它们，但是因为暴露了太多的变量或函数，它们可能被有意或者无意的篡改，以非预期的方式使用，这就导致我们的程序会出现各种各样的问题，严重会导致数据泄露，造成无法挽回的后果。 例如：123456789var obj = &#123; a: 2, getA: function () &#123; return this.a; &#125;&#125;;obj.a = 4;obj.getA(); // 4 这个例子中，我们可以任意修改对象 obj 内部的值，在某种情况下这并不是我们所期望的，采用函数作用域就可以解决这个问题，私有化变量 a 。12345678910111213141516var obj = (function () &#123; var a = 2; return &#123; getA: function () &#123; return a; &#125;, setA: function (val) &#123; a = val; &#125; &#125;&#125;());obj.a = 4;obj.getA(); // 2obj.setA(8);obj.getA(); // 8 这里通过立即执行函数（IIFE）返回一个对象，只能通过对象内的方法对变量 a 进行操作，其实这里有闭包的存在，这个我们在以后会深入讨论。 “隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，冲突会导致变量的值被意外覆盖。 例如：123456789101112function foo () &#123; function bar (a) &#123; i = 3; // 修改了 for 循环所属作用域中的 i console.log(a + i); &#125; for (var i = 0; i &lt; 10; i++) &#123; bar(i * 2); // 这里因为 i 总会被设置为 3 ，导致无限循环 &#125;&#125;foo(); bar(…) 内部的赋值表达式 i = 3 意外的覆盖了声明在 foo(…) 内部 for 循环中的 i ，在这个例子中因为 i 始终被设置为 3 ，永远满足小于 10 这个条件，导致无限循环。 bar(…) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3; 就可以满足这个要求。另外一种方法是采用一个完全不同的标识符名称，比如 var j = 3; 。但是软件设计在某种情况下可能自然而然的要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。 总结来说，作用域可以起到两个作用： 私有化变量或函数 规避同名冲突 函数声明和函数表达式如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 函数声明举个例子：123function foo () &#123; // something else&#125; 这就是一个函数声明。 函数表达式分为匿名函数表达式和具名函数表达式。 对于函数表达式来说，最熟悉的场景可能就是回调参数了，例如：123setTimeout(function () &#123; console.log("I wait for one second.")&#125;, 1000); 这个叫作匿名函数表达式，因为 function ()… 没有名称标识符。函数表达式可以是匿名的，但是函数声明不可以省略函数名，在 javascript 中这是非法的。 匿名函数表达式书写简便，但是它也有几个缺点需要注意： 匿名函数在浏览器栈追踪中不会显示出有意义的函数名，这会加大调试难度。 如果没有函数名，当函数需要引用自身的时候就只能使用已经不是标准的 arguments.callee 来引用，比如递归。在事件触发后的事件监听器中也有可能需要通过函数名来解绑自身。 匿名函数对代码的可读性和可理解性有一定的影响。一个有意义的函数名可以让代码不言自明。 具名函数表达式又叫行内函数表达式，例如：123setTimeout(function timerHandler () &#123; console.log("I wait for one second.")&#125;, 1000); 这样，在函数内部需要引用自身的时候就可以通过函数名来引用，当然要注意，这个函数名只能在这个函数内部使用，在函数外使用时未定义的。 立即执行函数表达式（IIFE）IIFE 全写是 Immediately Invoked Function Expression，立即执行函数。12345678var a = 2;(function foo () &#123; var a = 3; console.log(a); // 3&#125;)();console.log(a); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个函数表达式，通过在末尾加上另一对 ( ) 括号可以立即执行这个函数，比如 (function () {})() 。第一个 ( ) 将函数变成函数表达式，第二个 ( ) 执行了这个函数。 也有另外一种立即执行函数的写法，(function () {}()) 也可以立即执行这个函数。12345678var a = 2;(function foo () &#123; var a = 3; console.log(a); // 3&#125;());console.log(a); // 2 这两种写法功能是完全一样的，具体看大家使用。 IIFE 的另一种普遍的进阶用法是把它们当做函数调用并传递参数进去。123456789var a = 2;(function (global) &#123; var a = 3; console.log(a); // 3 console.log(global.a) // 2&#125;)(window);console.log(a); // 2 我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递你需要的任何东西，并将变量命名为任何你觉得合适的文字。这对于改进代码风格是非常有帮助的。 这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖的异常（这并不常见）。将一个参数命名为 undefined ，但是并不传入任何值，这样就可以保证在代码块中 undefined 的标识符的值就是 undefined 。12345678undefined = true;(function IIFE (undefined) &#123; var a; if (a === undefined) &#123; console.log("Undefined is safe here.") &#125;&#125;()); 块作用域ES5 及以前 JavaScript 中具有块作用域的只有 with 和 try…catch 语句，在 ES6 及以后的版本添加了具有块作用域的变量标识符 let 和 const 。 with123456789101112var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); // 2 console.log(b); // 3&#125;console.log(a); // 报错，a is not definedconsole.log(b); // 报错，a is not defined 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 try…catch1234567try &#123; undefined(); // 非法操作&#125; catch (err) &#123; console.log(err); // 正常执行&#125;console.log(err); // 报错，err is not defined try/catch 中的 catch 分句会创建一个块作用域，其中的变量声明仅在 catch 内部有效。 letlet 关键字可以将变量绑定到任意作用域中（通常是 {…} 内部）。换句话说，let 为其声明的变量隐式的劫持了所在的块作用域。1234567891011var foo = true;if (foo) &#123; let a = 2; var b = 2; console.log(a); // 2 console.log(b); // 2&#125;console.log(b); // 2console.log(a); // 报错，a is not defined 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些代码块作用域中有绑定的变量，并且习惯性的移动这些块或者将其包含到其他块中，就会导致代码混乱。 为块作用域显示的创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。12345678var foo = true;if (foo) &#123; &#123; let a = 2; console.log(a); // 2 &#125;&#125; 在代码的任意位置都可以使用 {…} 括号来为 let 创建一个用于绑定的块。 还有一点要注意的是，在使用 var 进行变量声明的时候会存在变量提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会存在作用域提升，声明的变量在被运行之前，并不存在。123456789console.log(a); // undefinedconsole.log(b); // 报错， b is not defined// 在浏览器中运行这段代码时，因为前面报错了，所以不会看到接下来打印的结果，但是理论上就是这样的结果var a = 2;console.log(a); // 2 let b = 4;console.log(b); // 4 2.3.1 垃圾收集另一个块作用域非常有用的原因和闭包及垃圾内存的回收机制有关。举个例子：12345678910111213function processData (data) &#123; // do something&#125;var bigData = &#123;...&#125;;processData(bigData);var btn = document.getElementById('my_button');btn.addEventListener('click', function () &#123; console.log('button clicked');&#125;, false); 这个按钮点击事件的回调函数中并不需要 bigData 这个非常占内存的数据，理论上来说，当 processData 函数处理完之后，这个占有大量空间的数据结构就可以被垃圾回收了。但是，由于这个事件回调函数形成了一个覆盖当前作用域的闭包，JavaScript 引擎极有可能依然保存着这个数据结构（取决于具体实现）。 使用块作用域可以解决这个问题，可以让引擎清楚的知道没有必要继续保存这个 bigData 。123456789101112131415function processData (data) &#123; // do something&#125;&#123; let bigData = &#123;...&#125;; processData(bigData);&#125;var btn = document.getElementById('my_button');btn.addEventListener('click', function () &#123; console.log('button clicked');&#125;, false); 2.3.2 let 循环一个 let 可以发挥优势的典型例子就是 for 循环。12345678910var lists = document.getElementsByTagName('li');for (let i = 0, length = lists.length; i &lt; length; i++) &#123; console.log(i); lists[i].onclick = function () &#123; console.log(i); // 点击每个 li 元素的时候，都是相对应的 i 值，而不像用 var 声明 i 的时候，因为没有块作用域，所以在回调函数通过闭包查找 i 的时候找到的都是最后的 i 值 &#125;;&#125;;console.log(i); // 报错，i is not defined for 循环头部的 let 不仅将 i 绑定到 fir 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保上一个循环迭代结束时的值重新进行赋值。 当然，我们在 for 循环中使用 var 时也可以通过立即执行函数形成一个新的闭包来解决这个问题。123456789var lists = document.getElementsByTagName('li');for (var i = 0, length = lists.length; i &lt; length; i++) &#123; lists[i].onclick = (function (j) &#123; return function () &#123; console.log(j); &#125; &#125;(i));&#125; 或者123456789var lists = document.getElementsByTagName('li');for (var i = 0, length = lists.length; i &lt; length; i++) &#123; (function (i) &#123; lists[i].onclick = function () &#123; console.log(i); &#125; &#125;(i));&#125; 其实原理无非就是，为每个迭代创建新的闭包，立即执行函数执行完后本来应该销毁变量，释放内存，但是因为这里有回调函数的存在，所以形成了闭包，然后通过形参进行同名变量覆盖，所以找到的 i 值就是每个迭代新闭包中的形参 i 。 const除了 let 以外，ES6 还引入了 const ，同样可以用来创建作用域变量，但其值是固定的（常亮）。之后任何试图修改值的操作都会引起错误。123456789101112var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常亮 a = 3; // 正常 b = 4; // 报错，TypeError: Assignment to constant variable&#125;console.log(a); // 3console.log(b); // 报错， b is not defined 和 let 一样，const 声明的变量也不存在“变量提升”。 总结函数是 JavaScript 中最常见的作用域单元。块作用域指的是变量和函数不仅可以属于所处的函数作用域，也可以属于某个代码块。 本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用哪种作用域，创造可读、可维护的优良代码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 02 - 词法作用域]]></title>
    <url>%2F2017%2F03%2F05%2Fjavascript_02_static_scope%2F</url>
    <content type="text"><![CDATA[两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。 举个例子：12345678910111213var a = 2;function foo1 () &#123; console.log(a);&#125;function foo2 () &#123; var a = 10; foo1();&#125;foo2(); 这里输出结果是多少呢？ 注意，这里结果打印的是 2。 可能会有一些同学认为是 10，那就是没有搞清楚词法作用域的概念。前边介绍了，词法作用域只取决于代码书写时的位置，那么在这个例子中，函数 foo1 定义时的位置决定了它的作用域，通过下图理解： foo1 和 foo2 都是分别定义在全局作用域中的函数，它们是并列的，所以在 foo1 的作用域链中并不包含 foo2 的作用域，虽然在 foo2 中调用了 foo1，但是 foo1 对变量 a 进行 RHS 查询时，在自己的作用域没有找到，引擎会去 foo1 的上级作用域（也就是全局作用域）中查找，而并不会去 foo2 的作用域中查找，最终在全局作用域中找到 a 的值为 2。 总结来说，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法JavaScript 中有 3 种方式可以用来“欺骗词法”，动态改变作用域。 第一种： eval JavaScript 中 eval(…) 函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 在执行 eval(…) 之后的代码时，引擎并不知道或在意前面的代码是以动态形式插入进来并对词法作用域环境进行修改的，引擎只会像往常一样正常进行词法作用域的查找。 举个例子：123456789function foo (str) &#123; eval(str); // "欺骗"词法 console.log(a);&#125;var a = 2;foo("var a = 10;"); 如大家所想，输出结果为 10。因为 eval(“var a = 10;”) 在 foo 的作用域中新创建了一个同名变量 a，引擎在 foo 作用域中对 a 进行 RHS 查询，找到了新定义的 a，值为 10，所以不再向上查找全局作用域中的 a，所以导致输出结果为 10，这就是 eval(…) 的作用。 在严格模式下，eval(…) 在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。 1234567891011'use strict;'function foo (str) &#123; eval(str); // eval() 有自己的作用域，所以并不会修改 foo 的词法作用域 console.log(a);&#125;var a = 2;foo("var a = 10;"); 这里输出结果为 2。 JavaScript 中还有一些功能和 eval(…) 类似的函数，例如 setTimeout(…) 和 setInterval(…) 的第一个参数可以是一个字符串，字符串的内容可以解释为一段动态生成的代码。这些功能已经过时并且不被提倡，最好不要使用它们。new Function(…) 函数的最后一个参数也可以接受代码字符串，并将其转化为动态生成的函数，也尽量避免使用。 在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。 第二种： withwith 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 举个例子：123456789101112var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); // 2 console.log(b); // 3 c = 4; &#125;;console.log(c); // 4, c 被泄露到全局作用域上 如上所示，我们对 c 进行 LHS 查询，因为在 with 引入的新作用域中没有找到 c，所以向上一级作用域（这里是全局作用域）查找，也没有找到，在非严格模式下，在全局对象中新建了一个属性 c 并赋值为 4。 with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会限制在这个块作用域中，而是被添加到 with 所处的函数作用域中。 严格模式下，with 被完全禁止使用。1234567891011121314'use strict';var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); console.log(b); c = 4; &#125;;console.log(c); 第三种： try…catchtry…catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。 举个例子：12345678910try &#123; foo();&#125; catch (err) &#123; console.log(err); var a = 2; // 打印出 "ReferenceError: foo is not defined at &lt;anonymous&gt;:2:4"&#125;console.log(a); // 2 当 try 中的代码出现错误时，就会进入 catch 块，此时会把异常对象添加到作用域链的最前端，类似于 with 一样，catch 中定义的局部变量也都会添加到包含 try…catch 的函数作用域（或全局作用域）中。 性能JavaScript 引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数定义的位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了 eval(…)、with 和 try…catch ，它只能简单的假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(…) 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了这些动态添加作用域的代码，所有的优化可能都是无意义的，因此最简单的做法就是完全不进行任何优化。 如果代码中大量使用 eval(…) 和 with，那么运行起来一定会变得非常缓慢。 结论很多时候我们对代码的分析出错，就是源于对词法作用域的忽略，所以让我们重新审视代码，继续努力！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 01 - 编译原理和作用域]]></title>
    <url>%2F2017%2F02%2F10%2Fjavascript_01_principles_of_compiler%2F</url>
    <content type="text"><![CDATA[在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。 编译原理大家通常把 javascript 归类为一种“动态”或“解释执行”的语言，但事实上，它是一门编译语言，但和传统的编译语言不同，它不是提前编译的，编译结果也不能进行移植。 在传统编译语言中，程序在执行之前会经历三个步骤，统称为“编译”： 分词/词法分析这个过程会把字符串分解成有意义的代码块，这些代码块被称为词法单元。例如 var a = 5; 这段程序通常会被分解成下面这些词法单元： var、a、=、5、; 。空格是否会被当成词法单元取决于空格在这门语言中是否有意义。 解析/语法分析这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。var a = 5; 的抽象语法树中可能如下图所示： 代码生成将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。简单来说，就是通过某种方法可以将 var a = 5; 的 AST 转化为一组机器指令，用来创建一个叫做 a 的变量（包括分配内存等），并将一个值 5 存储在 a 中。 比起那些编译过程只有三个步骤的语言的编译器来说，javascript 引擎要复杂的多。例如，在词法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 首先我们要清楚，javaScript 引擎不会有太多的时间来进行优化（相对于其它语言的编译器来说），因为与其它语言不同，javascript 的编译过程不是发生在构建之前的。 对于 javascript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在我们将要讨论的作用域背后，javascript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至重新编译）来保证性能最佳。 总结来说，任何 javascript 代码片段在执行前都要进行编译（预编译）。因此，javascript 编译器首先会对 var a = 5; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。 三位好友要真正理解作用域，我们首先要知道 javascript 中有三位好朋友： 引擎从头到尾负责整个 javascript 程序的编译及执行过程。 编译器负责语法分析及代码生成。 作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 当遇见 var a = 5; 这一段代码时，其实执行了两个步骤： （1）var a; 编译器会询问作用域是否已经有一个该名称的变量存在于同一作用域的集合中。如果是，编译器会忽略该声明，继续进行编译，否则它会要求在当前作用域的集合中声明一个新的变量，并命名为 a 。（2）a = 5; 编译器会为引擎生成运行时所需的代码，这些代码用来处理 a = 5; 这个赋值操作。引擎运行时会首先询问作用域，在当前作用域的集合中是否存在一个叫作 a 的变量，如果是，引擎就会使用这个变量。如果否，引擎会继续向父级作用域中查找，直到找到全局作用域，如果在全局作用域中仍没有找到 a ，那么在非严格模式下，引擎会为全局对象新建一个属性 a ，并将其赋值为5，在严格模式下，引擎会报错误 ReferenceError: a is not defined。 总结来说，变量的赋值会执行两个操作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在当前作用域中查找该变量（找不到就向上一级作用域查找），如果能够找到就会对它赋值。 LHS 和 RHS前面说到引擎在为变量赋值的时候会在作用域中查找变量，但是执行怎样的查找，用什么方式，会对最终的查找结果造成影响。 在 var a = 5; 这个例子中，引擎会对 a 进行 LHS 查询，当然，另外一个查找类型叫作 RHS。 对变量进行赋值所执行的查询叫 LHS。找到并使用变量值所执行的查询叫 RHS。 举个例子：12345678910function foo(a) &#123; // 这里隐式包含了 a = 2 这个赋值，所以对 a 进行了 LHS 查询 var b = a; // 这里对 a 进行了 RHS 查询，找到 a 的值，然后对 b 进行 LHS 查询，把 2 赋值给 b return a + b; // 这里包含了对 a 和 b 进行的 RHS 查询&#125;var c = foo(2);// 这里首先对 foo 进行 RHS 查询，找到它是一个函数，然后对 c 进行 LHS 查询把 foo 赋值给 c 所以上面的例子共包含 3 个 LHS 查询和 4 个 RHS 查询，你们都找对了吗？ 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 举个例子：1234567function foo(a) &#123; console.log(a + b);&#125;var b = 2;foo(2); // 4 这里对 b 进行的 RHS 查询在 foo 作用域中无法找到，但可以在上一级作用域（这个例子中就是全局作用域）中找到。 总结来说，遍历嵌套作用域链的规则很简单：引擎从当前执行的作用域中开始查找变量，如果都找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 总结编译器、引擎和作用域是 javascript 代码执行的基础，掌握好这些会对我们深入学习 javascript 起到事半功倍的效果，我们的学习之路才刚刚开始，大家加油！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
