<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[带你五步学会Vue SSR]]></title>
    <url>%2F2018%2F10%2F10%2Fjavascript_vue_ssr%2F</url>
    <content type="text"><![CDATA[前言SSR大家肯定都不陌生，通过服务端渲染，可以优化SEO抓取，提升首页加载速度等，我在学习SSR的时候，看过很多文章，有些对我有很大的启发作用，有些就只是照搬官网文档。通过几天的学习，我对SSR有了一些了解，也从头开始完整的配置出了SSR的开发环境，所以想通过这篇文章，总结一些经验，同时希望能够对学习SSR的朋友起到一点帮助。 我会通过五个步骤，一步步带你完成SSR的配置： 纯浏览器渲染 服务端渲染，不包含Ajax初始化数据 服务端渲染，包含Ajax初始化数据 服务端渲染，使用serverBundle和clientManifest进行优化 一个完整的基于Vue + VueRouter + Vuex的SSR工程 如果你现在对于我上面说的还不太了解，没有关系，跟着我一步步向下走，最终你也可以独立配置一个SSR开发项目，所有源码我会放到github上，大家可以作为参考。 正文1. 纯浏览器渲染这个配置相信大家都会，就是基于weback + vue的一个常规开发配置，这里我会放一些关键代码，完整代码可以去github查看。 目录结构12345678910111213- node_modules- components - Bar.vue - Foo.vue- App.vue- app.js- index.html- webpack.config.js- package.json- yarn.lock- postcss.config.js- .babelrc- .gitignore app.js1234567import Vue from 'vue';import App from './App.vue';let app = new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); App.vue1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;Foo&gt;&lt;/Foo&gt; &lt;Bar&gt;&lt;/Bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Foo from './components/Foo.vue';import Bar from './components/Bar.vue';export default &#123; components: &#123; Foo, Bar &#125;&#125;&lt;/script&gt; index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;纯浏览器渲染&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; components/Foo.vue1234567891011&lt;template&gt; &lt;div class="foo"&gt; &lt;h1&gt;Foo Component&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.foo &#123; background: yellowgreen;&#125;&lt;/style&gt; components/Bar.vue1234567891011&lt;template&gt; &lt;div class="bar"&gt; &lt;h1&gt;Bar Component&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.bar &#123; background: bisque;&#125;&lt;/style&gt; webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const path = require('path');const VueLoaderPlugin = require('vue-loader/lib/plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; mode: 'development', entry: './app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader'] // 如果需要单独抽出CSS文件，用下面这个配置 // use: ExtractTextPlugin.extract(&#123; // fallback: 'vue-style-loader', // use: [ // 'css-loader', // 'postcss-loader' // ] // &#125;) &#125;, &#123; test: /\.(jpg|jpeg|png|gif|svg)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 10000 // 10Kb &#125; &#125; &#125;, &#123; test: /\.vue$/, use: 'vue-loader' &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), new HtmlWebpackPlugin(&#123; template: './index.html' &#125;), // 如果需要单独抽出CSS文件，用下面这个配置 // new ExtractTextPlugin("styles.css") ]&#125;; postcss.config.js12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125;; .babelrc123456789&#123; "presets": [ "@babel/preset-env" ], "plugins": [ // 让其支持动态路由的写法 const Foo = () =&gt; import('../components/Foo.vue') "dynamic-import-webpack" ]&#125; package.json12345678910111213141516171819202122232425262728293031323334&#123; "name": "01", "version": "1.0.0", "main": "index.js", "license": "MIT", "scripts": &#123; "start": "yarn run dev", "dev": "webpack-dev-server", "build": "webpack" &#125;, "dependencies": &#123; "vue": "^2.5.17" &#125;, "devDependencies": &#123; "@babel/core": "^7.1.2", "@babel/preset-env": "^7.1.0", "babel-plugin-dynamic-import-webpack": "^1.1.0", "autoprefixer": "^9.1.5", "babel-loader": "^8.0.4", "css-loader": "^1.0.0", "extract-text-webpack-plugin": "^4.0.0-beta.0", "file-loader": "^2.0.0", "html-webpack-plugin": "^3.2.0", "postcss": "^7.0.5", "postcss-loader": "^3.0.0", "url-loader": "^1.1.1", "vue-loader": "^15.4.2", "vue-style-loader": "^4.1.2", "vue-template-compiler": "^2.5.17", "webpack": "^4.20.2", "webpack-cli": "^3.1.2", "webpack-dev-server": "^3.1.9" &#125;&#125; 命令启动开发环境1yarn start 构建生产环境1yarn run build 最终效果截图： 完整代码查看github 2. 服务端渲染，不包含Ajax初始化数据服务端渲染SSR，类似于同构，最终要让一份代码既可以在服务端运行，也可以在客户端运行。如果说在SSR的过程中出现问题，还可以回滚到纯浏览器渲染，保证用户正常看到页面。 那么，顺着这个思路，肯定就会有两个webpack的入口文件，一个用于浏览器端渲染weboack.client.config.js，一个用于服务端渲染webpack.server.config.js，将它们的公有部分抽出来作为webpack.base.cofig.js，后续通过webpack-merge进行合并。同时，也要有一个server来提供http服务，我这里用的是koa。 我们来看一下新的目录结构： 目录结构1234567891011121314151617181920- node_modules- config // 新增 - webpack.base.config.js - webpack.client.config.js - webpack.server.config.js- src - components - Bar.vue - Foo.vue - App.vue - app.js - entry-client.js // 新增 - entry-server.js // 新增 - index.html - index.ssr.html // 新增- package.json- yarn.lock- postcss.config.js- .babelrc- .gitignore 在纯客户端应用程序(client-only app)中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染(cross-request state pollution)。 所以，我们要对app.js做修改，将其包装为一个工厂函数，每次调用都会生成一个全新的根组件。 app.js 12345678910import Vue from 'vue';import App from './App.vue';export function createApp() &#123; const app = new Vue(&#123; render: h =&gt; h(App) &#125;); return &#123; app &#125;;&#125; 在浏览器端，我们直接新建一个根组件，然后将其挂载就可以了。 entry-client.js 12345import &#123; createApp &#125; from './app.js';const &#123; app &#125; = createApp();app.$mount('#app'); 在服务器端，我们就要返回一个函数，该函数的作用是接收一个context参数，同时每次都返回一个新的根组件。这个context在这里我们还不会用到，后续的步骤会用到它。 entry-server.js 1234567import &#123; createApp &#125; from './app.js';export default context =&gt; &#123; const &#123; app &#125; = createApp(); return app;&#125; 然后再来看一下index.ssr.html index.ssr.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;服务端渲染&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.options.files.js %&gt;"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 的作用是作为一个占位符，后续通过vue-server-renderer插件，将服务器解析出的组件html字符串插入到这里。是为了将webpack通过webpack.client.config.js打包出的文件放到这里（这里是为了简单演示，后续会有别的办法来做这个事情）。因为服务端吐出来的就是一个html字符串，后续的Vue相关的响应式、事件响应等等，都需要浏览器端来接管，所以就需要将为浏览器端渲染打包的文件在这里引入。用官方的词来说，叫客户端激活（client-side hydration）。所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。在 entry-client.js 中，我们用下面这行挂载(mount)应用程序：12// 这里假定 App.vue template 根元素的 `id="app"`app.$mount('#app') 由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。 如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性： 1&lt;div id="app" data-server-rendered="true"&gt; Vue在浏览器端就依靠这个属性将服务器吐出来的html进行激活，我们一会自己构建一下就可以看到了。 接下来我们看一下webpack相关的配置： webpack.base.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; mode: 'development', resolve: &#123; extensions: ['.js', '.vue'] &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.vue$/, use: 'vue-loader' &#125;, &#123; test: /\.js$/, use: 'babel-loader' &#125;, &#123; test: /\.css$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\.(jpg|jpeg|png|gif|svg)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 10000 // 10Kb &#125; &#125; &#125; ] &#125;, plugins: [ new VueLoaderPlugin() ]&#125;; webpack.client.config.js 1234567891011121314151617const path = require('path');const merge = require('webpack-merge');const HtmlWebpackPlugin = require('html-webpack-plugin');const base = require('./webpack.base.config');module.exports = merge(base, &#123; entry: &#123; client: path.resolve(__dirname, '../src/entry-client.js') &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, '../src/index.html'), filename: 'index.html' &#125;) ]&#125;); 注意，这里的入口文件变成了entry-client.js，将其打包出的client.bundle.js插入到index.html中。 webpack.server.config.js 123456789101112131415161718192021222324const path = require('path');const merge = require('webpack-merge');const HtmlWebpackPlugin = require('html-webpack-plugin');const base = require('./webpack.base.config');module.exports = merge(base, &#123; target: 'node', entry: &#123; server: path.resolve(__dirname, '../src/entry-server.js') &#125;, output: &#123; libraryTarget: 'commonjs2' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, '../src/index.ssr.html'), filename: 'index.ssr.html', files: &#123; js: 'client.bundle.js' &#125;, excludeChunks: ['server'] &#125;) ]&#125;); 这里有几个点需要注意一下： 入口文件是 entry-server.js 因为是打包服务器端依赖的代码，所以target要设为node，同时，output的libraryTarget要设为commonjs2 这里关于HtmlWebpackPlugin配置的意思是，不要在index.ssr.html中引入打包出的server.bundle.js，要引为浏览器打包的client.bundle.js，原因前面说过了，是为了让Vue可以将服务器吐出来的html进行激活，从而接管后续响应。 那么打包出的server.bundle.js在哪用呢？接着往下看就知道啦~~ package.json 12345678910111213141516171819202122232425262728293031323334353637383940&#123; "name": "01", "version": "1.0.0", "main": "index.js", "license": "MIT", "scripts": &#123; "start": "yarn run dev", "dev": "webpack-dev-server", "build:client": "webpack --config config/webpack.client.config.js", "build:server": "webpack --config config/webpack.server.config.js" &#125;, "dependencies": &#123; "koa": "^2.5.3", "koa-router": "^7.4.0", "koa-static": "^5.0.0", "vue": "^2.5.17", "vue-server-renderer": "^2.5.17" &#125;, "devDependencies": &#123; "@babel/core": "^7.1.2", "@babel/preset-env": "^7.1.0", "autoprefixer": "^9.1.5", "babel-loader": "^8.0.4", "css-loader": "^1.0.0", "extract-text-webpack-plugin": "^4.0.0-beta.0", "file-loader": "^2.0.0", "html-webpack-plugin": "^3.2.0", "postcss": "^7.0.5", "postcss-loader": "^3.0.0", "style-loader": "^0.23.0", "url-loader": "^1.1.1", "vue-loader": "^15.4.2", "vue-style-loader": "^4.1.2", "vue-template-compiler": "^2.5.17", "webpack": "^4.20.2", "webpack-cli": "^3.1.2", "webpack-dev-server": "^3.1.9", "webpack-merge": "^4.1.4" &#125;&#125; 接下来我们看server端关于http服务的代码： server/server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const Koa = require('koa');const Router = require('koa-router');const serve = require('koa-static');const path = require('path');const fs = require('fs');const backendApp = new Koa();const frontendApp = new Koa();const backendRouter = new Router();const frontendRouter = new Router();const bundle = fs.readFileSync(path.resolve(__dirname, '../dist/server.js'), 'utf-8');const renderer = require('vue-server-renderer').createBundleRenderer(bundle, &#123; template: fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8')&#125;);// 后端ServerbackendRouter.get('/index', (ctx, next) =&gt; &#123; // 这里用 renderToString 的 promise 返回的 html 有问题，没有样式 renderer.renderToString((err, html) =&gt; &#123; if (err) &#123; console.error(err); ctx.status = 500; ctx.body = '服务器内部错误'; &#125; else &#123; console.log(html); ctx.status = 200; ctx.body = html; &#125; &#125;);&#125;);backendApp.use(serve(path.resolve(__dirname, '../dist')));backendApp .use(backendRouter.routes()) .use(backendRouter.allowedMethods());backendApp.listen(3000, () =&gt; &#123; console.log('服务器端渲染地址： http://localhost:3000');&#125;);// 前端ServerfrontendRouter.get('/index', (ctx, next) =&gt; &#123; let html = fs.readFileSync(path.resolve(__dirname, '../dist/index.html'), 'utf-8'); ctx.type = 'html'; ctx.status = 200; ctx.body = html;&#125;);frontendApp.use(serve(path.resolve(__dirname, '../dist')));frontendApp .use(frontendRouter.routes()) .use(frontendRouter.allowedMethods());frontendApp.listen(3001, () =&gt; &#123; console.log('浏览器端渲染地址： http://localhost:3001');&#125;); 这里对两个端口进行监听，3000端口是服务端渲染，3001端口是直接输出index.html，然后会在浏览器端走Vue的那一套，主要是为了和服务端渲染做对比使用。 这里的关键代码是如何在服务端去输出html字符串。 1234const bundle = fs.readFileSync(path.resolve(__dirname, '../dist/server.bundle.js'), 'utf-8');const renderer = require('vue-server-renderer').createBundleRenderer(bundle, &#123; template: fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8')&#125;); 可以看到，server.bundle.js在这里被使用啦，因为它的入口是一个函数，接收context作为参数（非必传），输出一个根组件app。 这里我们用到了vue-server-renderer插件，它有两个方法可以做渲染，一个是createRenderer，另一个是createBundleRenderer。 12const &#123; createRenderer &#125; = require('vue-server-renderer')const renderer = createRenderer(&#123; /* 选项 */ &#125;) 12const &#123; createBundleRenderer &#125; = require('vue-server-renderer')const renderer = createBundleRenderer(serverBundle, &#123; /* 选项 */ &#125;) createRenderer无法接收为服务端打包出的server.bundle.js文件，所以这里只能用createBundleRenderer。 serverBundle 参数可以是以下之一： 绝对路径，指向一个已经构建好的 bundle 文件（.js 或 .json）。必须以 / 开头才会被识别为文件路径。 由 webpack + vue-server-renderer/server-plugin 生成的 bundle 对象。 JavaScript 代码字符串（不推荐）。 这里我们引入的是.js文件，后续会介绍如何使用.json文件以及有什么好处。 1234567891011renderer.renderToString((err, html) =&gt; &#123; if (err) &#123; console.error(err); ctx.status = 500; ctx.body = '服务器内部错误'; &#125; else &#123; console.log(html); ctx.status = 200; ctx.body = html; &#125;&#125;); 使用createRenderer和createBundleRenderer返回的renderer函数包含两个方法renderToString和renderToStream，我们这里用的是renderToString成功后直接返回一个完整的字符串，renderToStream返回的是一个Node流。 renderToString支持Promise，但是我在使用Prmoise形式的时候样式会渲染不出来，暂时还不知道原因，如果大家知道的话可以给我留言啊。 配置基本就完成了，来看一下如何运行。 1234yarn run build:client // 打包浏览器端需要bundleyarn run build:server // 打包SSR需要bundleyarn start // 其实就是 node server/server.js，提供http服务 最终效果展示： 访问http://localhost:3000/index 我们看到了前面提过的data-server-rendered=”true”属性，同时会加载client.bundle.js文件，为了让Vue在浏览器端做后续接管。 访问http://localhost:3001/index还和第一步实现的效果一样，纯浏览器渲染，这里就不放截图了。 完整代码查看github 3. 服务端渲染，包含Ajax初始化数据如果SSR需要初始化一些异步数据，那么流程就会变得复杂一些。 我们先提出几个问题： 服务端拿异步数据的步骤在哪做？ 如何确定哪些组件需要获取异步数据？ 获取到异步数据之后要如何塞回到组件内？ 带着问题我们向下走，希望看完这篇文章的时候上面的问题你都找到了答案。 服务器端渲染和浏览器端渲染组件经过的生命周期是有区别的，在服务器端，只会经历beforeCreate和created两个生命周期。因为SSR服务器直接吐出html字符串就好了，不会渲染DOM结构，所以不存在beforeMount和mounted的，也不会对其进行更新，所以也就不存在beforeUpdate和updated等。 我们先来想一下，在纯浏览器渲染的Vue项目中，我们是怎么获取异步数据并渲染到组件中的？一般是在created或者mounted生命周期里发起异步请求，然后在成功回调里执行this.data = xxx，Vue监听到数据发生改变，走后面的Dom Diff，打patch，做DOM更新。 那么服务端渲染可不可以也这么做呢？答案是不行的。 在mounted里肯定不行，因为SSR都没有mounted生命周期，所以在这里肯定不行。 在beforeCreate里发起异步请求是否可以呢，也是不行的。因为请求是异步的，可能还没有等接口返回，服务端就已经把html字符串拼接出来了。 所以，参考一下官方文档，我们可以得到以下思路： 在渲染前，要预先获取所有需要的异步数据，然后存到Vuex的store中。 在后端渲染时，通过Vuex将获取到的数据注入到相应组件中。 把store中的数据设置到window.INITIAL_STATE属性中。 在浏览器环境中，通过Vuex将window.INITIAL_STATE里面的数据注入到相应组件中。 正常情况下，通过这几个步骤，服务端吐出来的html字符串相应组件的数据都是最新的，所以第4步并不会引起DOM更新，但如果出了某些问题，吐出来的html字符串没有相应数据，Vue也可以在浏览器端通过Vuex注入数据，进行DOM更新。 更新后的目录结构： 目录结构12345678910111213141516171819202122- node_modules- config - webpack.base.config.js - webpack.client.config.js - webpack.server.config.js- src - components - Bar.vue - Foo.vue - store // 新增 store.js - App.vue - app.js - entry-client.js - entry-server.js - index.html - index.ssr.html- package.json- yarn.lock- postcss.config.js- .babelrc- .gitignore 先来看一下store.js: store/store.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const fetchBar = function() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('bar 组件返回 ajax 数据'); &#125;, 1000); &#125;);&#125;;function createStore() &#123; const store = new Vuex.Store(&#123; state: &#123; bar: '' &#125;, mutations: &#123; 'SET_BAR'(state, data) &#123; state.bar = data; &#125; &#125;, actions: &#123; fetchBar(&#123; commit &#125;) &#123; return fetchBar().then((data) =&gt; &#123; commit('SET_BAR', data); &#125;).catch((err) =&gt; &#123; console.error(err); &#125;) &#125; &#125; &#125;); if (typeof window !== 'undefined' &amp;&amp; window.__INITIAL_STATE__) &#123; console.log('window.__INITIAL_STATE__', window.__INITIAL_STATE__); store.replaceState(window.__INITIAL_STATE__); &#125; return store;&#125;export default createStore;typeof window 如果不太了解Vuex，可以去Vuex官网先看一些基本概念。 这里fetchBar可以看成是一个异步请求，这里用setTimeout模拟。在成功回调中commit相应的mutation进行状态修改。 这里有一段关键代码： 1234if (typeof window !== 'undefined' &amp;&amp; window.__INITIAL_STATE__) &#123; console.log('window.__INITIAL_STATE__', window.__INITIAL_STATE__); store.replaceState(window.__INITIAL_STATE__);&#125; 因为store.js同样也会被打包到服务器运行的server.bundle.js中，所以运行环境不一定是浏览器，这里需要对window做判断，防止报错，同时如果有window.INITIAL_STATE属性，说明服务器已经把所有初始化需要的异步数据都获取完成了，要对store中的状态做一个替换，保证统一。 components/Bar.vue 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class="bar"&gt; &lt;h1 @click="onHandleClick"&gt;Bar Component&lt;/h1&gt; &lt;h2&gt;异步Ajax数据：&lt;/h2&gt; &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const fetchInitialData = (&#123; store &#125;) =&gt; &#123; store.dispatch('fetchBar'); &#125;; export default &#123; asyncData: fetchInitialData, methods: &#123; onHandleClick() &#123; alert('bar'); &#125; &#125;, mounted() &#123; // 因为服务端渲染只有 beforeCreate 和 created 两个生命周期，不会走这里 // 所以把调用 Ajax 初始化数据也写在这里，是为了供单独浏览器渲染使用 let store = this.$store; fetchInitialData(&#123; store &#125;); &#125;, computed: &#123; msg() &#123; return this.$store.state.bar; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.bar &#123; background: bisque;&#125;&lt;/style&gt; 这里在Bar组件的默认导出对象中增加了一个方法asyncData，在该方法中会dispatch相应的action，进行异步数据获取。 需要注意的是，我在mounted中也写了获取数据的代码，这是为什么呢？ 因为想要做到同构，代码单独在浏览器端运行，也应该是没有问题的，又由于服务器没有mounted生命周期，所以我写在这里就可以解决单独在浏览器环境使用也可以发起同样的异步请求去初始化数据。 components/Foo.vue 123456789101112131415161718192021&lt;template&gt; &lt;div class="foo"&gt; &lt;h1 @click="onHandleClick"&gt;Foo Component&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; onHandleClick() &#123; alert('foo'); &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;.foo &#123; background: yellowgreen;&#125;&lt;/style&gt; 这里我对两个组件都添加了一个点击事件，为的是证明在服务器吐出首页html后，后续的步骤都会被浏览器端的Vue接管，可以正常执行后面的操作。 app.js 1234567891011121314import Vue from 'vue';import createStore from './store/store.js';import App from './App.vue';export function createApp() &#123; const store = createStore(); const app = new Vue(&#123; store, render: h =&gt; h(App) &#125;); return &#123; app, store, App &#125;;&#125; 在建立根组件的时候，要把Vuex的store传进去，同时要返回，后续会用到。 最后来看一下entry-server.js，关键步骤在这里： entry-server.js 12345678910111213141516171819202122232425262728import &#123; createApp &#125; from './app.js';export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const &#123; app, store, App &#125; = createApp(); let components = App.components; let asyncDataPromiseFns = []; Object.values(components).forEach(component =&gt; &#123; if (component.asyncData) &#123; asyncDataPromiseFns.push(component.asyncData(&#123; store &#125;)); &#125; &#125;); Promise.all(asyncDataPromiseFns).then((result) =&gt; &#123; // 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中 context.state = store.state; console.log(222); console.log(store.state); console.log(context.state); console.log(context); resolve(app); &#125;, reject); &#125;);&#125; 我们通过导出的App拿到了所有它下面的components，然后遍历，找出哪些component有asyncData方法，有的话调用并传入store，该方法会返回一个Promise，我们使用Promise.all等所有的异步方法都成功返回，才resolve(app)。 context.state = store.state作用是，当使用createBundleRenderer时，如果设置了template选项，那么会把context.state的值作为window.INITIAL_STATE自动插入到模板html中。 这里需要大家多思考一下，弄清楚整个服务端渲染的逻辑。 如何运行： 1234yarn run build:clientyarn run build:serveryarn start 最终效果截图： 服务端渲染：打开http://localhost:3000/index 可以看到window.INITIAL_STATE被自动插入了。 我们来对比一下SSR到底对加载性能有什么影响吧。 服务端渲染时performance截图： 纯浏览器端渲染时performance截图： 同样都是在fast 3G网络模式下，纯浏览器端渲染首屏加载花费时间2.9s，因为client.js加载就花费了2.27s，因为没有client.js就没有Vue，也就没有后面的东西了。 服务端渲染首屏时间花费0.8s，虽然client.js加载扔花费2.27s，但是首屏已经不需要它了，它是为了让Vue在浏览器端进行后续接管。 从这我们可以真正的看到，服务端渲染对于提升首屏的响应速度是很有作用的。 当然有的同学可能会问，在服务端渲染获取初始ajax数据时，我们还延时了1s，在这个时间用户也是看不到页面的。没错，接口的时间我们无法避免，就算是纯浏览器渲染，首页该调接口还是得调，如果接口响应慢，那么纯浏览器渲染看到完整页面的时间会更慢。 完整代码查看github 4. 使用serverBundle和clientManifest进行优化前面我们创建服务端renderer的方法是： 1234const bundle = fs.readFileSync(path.resolve(__dirname, '../dist/server.js'), 'utf-8');const renderer = require('vue-server-renderer').createBundleRenderer(bundle, &#123; template: fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8')&#125;); serverBundle我们用的是打包出的server.bundle.js文件。这样做的话，在每次编辑过应用程序源代码之后，都必须停止并重启服务。这在开发过程中会影响开发效率。此外，Node.js 本身不支持 source map。 vue-server-renderer 提供一个名为 createBundleRenderer 的 API，用于处理此问题，通过使用 webpack 的自定义插件，server bundle 将生成为可传递到 bundle renderer 的特殊 JSON 文件。所创建的 bundle renderer，用法和普通 renderer 相同，但是 bundle renderer 提供以下优点： 内置的 source map 支持（在 webpack 配置中使用 devtool: ‘source-map’） 在开发环境甚至部署过程中热重载（通过读取更新后的 bundle，然后重新创建 renderer 实例） 关键 CSS(critical CSS) 注入（在使用 *.vue 文件时）：自动内联在渲染过程中用到的组件所需的CSS。更多细节请查看 CSS 章节。 使用 clientManifest 进行资源注入：自动推断出最佳的预加载(preload)和预取(prefetch)指令，以及初始渲染所需的代码分割 chunk。 preload和prefetch有不了解的话可以自行查一下它们的作用哈。 那么我们来修改webpack配置： webpack.client.config.js 12345678910111213141516171819const path = require('path');const merge = require('webpack-merge');const HtmlWebpackPlugin = require('html-webpack-plugin');const VueSSRClientPlugin = require('vue-server-renderer/client-plugin');const base = require('./webpack.base.config');module.exports = merge(base, &#123; entry: &#123; client: path.resolve(__dirname, '../src/entry-client.js') &#125;, plugins: [ new VueSSRClientPlugin(), // 新增 new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, '../src/index.html'), filename: 'index.html' &#125;) ]&#125;); webpack.server.config.js 123456789101112131415161718192021222324252627282930const path = require('path');const merge = require('webpack-merge');const nodeExternals = require('webpack-node-externals');const HtmlWebpackPlugin = require('html-webpack-plugin');const VueSSRServerPlugin = require('vue-server-renderer/server-plugin');const base = require('./webpack.base.config');module.exports = merge(base, &#123; target: 'node', // 对 bundle renderer 提供 source map 支持 devtool: '#source-map', entry: &#123; server: path.resolve(__dirname, '../src/entry-server.js') &#125;, externals: [nodeExternals()], // 新增 output: &#123; libraryTarget: 'commonjs2' &#125;, plugins: [ new VueSSRServerPlugin(), // 这个要放到第一个写，否则 CopyWebpackPlugin 不起作用，原因还没查清楚 new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, '../src/index.ssr.html'), filename: 'index.ssr.html', files: &#123; js: 'client.bundle.js' &#125;, excludeChunks: ['server'] &#125;) ]&#125;); 因为是服务端引用模块，所以不需要打包node_modules中的依赖，直接在代码中require引用就好，所以配置externals: [nodeExternals()]。 两个配置文件会分别生成vue-ssr-client-manifest.json和vue-ssr-server-bundle.json。作为createBundleRenderer的参数。 来看server.js server.js 123456789const serverBundle = require(path.resolve(__dirname, '../dist/vue-ssr-server-bundle.json'));const clientManifest = require(path.resolve(__dirname, '../dist/vue-ssr-client-manifest.json'));const template = fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8');const renderer = createBundleRenderer(serverBundle, &#123; runInNewContext: false, template: template, clientManifest: clientManifest&#125;); 效果和第三步就是一样的啦，就不截图了，完整代码查看github。 5. 配置一个完整的基于Vue + VueRouter + Vuex的SSR这里和第四步不一样的是引入了vue-router，更接近于实际开发项目。 在src下新增router目录。 router/index.js 123456789101112131415161718192021222324252627import Vue from 'vue';import Router from 'vue-router';import Bar from '../components/Bar.vue';Vue.use(Router);function createRouter() &#123; const routes = [ &#123; path: '/bar', component: Bar &#125;, &#123; path: '/foo', component: () =&gt; import('../components/Foo.vue') // 异步路由 &#125; ]; const router = new Router(&#123; mode: 'history', routes &#125;); return router;&#125;export default createRouter; 这里我们把Foo组件作为一个异步组件引入，做成按需加载。 在app.js中引入router，并导出： app.js 1234567891011121314151617import Vue from 'vue';import createStore from './store/store.js';import createRouter from './router';import App from './App.vue';export function createApp() &#123; const store = createStore(); const router = createRouter(); const app = new Vue(&#123; router, store, render: h =&gt; h(App) &#125;); return &#123; app, store, router, App &#125;;&#125; 修改App.vue引入路由组件： App.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="app"&gt; &lt;router-link to="/bar"&gt;Goto Bar&lt;/router-link&gt; &lt;router-link to="/foo"&gt;Goto Foo&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; beforeCreate() &#123; console.log('App.vue beforeCreate'); &#125;, created() &#123; console.log('App.vue created'); &#125;, beforeMount() &#123; console.log('App.vue beforeMount'); &#125;, mounted() &#123; console.log('App.vue mounted'); &#125;&#125;&lt;/script&gt; 最重要的修改在entry-server.js中， entry-server.js 1234567891011121314151617181920212223242526272829303132import &#123; createApp &#125; from './app.js';export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const &#123; app, store, router, App &#125; = createApp(); router.push(context.url); router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents(); console.log(context.url) console.log(matchedComponents) if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;); &#125; Promise.all(matchedComponents.map(component =&gt; &#123; if (component.asyncData) &#123; return component.asyncData(&#123; store &#125;); &#125; &#125;)).then(() =&gt; &#123; // 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中 context.state = store.state; // 返回根组件 resolve(app); &#125;); &#125;, reject); &#125;);&#125; 这里前面提到的context就起了大作用，它将用户访问的url地址传进来，供vue-router使用。因为有异步组件，所以在router.onReady的成功回调中，去找该url路由所匹配到的组件，获取异步数据那一套还和前面的一样。 于是，我们就完成了一个基本完整的基于Vue + VueRouter + VuexSSR配置，完成代码查看github。 最终效果演示： 访问http://localhost:3000/bar： 完整代码查看github 后续上面我们通过五个步骤，完成了从纯浏览器渲染到完整服务端渲染的同构，代码既可以运行在浏览器端，也可以运行在服务器端。那么，回过头来我们在看一下是否有优化的空间，又或者有哪些扩展的思考。 1. 优化 我们目前是使用renderToString方法，完全生成html后，才会向客户端返回，如果使用renderToStream，应用bigpipe技术可以向浏览器持续不断的返回一个流，那么文件的加载浏览器可以尽早的显示一些东西出来。1const stream = renderer.renderToStream(context) 返回的值是 Node.js stream：12345678910111213let html = ''stream.on('data', data =&gt; &#123; html += data.toString()&#125;)stream.on('end', () =&gt; &#123; console.log(html) // 渲染完成&#125;)stream.on('error', err =&gt; &#123; // handle error...&#125;) 在流式渲染模式下，当 renderer 遍历虚拟 DOM 树(virtual DOM tree)时，会尽快发送数据。这意味着我们可以尽快获得”第一个 chunk”，并开始更快地将其发送给客户端。 然而，当第一个数据 chunk 被发出时，子组件甚至可能不被实例化，它们的生命周期钩子也不会被调用。这意味着，如果子组件需要在其生命周期钩子函数中，将数据附加到渲染上下文(render context)，当流(stream)启动时，这些数据将不可用。这是因为，大量上下文信息(context information)（如头信息(head information)或内联关键 CSS(inline critical CSS)）需要在应用程序标记(markup)之前出现，我们基本上必须等待流(stream)完成后，才能开始使用这些上下文数据。 因此，如果你依赖由组件生命周期钩子函数填充的上下文数据，则不建议使用流式传输模式。 webpack优化 webpack优化又是一个大的话题了，这里不展开讨论，感兴趣的同学可以自行查找一些资料，后续我也可能会专门写一篇文章来讲webpack优化。 2. 思考 是否必须使用vuex？ 答案是不用。Vuex只是为了帮助你实现一套数据存储、更新、获取的机制，入股你不用Vuex，那么你就必须自己想一套方案可以将异步获取到的数据存起来，并且在适当的时机将它注入到组件内，有一些文章提出了一些方案，我会放到参考文章里，大家可以阅读一下。 是否使用SSR就一定好？ 这个也是不一定的，任何技术都有使用场景。SSR可以帮助你提升首页加载速度，优化搜索引擎SEO，但同时由于它需要在node中渲染整套Vue的模板，会占用服务器负载，同时只会执行beforeCreate和created两个生命周期，对于一些外部扩展库需要做一定处理才可以在SSR中运行等等。 结语本文通过五个步骤，从纯浏览器端渲染开始，到配置一个完整的基于Vue + vue-router + Vuex的SSR环境，介绍了很多新的概念，也许你看完一遍不太理解，那么结合着源码，去自己手敲几遍，然后再来看几遍文章，相信你一定可以掌握SSR。 最后，本文所有源代码都放在我的github上，如果对你有帮助的话，就来点一个赞吧~~ 参考链接 https://ssr.vuejs.org/zh/ https://zhuanlan.zhihu.com/p/35871344 http://www.cnblogs.com/qingmingsang/articles/8719679.html https://juejin.im/entry/590ca74b2f301e006c10465f https://github.com/youngwind/blog/issues/112]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
        <tag>Vue Router</tag>
        <tag>Vue SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0到1实现Promise]]></title>
    <url>%2F2018%2F09%2F28%2Fjavascript_promise%2F</url>
    <content type="text"><![CDATA[前言Promise大家一定都不陌生了，JavaScript异步流程从最初的Callback，到Promise，到Generator，再到目前使用最多的Async/Await（如果对于这些不熟悉的可以参考我另一篇文章《JavaScript异步编程》），这不仅仅是技术实现的发展，更是思想上对于如何控制异步的递进。Promise作为后续方案的基础，是重中之重，也是面试时候最常被问到的。 今天我们就一起从0到1实现一个基于A+规范的Promise，过程中也会对Promise的异常处理，以及是否可手动终止做一些讨论，最后会对我们实现的Promise做单元测试。完整的代码已经上传到github，想直接看代码的可以点这里。 虽然已经有很多带你实现Promise类的文章了，但每个人理解的程度不一样，也许不同的文章可以带给你不同的思考呢，那我们就开始吧。 正文1. 基础框架new Promise()时接收一个executor函数作为参数，该函数会立即执行，函数中有两个参数，它们也是函数，分别是resolve和reject，函数同步执行一定要放在try…catch中，否则无法进行错误捕获。 MyPromise.js 123456789101112131415161718function MyPromise(executor) &#123; function resolve(value) &#123; &#125; function reject(reason) &#123; &#125; try &#123; executor(resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125;&#125;module.exports = MyPromise; resolve()接收Promise成功值value，reject接收Promise失败原因reason。 test.js 12345let MyPromise = require('./MyPromise.js');let promise = new MyPromise(function(resolve, reject) &#123; resolve(123);&#125;) 2. 添加状态机目前实现存在的问题： Promise是一个状态机的机制，初始状态为 pending，成功状态为 fulfilled，失败状态为 rejected。只能从 pending -&gt; fulfilled，或者从 pending -&gt; rejected，并且状态一旦转变，就永远不会再变了。 所以，我们需要为Promise添加一个状态流转的机制。 MyPromise.js 1234567891011121314151617181920212223242526272829const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';function MyPromise(executor) &#123; let self = this; self.state = PENDING; function resolve(value) &#123; if (self.state === PENDING) &#123; self.state = FULFILLED; &#125; &#125; function reject(reason) &#123; if (self.state === PENDING) &#123; self.state = REJECTED; &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125;&#125;module.exports = MyPromise; test.js 1234567891011let MyPromise = require('./MyPromise.js');let promise = new MyPromise(function(resolve, reject) &#123; resolve(123);&#125;);promise.then(function(value) &#123; console.log('value', value);&#125;, function(reason) &#123; console.log('reason', reason);&#125;) 3. 添加then方法Promise拥有一个then方法，接收两个函数 onFulfilled 和 onRejected，分别作为Promise成功和失败的回调。所以，在then方法中我们需要对状态state进行判断，如果是fulfilled，则执行onFulfilled(value)方法，如果是rejected，则执行onRejected(reason)方法。 由于成功值value和失败原因reason是由用户在executor中通过resolve(value) 和 reject(reason)传入的，所以我们需要有一个全局的value和reason供后续方法获取。 MyPromise.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';function MyPromise(executor) &#123; let self = this; self.state = PENDING; self.value = null; self.reason = null; function resolve(value) &#123; if (self.state === PENDING) &#123; self.state = FULFILLED; self.value = value; &#125; &#125; function reject(reason) &#123; if (self.state === PENDING) &#123; self.state = REJECTED; self.reason = reason; &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125;&#125;MyPromise.prototype.then = function(onFuifilled, onRejected) &#123; let self = this; if (self.state === FULFILLED) &#123; onFuifilled(self.value); &#125; if (self.state === REJECTED) &#123; onRejected(self.reason); &#125;&#125;;module.exports = MyPromise; 4. 实现异步调用resolve目前实现存在的问题： 同步调用resolve()没有问题，但如果是异步调用，比如放到setTimeout中，因为目前的代码在调用then()方法时，state仍是pending状态，当timer到时候调用resolve()把state修改为fulfilled状态，但是onFulfilled()函数已经没有时机调用了。 针对上述问题，进行如下修改： MyPromise.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';function MyPromise(executor) &#123; let self = this; self.state = PENDING; self.value = null; self.reason = null; self.onFulfilledCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.state === PENDING) &#123; self.state = FULFILLED; self.value = value; self.onFulfilledCallbacks.forEach(function(fulfilledCallback) &#123; fulfilledCallback(); &#125;); &#125; &#125; function reject(reason) &#123; if (self.state === PENDING) &#123; self.state = REJECTED; self.reason = reason; self.onRejectedCallbacks.forEach(function(rejectedCallback) &#123; rejectedCallback(); &#125;); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125;&#125;MyPromise.prototype.then = function(onFuifilled, onRejected) &#123; let self = this; if (self.state === PENDING) &#123; self.onFulfilledCallbacks.push(() =&gt; &#123; onFuifilled(self.value); &#125;); self.onRejectedCallbacks.push(() =&gt; &#123; onRejected(self.reason); &#125;); &#125; if (self.state === FULFILLED) &#123; onFuifilled(self.value); &#125; if (self.state === REJECTED) &#123; onRejected(self.reason); &#125;&#125;;module.exports = MyPromise; 我们添加了两个回调函数数组onFulfilledCallbacks和onRejectedCallbacks，用来存储then()方法中传入的成功和失败回调。然后，当用户调用resolve()或reject()的时候，修改state状态，并从相应的回调数组中依次取出回调函数执行。 同时，通过这种方式我们也实现了可以注册多个then()函数，并且在成功或者失败时按照注册顺序依次执行。 test.js 12345678910111213141516171819let MyPromise = require('./MyPromise.js');let promise = new MyPromise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(123); &#125;, 1000);&#125;);promise.then(function(value) &#123; console.log('value1', value);&#125;, function(reason) &#123; console.log('reason1', reason);&#125;);promise.then(function(value) &#123; console.log('value2', value);&#125;, function(reason) &#123; console.log('reason2', reason);&#125;); 5. then返回的仍是Promise读过PromiseA+规范的同学肯定知道，then()方法返回的仍是一个Promise，并且返回Promise的resolve的值是上一个Promise的onFulfilled()函数或onRejected()函数的返回值。如果在上一个Promise的then()方法回调函数的执行过程中发生了错误，那么会将其捕获到，并作为返回的Promise的onRejected函数的参数传入。比如： 1234567891011121314let promise = new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;);promise.then((value) =&gt; &#123; console.log('value1', value); return 456;&#125;).then((value) =&gt; &#123; console.log('value2', value);&#125;);let promise = new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;); 打印结果为： value1 123value2 456 12345678910111213let promise = new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;);promise.then((value) =&gt; &#123; console.log('value1', value); a.b = 2; // 这里存在语法错误 return 456;&#125;).then((value) =&gt; &#123; console.log('value2', value);&#125;, (reason) =&gt; &#123; console.log('reason2', reason);&#125;); 打印结果为： value1 123reason2 ReferenceError: a is not defined 可以看到，then()方法回调函数如果发生错误，会被捕获到，那么then()返回的Promise会自动变为onRejected，执行onRejected()回调函数。 123456789101112131415let promise = new Promise((resolve, reject) =&gt; &#123; reject(123);&#125;);promise.then((value) =&gt; &#123; console.log('value1', value); return 456;&#125;, (reason) =&gt; &#123; console.log('reason1', reason); return 456;&#125;).then((value) =&gt; &#123; console.log('value2', value);&#125;, (reason) =&gt; &#123; console.log('reason2', reason);&#125;); 打印结果为： reason1 123value2 456 好啦，接下来我们就去实现then()方法依然返回一个Promise。 MyPromise.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445MyPromise.prototype.then = function(onFuifilled, onRejected) &#123; let self = this; let promise2 = null; promise2 = new MyPromise((resolve, reject) =&gt; &#123; if (self.state === PENDING) &#123; self.onFulfilledCallbacks.push(() =&gt; &#123; try &#123; let x = onFuifilled(self.value); self.resolvePromise(promise2, x, resolve, reject); &#125; catch(reason) &#123; reject(reason); &#125; &#125;); self.onRejectedCallbacks.push(() =&gt; &#123; try &#123; let x = onRejected(self.reason); self.resolvePromise(promise2, x, resolve, reject); &#125; catch(reason) &#123; reject(reason); &#125; &#125;); &#125; if (self.state === FULFILLED) &#123; try &#123; let x = onFuifilled(self.value); self.resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125; if (self.state === REJECTED) &#123; try &#123; let x = onRejected(self.reason); self.resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125; &#125;); return promise2;&#125;; 可以看到，我们新增了一个promise2作为then()方法的返回值。通过let x = onFuifilled(self.value) 或者 let x = onRejected(self.reason)拿到then()方法回调函数的返回值，然后调用self.resolvePromise(promise2, x, resolve, reject)，将新增的promise2、x、promise2的resolve和reject传入到resolvePromise()中。 所以，下面我们重点看一下resolvePromise()方法。 MyPromise.js 12345678910111213141516171819202122232425262728293031323334353637383940MyPromise.prototype.resolvePromise = function(promise2, x, resolve, reject) &#123; let self = this; let called = false; // called 防止多次调用 if (promise2 === x) &#123; return reject(new TypeError('循环引用')); &#125; if (x !== null &amp;&amp; (Object.prototype.toString.call(x) === '[object Object]' || Object.prototype.toString.call(x) === '[object Function]')) &#123; // x是对象或者函数 try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, (y) =&gt; &#123; // 别人的Promise的then方法可能设置了getter等，使用called防止多次调用then方法 if (called) return ; called = true; // 成功值y有可能还是promise或者是具有then方法等，再次resolvePromise，直到成功值为基本类型或者非thenable self.resolvePromise(promise2, y, resolve, reject); &#125;, (reason) =&gt; &#123; if (called) return ; called = true; reject(reason); &#125;); &#125; else &#123; if (called) return ; called = true; resolve(x); &#125; &#125; catch (reason) &#123; if (called) return ; called = true; reject(reason); &#125; &#125; else &#123; // x是普通值，直接resolve resolve(x); &#125;&#125;; resolvePromise()是用来解析then()回调函数中返回的仍是一个Promise，这个Promise有可能是我们自己的，有可能是别的库实现的，也有可能是一个具有then()方法的对象，所以这里靠resolvePromise()来实现统一处理。 下面是翻译自PromiseA+规范关于resolvePromise()的要求： Promise 解决过程 Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [Resolve]，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。 运行 [Resolve] 需遵循以下步骤： x 与 promise 相等如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise x 为 Promise如果 x 为 Promise ，则使 promise 接受 x 的状态: 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise x 为对象或函数如果 x 为对象或者函数： 把 x.then 赋值给 then 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [Resolve] 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用 then 方法抛出了异常 e： 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [Resolve] 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。 参考上述规范，结合代码中的注释，相信大家可以理解resolvePromise()的作用了。 测试： test.js 123456789101112131415161718192021222324let MyPromise = require('./MyPromise.js');let promise = new MyPromise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(123); &#125;, 1000);&#125;);promise.then((value) =&gt; &#123; console.log('value1', value); return new MyPromise((resolve, reject) =&gt; &#123; resolve(456); &#125;).then((value) =&gt; &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(789); &#125;) &#125;);&#125;, (reason) =&gt; &#123; console.log('reason1', reason);&#125;).then((value) =&gt; &#123; console.log('value2', value);&#125;, (reason) =&gt; &#123; console.log('reason2', reason);&#125;); 打印结果： value1 123value2 789 6. 让then()方法的回调函数总是异步调用官方Promise实现的回调函数总是异步调用的： 12345678910111213console.log('start');let promise = new Promise((resolve, reject) =&gt; &#123; console.log('step-'); resolve(123);&#125;);promise.then((value) =&gt; &#123; console.log('step--'); console.log('value', value);&#125;);console.log('end'); 打印结果： startstep-endstep–value1 123 Promise属于微任务，这里我们为了方便用宏任务setTiemout来代替实现异步，具体关于宏任务、微任务以及Event Loop可以参考我的另一篇文章带你彻底弄懂Event Loop。 MyPromise.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MyPromise.prototype.then = function(onFuifilled, onRejected) &#123; let self = this; let promise2 = null; promise2 = new MyPromise((resolve, reject) =&gt; &#123; if (self.state === PENDING) &#123; self.onFulfilledCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFuifilled(self.value); self.resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;, 0); &#125;); self.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); self.resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;, 0); &#125;); &#125; if (self.state === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFuifilled(self.value); self.resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;, 0); &#125; if (self.state === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); self.resolvePromise(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;, 0); &#125; &#125;); return promise2;&#125;; 测试： test.js 1234567891011121314151617let MyPromise = require('./MyPromise.js');console.log('start');let promise = new MyPromise((resolve, reject) =&gt; &#123; console.log('step-'); setTimeout(() =&gt; &#123; resolve(123); &#125;, 1000);&#125;);promise.then((value) =&gt; &#123; console.log('step--'); console.log('value', value);&#125;);console.log('end'); 打印结果： startstep-endstep–value1 123 经过以上步骤，一个最基本的Promise就已经实现完了，下面我们会实现一些不在PromiseA+规范的扩展方法。 7. 实现catch()方法then()方法的onFulfilled和onRejected回调函数都不是必传项，如果不传，那么我们就无法接收reject(reason)中的错误，这时我们可以通过链式调用catch()方法用来接收错误。举例： 123456789let promise = new Promise((resolve, reject) =&gt; &#123; reject('has error');&#125;);promise.then((value) =&gt; &#123; console.log('value', value);&#125;).catch((reason) =&gt; &#123; console.log('reason', reason);&#125;); 打印结果： reason has error 不仅如此，catch()可以作为Promise链式调用的最后一步，前面Promise发生的错误会冒泡到最后一个catch()中，从而捕获异常。举例： 1234567891011121314151617let promise = new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;);promise.then((value) =&gt; &#123; console.log('value', value); return new Promise((resolve, reject) =&gt; &#123; reject('has error1'); &#125;);&#125;).then((value) =&gt; &#123; console.log('value', value); return new Promise((resolve, reject) =&gt; &#123; reject('has error2'); &#125;);&#125;).catch((reason) =&gt; &#123; console.log('reason', reason);&#125;); 打印结果： value 123reason has error1 那么catch()方法到底是如何实现的呢？ 答案就是在Promise的实现中，onFulfilled和onRejected函数是有默认值的： MyPromise.js 12345678MyPromise.prototype.then = function(onFuifilled, onRejected) &#123; onFuifilled = typeof onFuifilled === 'function' ? onFuifilled : value =&gt; &#123;return value;&#125;; onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123;throw reason&#125;;&#125;;MyPromise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125;; 可以看到，onRejected的默认值是把错误reason通过throw抛出去。由于我们对于同步代码的执行都是在try…catch中的，所以如果Promise发生了错误，如果没传onRejected，默认的函数会把错误reason抛出，然后会被promise2捕捉到，作为reject(reason)决议。 catch()实现就是调用this.then(null, onRejected)，由于promise2被reject，所以会执行onRejected回调，于是就捕捉到了第一个promise的错误。 总结来说，then()方法中不传onRejected回调，Promise内部会默认帮你写一个函数作为回调，作用就是throw抛出reject或者try…catch到的错误，然后错误reason会被promise2作为reject(reason)进行决议，于是会被下一个then()方法的onRejected回调函数调用，而catch只是写了一个特殊的then(null, onRejected)而已。 所以，我们在写Promise的链式调用的时候，在then()中可以不传onRejected回调，只需要在链式调用的最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。 举例1： 12345678910111213141516171819202122let promise = new Promise((resolve, reject) =&gt; &#123; reject(123);&#125;);promise.then((value) =&gt; &#123; // 注意，不会走这里，因为第一个promise是被reject的 console.log('value1', value); return new Promise((resolve, reject) =&gt; &#123; reject('has error1'); &#125;);&#125;).then((value) =&gt; &#123; console.log('value2', value); return new Promise((resolve, reject) =&gt; &#123; reject('has error2'); &#125;);&#125;, (reason) =&gt; &#123; // 注意，这个then有onRejected回调 console.log('reason2', reason);&#125;).catch((reason) =&gt; &#123; // 错误在上一个then就被捕获了，所以不会走到这里 console.log('reason3', reason);&#125;); 打印结果： reason2 123 举例2： 123456789101112131415161718let promise = new Promise((resolve, reject) =&gt; &#123; reject(123);&#125;);promise.then((value) =&gt; &#123; console.log('value1', value); return new Promise((resolve, reject) =&gt; &#123; reject('has error1'); &#125;);&#125;).then((value) =&gt; &#123; console.log('value2', value); return new Promise((resolve, reject) =&gt; &#123; reject('has error2'); &#125;);&#125;).catch((reason) =&gt; &#123; // 由于链条中的then都没有onRejected回调，所以会一直被冒泡到最后的catch这里 console.log('reason3', reason);&#125;); catch和then一样都是返回一个新的Promise。有的同学可能会有疑问，如果catch中的回调执行也发生错误该怎么办呢，这个我们后续在Promise异常处理中再做讨论。 打印结果： reason3 123 8. 实现finally方法finally是某些库对Promise实现的一个扩展方法，无论是resolve还是reject，都会走finally方法。 MyPromise.js 123456789MyPromise.prototype.finally = function(fn) &#123; return this.then(value =&gt; &#123; fn(); return value; &#125;, reason =&gt; &#123; fn(); throw reason; &#125;);&#125;; 9. 实现done方法done方法作为Promise链式调用的最后一步，用来向全局抛出没有被Promise内部捕获的错误，并且不再返回一个Promise。一般用来结束一个Promise链。 MyPromise.js 123456MyPromise.prototype.done = function() &#123; this.catch(reason =&gt; &#123; console.log('done', reason); throw reason; &#125;);&#125;; 10. 实现Promise.all方法Promise.all()接收一个包含多个Promise的数组，当所有Promise均为fulfilled状态时，返回一个结果数组，数组中结果的顺序和传入的Promise顺序一一对应。如果有一个Promise为rejected状态，则整个Promise.all为rejected。 MyPromise.js 123456789101112131415MyPromise.all = function(promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let result = []; promiseArr.forEach((promise, index) =&gt; &#123; promise.then((value) =&gt; &#123; result[index] = value; if (result.length === promiseArr.length) &#123; resolve(result); &#125; &#125;, reject); &#125;); &#125;);&#125;; test.js 12345678910111213141516171819202122232425262728293031let MyPromise = require('./MyPromise.js');let promise1 = new MyPromise((resolve, reject) =&gt; &#123; console.log('aaaa'); setTimeout(() =&gt; &#123; resolve(1111); console.log(1111); &#125;, 1000);&#125;);let promise2 = new MyPromise((resolve, reject) =&gt; &#123; console.log('bbbb'); setTimeout(() =&gt; &#123; reject(2222); console.log(2222); &#125;, 2000);&#125;);let promise3 = new MyPromise((resolve, reject) =&gt; &#123; console.log('cccc'); setTimeout(() =&gt; &#123; resolve(3333); console.log(3333); &#125;, 3000);&#125;);Promise.all([promise1, promise2, promise3]).then((value) =&gt; &#123; console.log('all value', value);&#125;, (reason) =&gt; &#123; console.log('all reason', reason);&#125;) 打印结果： aaaabbbbcccc11112222all reason 22223333 11. 实现Promise.race方法Promise.race()接收一个包含多个Promise的数组，当有一个Promise为fulfilled状态时，整个大的Promise为onfulfilled，并执行onFulfilled回调函数。如果有一个Promise为rejected状态，则整个Promise.race为rejected。 MyPromise.js 123456789MyPromise.race = function(promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promiseArr.forEach(promise =&gt; &#123; promise.then((value) =&gt; &#123; resolve(value); &#125;, reject); &#125;); &#125;);&#125;; test.js 12345678910111213141516171819202122232425262728293031let MyPromise = require('./MyPromise.js');let promise1 = new MyPromise((resolve, reject) =&gt; &#123; console.log('aaaa'); setTimeout(() =&gt; &#123; resolve(1111); console.log(1111); &#125;, 1000);&#125;);let promise2 = new MyPromise((resolve, reject) =&gt; &#123; console.log('bbbb'); setTimeout(() =&gt; &#123; reject(2222); console.log(2222); &#125;, 2000);&#125;);let promise3 = new MyPromise((resolve, reject) =&gt; &#123; console.log('cccc'); setTimeout(() =&gt; &#123; resolve(3333); console.log(3333); &#125;, 3000);&#125;);Promise.race([promise1, promise2, promise3]).then((value) =&gt; &#123; console.log('all value', value);&#125;, (reason) =&gt; &#123; console.log('all reason', reason);&#125;) 打印结果： aaaabbbbcccc1111all reason 111122223333 12. 实现Promise.resolve方法Promise.resolve用来生成一个fulfilled完成态的Promise，一般放在整个Promise链的开头，用来开始一个Promise链。 MyPromise.js 123456789MyPromise.resolve = function(value) &#123; let promise; promise = new MyPromise((resolve, reject) =&gt; &#123; this.prototype.resolvePromise(promise, value, resolve, reject); &#125;); return promise;&#125;; test.js 12345678910let MyPromise = require('./MyPromise.js');MyPromise.resolve(1111).then((value) =&gt; &#123; console.log('value1', value); return new MyPromise((resolve, reject) =&gt; &#123; resolve(2222); &#125;)&#125;).then((value) =&gt; &#123; console.log('value2', value);&#125;) 打印结果： value1 1111value2 2222 由于传入的value有可能是普通值，有可能是thenable，也有可能是另一个Promise，所以调用resolvePromise进行解析。 12. 实现Promise.reject方法Promise.reject用来生成一个rejected失败态的Promise。 MyPromise.js 12345MyPromise.reject = function(reason) &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125;; test.js 123456789101112let MyPromise = require('./MyPromise.js');MyPromise.reject(1111).then((value) =&gt; &#123; console.log('value1', value); return new MyPromise((resolve, reject) =&gt; &#123; resolve(2222); &#125;)&#125;).then((value) =&gt; &#123; console.log('value2', value);&#125;).catch(reason =&gt; &#123; console.log('reason', reason);&#125;); 打印结果： reason 1111 13. 实现Promise.deferred方法Promise.deferred可以用来延迟执行resolve和reject。 MyPromise.js 12345678MyPromise.deferred = function() &#123; let dfd = &#123;&#125;; dfd.promies = new MyPromise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.rfeject = reject; &#125;); return dfd;&#125;; 这样，你就可以在外部通过调用dfd.resolve()和dfd.reject()来决议该Promise。 13. 如何停止一个Promise链假设这样一个场景，我们有一个很长的Promise链式调用，这些Promise是依次依赖的关系，如果链条中的某个Promise出错了，就不需要再向下执行了，默认情况下，我们是无法实现这个需求的，因为Promise无论是then还是catch都会返回一个Promise，都会继续向下执行then或catch。举例： 123456789new Promise(function(resolve, reject) &#123; resolve(1111)&#125;).then(function(value) &#123; // "ERROR!!!"&#125;).catch() .then() .then() .catch() .then() 有没有办法让这个链式调用在ERROR!!!的后面就停掉，完全不去执行链式调用后面所有回调函数呢？ 我们自己封装一个Promise.stop方法。 MyPromise.js 123MyPromise.stop = function() &#123; return new Promise(function() &#123;&#125;);&#125;; stop中返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。 12345678910new MyPromise(function(resolve, reject) &#123; resolve(1111)&#125;).then(function(value) &#123; // "ERROR!!!" MyPromise.stop();&#125;).catch() .then() .then() .catch() .then() 但是这样会有一个缺点，就是链式调用后面的所有回调函数都无法被垃圾回收器回收。 14. 如何解决Promise链上返回的最后一个Promise出现错误看如下例子： 12345new Promise(function(resolve) &#123; resolve(42)&#125;).then(function(value) &#123; a.b = 2;&#125;); 这里a不存在，所以给a.b赋值是一个语法错误，onFulfilled回调函数是包在try…catch中执行的，错误会被catch到，但是由于后面没有then或catch了，这个错误无法被处理，就会被Promise吃掉，没有任何异常，这就是常说的Promise有可能会吃掉错误。 那么我们怎么处理这种情况呢？ 方法一 就是我们前面已经实现过的done()。 12345new Promise(function(resolve) &#123; resolve(42)&#125;).then(function(value) &#123; a.b = 2;&#125;).done(); done()方法相当于一个catch，但是却不再返回Promise了，注意done()方法中不能出现语法错误，否则又无法捕获了。 方法二 普通错误监听window的error事件可以实现捕获 123window.addEventListener('error', error =&gt; &#123; console.log(error); // 不会触发&#125;); Promise没有被onRejected()处理的错误需要监听unhandledrejection事件 123window.addEventListener('unhandledrejection', error =&gt; &#123; console.log('unhandledrejection', error); // 可以触发，而且还可以直接拿到 promise 对象&#125;); 14. 单元测试结束相关单元测试以及完整代码可以到我的github查看，如果对你有帮助的话，就来个star吧~ 参考文档PromiseA+规范]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你彻底弄懂Event Loop]]></title>
    <url>%2F2018%2F09%2F05%2Fjavascript_eventloop%2F</url>
    <content type="text"><![CDATA[前言我在学习浏览器和NodeJS的Event Loop时看了大量的文章，那些文章都写的很好，但是往往是每篇文章有那么几个关键的点，很多篇文章凑在一起综合来看，才可以对这些概念有较为深入的理解。 于是，我在看了大量文章之后，想要写这么一篇博客，不采用官方的描述，结合自己的理解以及示例代码，用最通俗的语言表达出来。希望大家可以通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。如果在文中出现书写错误的地方，欢迎大家留言一起探讨。 （PS：说到Event Loop肯定会提到Promise，我根据Promise A+规范自己实现了一个简易Promise库，源码放到Github上，大家有需要的可以当做参考，后续我也会也写一篇博客来讲Promise，如果对你有用，就请给个Star吧~） 正文Event Loop是什么event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。 浏览器的Event Loop是在html5的规范中明确定义。 NodeJS的Event Loop是基于libuv实现的。可以参考Node的官方文档以及libuv的官方文档。 libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。 宏队列和微队列宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括： setTimeout setInterval setImmediate (Node独有) requestAnimationFrame (浏览器独有) I/O UI rendering (浏览器独有) 微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括： process.nextTick (Node独有) Promise Object.observe MutationObserver （注：这里只针对浏览器和NodeJS） 浏览器的Event Loop我们先来看一张图，再看完这篇文章后，请返回来再仔细看一下这张图，相信你会有更深的理解。 这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程： 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）； 全局Script代码执行完毕后，调用栈Stack会清空； 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1； 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空； 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行； 执行完毕后，调用栈Stack为空； 重复第3-7个步骤； 重复第3-7个步骤； …… 可以看到，这就是浏览器的事件循环Event Loop 这里归纳3个重点： 宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务； 微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空； 图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。 好了，概念性的东西就这么多，来看几个示例代码，测试一下你是否掌握了: 123456789101112131415161718192021console.log(1);setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;);&#125;);new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(5)&#125;).then((data) =&gt; &#123; console.log(data);&#125;)setTimeout(() =&gt; &#123; console.log(6);&#125;)console.log(7); 这里结果会是什么呢？运用上面了解到的知识，先自己做一下试试看。 12345678// 正确答案1475236 你答对了吗？ 我们来分析一下整个流程： 执行全局Script代码 Step 1 1console.log(1) Stack Queue: [console] Macrotask Queue: [] Microtask Queue: [] 打印结果：1 Step 2 1234567setTimeout(() =&gt; &#123; // 这个回调函数叫做callback1，setTimeout属于macrotask，所以放到macrotask queue中 console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;);&#125;); Stack Queue: [setTimeout] Macrotask Queue: [callback1] Microtask Queue: [] 打印结果：1 Step 3 12345678new Promise((resolve, reject) =&gt; &#123; // 注意，这里是同步执行的，如果不太清楚，可以去看一下我开头自己实现的promise啦~~ console.log(4) resolve(5)&#125;).then((data) =&gt; &#123; // 这个回调函数叫做callback2，promise属于microtask，所以放到microtask queue中 console.log(data);&#125;) Stack Queue: [promise] Macrotask Queue: [callback1] Microtask Queue: [callback2] 打印结果：14 Step 5 1234setTimeout(() =&gt; &#123; // 这个回调函数叫做callback3，setTimeout属于macrotask，所以放到macrotask queue中 console.log(6);&#125;) Stack Queue: [setTimeout] Macrotask Queue: [callback1, callback3] Microtask Queue: [callback2] 打印结果：14 Step 6 1console.log(7) Stack Queue: [console] Macrotask Queue: [callback1, callback3] Microtask Queue: [callback2] 打印结果：147 好啦，全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。 Step 7 1console.log(data) // 这里data是Promise的决议值5 Stack Queue: [callback2] Macrotask Queue: [callback1, callback3] Microtask Queue: [] 打印结果：1475 这里microtask queue中只有一个任务，执行完后开始从宏任务队列macrotask queue中取位于队首的任务执行 Step 8 1console.log(2) Stack Queue: [callback1] Macrotask Queue: [callback3] Microtask Queue: [] 打印结果：14752 但是，执行callback1的时候又遇到了另一个Promise，Promise异步执行完后在microtask queue中又注册了一个callback4回调函数 Step 9 1234Promise.resolve().then(() =&gt; &#123; // 这个回调函数叫做callback4，promise属于microtask，所以放到microtask queue中 console.log(3)&#125;); Stack Queue: [promise] Macrotask v: [callback3] Microtask Queue: [callback4] 打印结果：14752 取出一个宏任务macrotask执行完毕，然后再去微任务队列microtask queue中依次取出执行 Step 10 1console.log(3) Stack Queue: [callback4] Macrotask Queue: [callback3] Microtask Queue: [] 打印结果：147523 微任务队列全部执行完，再去宏任务队列中取第一个任务执行 Step 11 1console.log(6) Stack Queue: [callback3] Macrotask Queue: [] Microtask Queue: [] 打印结果：1475236 以上，全部执行完后，Stack Queue为空，Macrotask Queue为空，Micro Queue为空 Stack Queue: [] Macrotask Queue: [] Microtask Queue: [] 最终打印结果：1475236 因为是第一个例子，所以这里分析的比较详细，大家仔细看一下，接下来我们再来一个例子： 12345678910111213141516171819202122232425262728293031console.log(1);setTimeout(() =&gt; &#123; console.log(2); Promise.resolve().then(() =&gt; &#123; console.log(3) &#125;);&#125;);new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(5)&#125;).then((data) =&gt; &#123; console.log(data); Promise.resolve().then(() =&gt; &#123; console.log(6) &#125;).then(() =&gt; &#123; console.log(7) setTimeout(() =&gt; &#123; console.log(8) &#125;, 0); &#125;);&#125;)setTimeout(() =&gt; &#123; console.log(9);&#125;)console.log(10); 最终输出结果是什么呢？参考前面的例子，好好想一想…… 1234567891011// 正确答案14105672398 相信大家都答对了，这里的关键在前面已经提过： 在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。 注：当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的，拿NodeJS中的微任务process.nextTick()来说，它的上限是1000个，后面我们会讲到。 浏览器的Event Loop就说到这里，下面我们看一下NodeJS中的Event Loop，它更复杂一些，机制也不太一样。 NodeJS中的Event Looplibuv先来看一张libuv的结构图： NodeJS中的宏队列和微队列NodeJS的Event Loop中，执行宏队列的回调任务有6个阶段，如下图： 各个阶段执行的任务如下： timers阶段：这个阶段执行setTimeout和setInterval预定的callback I/O callback阶段：执行除了close事件的callbacks、被timers设定的callbacks、setImmediate()设定的callbacks这些之外的callbacks idle, prepare阶段：仅node内部使用 poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里 check阶段：执行setImmediate()设定的callbacks close callbacks阶段：执行socket.on(‘close’, ….)这些callbacks NodeJS中宏队列主要有4个 由上面的介绍可以看到，回调事件主要位于4个macrotask queue中： Timers Queue IO Callbacks Queue Check Queue Close Callbacks Queue 这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。 NodeJS中微队列主要有2个： Next Tick Queue：是放置process.nextTick(callback)的回调任务的 Other Micro Queue：放置其他microtask，比如Promise等 在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。 具体可以通过下图加深一下理解： 大体解释一下NodeJS的Event Loop过程： 执行全局Script的同步代码 执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务 开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2 Timers Queue -&gt; 步骤2 -&gt; I/O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; Timers Queue …… 这就是Node的Event Loop 关于NodeJS的macrotask queue和microtask queue，我画了两张图，大家作为参考： 好啦，概念理解了我们通过几个例子来实战一下： 第一个例子 12345678910111213141516171819202122232425262728293031323334console.log('start');setTimeout(() =&gt; &#123; // callback1 console.log(111); setTimeout(() =&gt; &#123; // callback2 console.log(222); &#125;, 0); setImmediate(() =&gt; &#123; // callback3 console.log(333); &#125;) process.nextTick(() =&gt; &#123; // callback4 console.log(444); &#125;)&#125;, 0);setImmediate(() =&gt; &#123; // callback5 console.log(555); process.nextTick(() =&gt; &#123; // callback6 console.log(666); &#125;)&#125;)setTimeout(() =&gt; &#123; // callback7 console.log(777); process.nextTick(() =&gt; &#123; // callback8 console.log(888); &#125;)&#125;, 0);process.nextTick(() =&gt; &#123; // callback9 console.log(999); &#125;)console.log('end'); 请运用前面学到的知识，仔细分析一下…… 123456789101112// 正确答案startend999111777444888555333666222 更新 2018.9.20 上面这段代码你执行的结果可能会有多种情况，原因解释如下。 setTimeout(fn, 0)不是严格的0，一般是setTimeout(fn, 3)或什么，会有一定的延迟时间，当setTimeout(fn, 0)和setImmediate(fn)出现在同一段同步代码中时，就会存在两种情况。 第1种情况：同步代码执行完了，Timer还没到期，setImmediate回调先注册到Check Queue中，开始执行微队列，然后是宏队列，先从Timers Queue中开始，发现没回调，往下走直到Check Queue中有回调，执行，然后timer到期（只要在执行完Timer Queue后到期效果就都一样），timer回调注册到Timers Queue中，下一轮循环执行到Timers Queue中才能执行那个timer 回调；所以，这种情况下，setImmediate(fn)回调先于setTimeout(fn, 0)回调执行。 第2种情况：同步代码还没执行完，timer先到期，timer回调先注册到Timers Queue中，执行到setImmediate了，它的回调再注册到Check Queue中。 然后，同步代码执行完了，执行微队列，然后开始先执行Timers Queue，先执行Timer 回调，再到Check Queue，执行setImmediate回调；所以，这种情况下，setTimeout(fn, 0)回调先于setImmediate(fn)回调执行。 所以，在同步代码中同时调setTimeout(fn, 0)和setImmediate情况是不确定的，但是如果把他们放在一个IO的回调，比如readFile(‘xx’, function () {// ….})回调中，那么IO回调是在IO Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，IO Queue执行完到Check Queue，timer Queue得到下个周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行。 综上，这个例子是不太好的，setTimeout(fn, 0)和setImmediate(fn)如果想要保证结果唯一，就放在一个IO Callback中吧，上面那段代码可以把所有它俩同步执行的代码都放在一个IO Callback中，结果就唯一了。 更新结束 你答对了吗？我们来一起分析一下： 执行全局Script代码，先打印start，向下执行，将setTimeout的回调callback1注册到Timers Queue中，再向下执行，将setImmediate的回调callback5注册到Check Queue中，接着向下执行，将setTimeout的回调callback7注册到Timers Queue中，继续向下，将process.nextTick的回调callback9注册到微队列Next Tick Queue中,最后一步打印end。此时，各个队列的回调情况如下： 宏队列 Timers Queue: [callback1, callback7] Check Queue: [callback5] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [callback9] Other Microtask Queue: [] 打印结果startend 全局Script执行完了，开始依次执行微任务Next Tick Queue中的全部回调任务。此时Next Tick Queue中只有一个callback9，将其取出放入调用栈中执行，打印999。 宏队列 Timers Queue: [callback1, callback7] Check Queue: [callback5] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [] Other Microtask Queue: [] 打印结果startend999 开始依次执行6个阶段各自宏队列中的所有任务，先执行第1个阶段Timers Queue中的所有任务，先取出callback1执行，打印111，callback1函数继续向下，依次把callback2放入Timers Queue中，把callback3放入Check Queue中，把callback4放入Next Tick Queue中，然后callback1执行完毕。再取出Timers Queue中此时排在首位的callback7执行，打印777，把callback8放入Next Tick Queue中，执行完毕。此时，各队列情况如下： 宏队列 Timers Queue: [callback2] Check Queue: [callback5, callback3] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [callback4, callback8] Other Microtask Queue: [] 打印结果startend999111777 6个阶段每阶段的宏任务队列执行完毕后，都会开始执行微任务，此时，先取出Next Tick Queue中的所有任务执行，callback4开始执行，打印444，然后callback8开始执行，打印888，Next Tick Queue执行完毕，开始执行Other Microtask Queue中的任务，因为里面为空，所以继续向下。 宏队列 Timers Queue: [callback2] Check Queue: [callback5, callback3] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [] Other Microtask Queue: [] 打印结果startend999111777444888 第2个阶段IO Callback Queue队列为空，跳过，第3和第4个阶段一般是Node内部使用，跳过，进入第5个阶段Check Queue。取出callback5执行，打印555，把callback6放入Next Tick Queue中，执行callback3，打印333。 宏队列 Timers Queue: [callback2] Check Queue: [] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [callback6] Other Microtask Queue: [] 打印结果startend999111777444888555333 执行微任务队列，先执行Next Tick Queue，取出callback6执行，打印666，执行完毕，因为Other Microtask Queue为空，跳过。 宏队列 Timers Queue: [callback2] Check Queue: [] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [callback6] Other Microtask Queue: [] 打印结果startend999111777444888555333 执行第6个阶段Close Callback Queue中的任务，为空，跳过，好了，此时一个循环已经结束。进入下一个循环，执行第1个阶段Timers Queue中的所有任务，取出callback2执行，打印222，完毕。此时，所有队列包括宏任务队列和微任务队列都为空，不再打印任何东西。 宏队列 Timers Queue: [] Check Queue: [] IO Callback Queue： [] Close Callback Queue: [] 微队列 Next Tick Queue: [callback6] Other Microtask Queue: [] 最终结果startend999111777444888555333666222 以上就是这道题目的详细分析，如果没有明白，一定要多看几次。 下面引入Promise再来看一个例子： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)process.nextTick(function() &#123; console.log('6');&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 大家仔细分析，相比于上一个例子，这里由于存在Promise，所以Other Microtask Queue中也会有回调任务的存在，执行到微任务阶段时，先执行Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务，然后才会进入下一个阶段的宏任务。明白了这一点，相信大家都可以分析出来，下面直接给出正确答案，如有疑问，欢迎留言和我讨论。 12345678910111213// 正确答案176824911310512 setTimeout 对比 setImmediate setTimeout(fn, 0)在Timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行 setImmediate(fn)在Check阶段执行 两者的执行顺序要根据当前的执行环境才能确定： 如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机 如果两者都不在主模块调用，即在一个I/O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段 setImmediate 对比 process.nextTick setImmediate(fn)的回调任务会插入到宏队列Check Queue中 process.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中 process.nextTick(fn)调用深度有限制，上限是1000，而setImmedaite则没有 总结 浏览器的Event Loop和NodeJS的Event Loop是不同的，实现机制也不一样，不要混为一谈。 浏览器可以理解成只有1个宏任务队列和1个微任务队列，先执行全局Script代码，执行完同步代码调用栈清空后，从微任务队列中依次取出所有的任务放入调用栈执行，微任务队列清空后，从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里和Node的区别，只取一个，然后继续执行微队列中的所有任务，再去宏队列取一个，以此构成事件循环。 NodeJS可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段。先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务队列Next Tick Queue中依次取出所有的任务放入调用栈中执行，再从微任务队列Other Microtask Queue中依次取出所有的任务放入调用栈中执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行（注意，这里和浏览器不一样，浏览器只取一个），每个宏任务阶段执行完毕后，开始执行微任务，再开始执行下一阶段宏任务，以此构成事件循环。 MacroTask包括： setTimeout、setInterval、 setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering Microtask包括： process.nextTick(Node)、Promise、Object.observe、MutationObserver 参考链接不要混淆nodejs和浏览器中的event loopnode中的Event模块Promises, process.nextTick And setImmediate浏览器和Node不同的事件循环Tasks, microtasks, queues and schedules理解事件循环浅析]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>V8</tag>
        <tag>Node</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现函数重载]]></title>
    <url>%2F2018%2F08%2F29%2Fjavascript_function_overload%2F</url>
    <content type="text"><![CDATA[概念重载是指函数或者方法有相同的名称，但是参数个数或类型不相同的情形，这样的同名不同参的函数或者方法之间，互相称之为重载函数或方法。 我们知道，JavaScript函数可以随意传递任意数量、任意类型的参数，那么它有没有重载呢？ 答案是有的，下面我们通过3种方法来实现JavaScript的函数重载。 实现0. 目标我们有一个people对象123var people = &#123; values: ['Dean Edwards', 'Sam Stephenson', 'Alex Russell', 'Dean Tom']&#125;; 想要实现一个find方法，不传参数的时候，输出所有名字，只传1个参数的时候，输出所有fristName和参数相同的名字，传2个参数的时候，输出所有firstName和lastName和2个参数分别相同的名字。 123people.find(); // ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]people.find('Dean'); // ["Dean Edwards", "Dean Tom"]people.find('Dean', 'Edwards'); // ["Dean Edwards"] 1. 利用arguments和switch实现重载12345678910111213141516171819202122people.find = function () &#123; switch (arguments.length) &#123; case 0: return this.values; case 1: return this.values.filter((value) =&gt; &#123; var firstName = arguments[0]; return value.indexOf(firstName) !== -1 ? true : false; &#125;); case 2: return this.values.filter((value) =&gt; &#123; var fullName = `$&#123;arguments[0]&#125; $&#123;arguments[1]&#125;`; return value.indexOf(fullName) !== -1 ? true : false; &#125;); &#125;&#125;;console.log(people.find()); // ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]console.log(people.find('Dean')); // ["Dean Edwards", "Dean Tom"]console.log(people.find('Dean', 'Edwards')); // ["Dean Edwards"] 这种方式大家肯定都能看懂，就不多说啦。 2. 利用arguments和闭包实现重载123456789101112131415161718192021222324252627282930313233343536function addMethod (object, name, fn) &#123; // 把前一次添加的方法存在一个临时变量old中 var old = object[name]; // 重写object[name]方法 object[name] = function () &#123; if (fn.length === arguments.length) &#123; // 如果调用object[name]方法时，如果实参和形参个数一致，则直接调用 return fn.apply(this, arguments); &#125; else if (typeof old === 'function') &#123; // 如果实参形参不一致，判断old是否是函数，如果是，就调用old return old.apply(this, arguments); &#125; &#125;;&#125;addMethod(people, 'find', function() &#123; return this.values;&#125;);addMethod(people, 'find', function(firstName) &#123; return this.values.filter((value) =&gt; &#123; return value.indexOf(firstName) !== -1 ? true : false; &#125;);&#125;);addMethod(people, 'find', function(firstName, lastName) &#123; return this.values.filter((value) =&gt; &#123; var fullName = `$&#123;firstName&#125; $&#123;lastName&#125;`; return value.indexOf(fullName) !== -1 ? true : false; &#125;);&#125;);console.log(people.find()); // ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]console.log(people.find('Dean')); // ["Dean Edwards", "Dean Tom"]console.log(people.find('Dean', 'Edwards')); // ["Dean Edwards"] 这里addMethod(object, name, fn)方法是核心。我们着重分析一下为什么这里会有闭包，可以保存上一个注册的函数。 12345678910111213function addMethod (object, name, fn) &#123; // object, name, fn是传入的3个参数 var old = object[name]; object[name] = function () &#123; // 这里对old和fn进行了引用 if (fn.length === arguments.length) &#123; return fn.apply(this, arguments); &#125; else if (typeof old === 'function') &#123; return old.apply(this, arguments); &#125; &#125;;&#125; object是另外一个引用对象，它的一个方法中引用了old和fn，所以对于addMethod来说，它的局部变量在addMethod函数执行完后，仍然被另外的变量所引用，导致它的执行环境无法销毁，所以产生了闭包。 因此，每次调用addMethod，都会有一个执行环境保存着当时的old和fn，所以在调用people.find()的时候可以找到当时注入的fn，实现函数重载。 3. 利用Proxy和arguments实现重载12345678910111213141516171819202122232425262728293031323334var proxy = new Proxy(people, &#123; get: function (target, key, receiver) &#123; if (key === 'find') &#123; return function () &#123; switch (arguments.length) &#123; case 0: return this.values; case 1: return this.values.filter((value) =&gt; &#123; var firstName = arguments[0]; return value.indexOf(firstName) !== -1 ? true : false; &#125;); case 2: return this.values.filter((value) =&gt; &#123; var fullName = `$&#123;arguments[0]&#125; $&#123;arguments[1]&#125;`; return value.indexOf(fullName) !== -1 ? true : false; &#125;); &#125; &#125;; &#125; return Reflect.get(target , key , receiver); &#125;, set: function (target, key, value, receiver) &#123; return Reflect.set(target, key, value, receiver); &#125;&#125;);console.log(proxy.find()); // ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]console.log(proxy.find('Dean')); // ["Dean Edwards", "Dean Tom"]console.log(proxy.find('Dean', 'Edwards')); // ["Dean Edwards"] 这样写其实感觉有点画蛇添足了，就当成是另外一种思路吧。 总结JavaScript可以实现函数重载，主要有两种思想： 利用arguments类数组来判断接收参数的个数 利用闭包保存以前注册进来的同名函数]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>继承</tag>
        <tag>原型链</tag>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现继承]]></title>
    <url>%2F2018%2F08%2F28%2Fjavascript_extend%2F</url>
    <content type="text"><![CDATA[简介本文不准备深入细节，主要是对《JavaScript高级程序设计中》介绍的JS如何实现继承做一个总结，毕竟好记性不如烂笔头。文末会附带一张神图，搞清楚这张图，原型链也就没有什么问题了。 ES5实现继承的六种方式1. 原型链基本思想： 利用原型链让一个引用类型继承另一个引用类型的属性和方法。 12345678910111213141516171819202122232425262728function SuperType () &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property; &#125;;// 子类 SubTypefunction SubType () &#123; this.subProperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123; return this.subProperty;&#125;;// 实例var instance = new SubType();console.log(instance);console.log(instance.getSuperValue()); // trueconsole.log(instance instanceof SubType); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(instance instanceof Object); // trueconsole.log(SubType.prototype.isPrototypeOf(instance)); // trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); // trueconsole.log(Object.prototype.isPrototypeOf(instance)); // true 缺点： 1. 来自原型对象的引用属性是所有实例共享的。 2. 创建子类实例时，无法向父类构造函数传参。 举例如下：123456789101112131415161718192021// 1. 来自原型对象的引用属性是所有实例共享的// 父类function SuperType () &#123; this.colors = ['red', 'blue', 'green'];&#125;// 子类function SubType () &#123;&#125;SubType.prototype = new SuperType();// 实例var instance1 = new SubType();instance1.colors.push('black');console.log(instance1.colors); // ['red', 'blue', 'green', 'black']var instance2 = new SubType();console.log(instance2.colors); // ['red', 'blue', 'green', 'black']// 因为修改colors是修改的SubType.prototype.colors，所以所有的实例都会更新 12345// 2. 创建子类实例时，无法向父类构造函数传参// 调用父类是在 SubType.prototype = new SuperType()// 新建子类实例调用 new SubType()// 所以无法再new SubType() 的时候给父类 SuperType() 传参 2. 借用构造函数基本思想： 在子类构造函数的内部通过call()以及apply()调用父类构造函数。 12345678910111213141516171819202122232425262728293031// 父类 SuperTypefunction SuperType (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green']; this.getName = function () &#123; return this.name; &#125;&#125;// 子类function SubType (name) &#123; // 继承了SuperType，同时还传递了参数 SuperType.call(this, name); // 实例属性 this.age = 20;&#125;// 实例var instance1 = new SubType('Tom');instance1.colors.push('black');console.log(instance1.name); // "Tom"console.log(instance1.getName()); // "Tom"console.log(instance1.age); // 20console.log(instance1.colors); // ['red', 'blue', 'green', 'black']var instance2 = new SubType('Peter');console.log(instance2.name); // "Peter"console.log(instance2.getName()); // "Peter"console.log(instance2.age); // 20console.log(instance2.colors); // ['red', 'blue', 'green'] 可以看到，借用构造函数实现继承，解决了原型链继承的两个问题，既可以在新建子类实例的时候给父类构造函数传递参数，也不会造成子类实例共享父类引用变量。 但是你注意到了吗，这里我们把父类方法也写在了SuperType()构造函数里面，可以像前面一样写在SuperType.prototype上吗？ 答案是不可以，必须写在SuperType()构造函数里面。因为这里是通过调用SuperType.call(this)来实现继承的，并没有通过new生成一个父类实例，所以如果写在prototype上，子类是无法拿到的。 缺点： 1. 如果方法都在构造函数中定义，那么就无法复用函数。每次构建实例时都会在实例中保留方法函数，造成了内存的浪费，同时也无法实现同步更新，因为每个实例都是单独的方法函数。如果方法写在prototype上，就只会有一份，更新时候会做到同步更新。 3. 组合继承基本思想： 将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 123456789101112131415161718192021222324252627282930313233343536// 父类function SuperType (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;// 子类function SubType (name, age) &#123; // 继承父类实例属性 SuperType.call(this, name); // 子类实例属性 this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;;// 实例var instance1 = new SubType('Tom', 20);instance1.colors.push('black');console.log(instance1.colors); // ['red', 'blue', 'green', 'black']instance1.sayName(); // "Tom"instance1.sayAge(); // 20var instance2 = new SubType('Peter', 30);console.log(instance2.colors); // ['red', 'blue', 'green']instance2.sayName(); // "Peter"instance2.sayAge(); // 30 缺点： 1. 调用了两次父类构造函数，一次通过SuperType.call(this)调用，一次通过new SuperType()调用。 4. 原型式继承基本思想： 不使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。 1234567891011121314151617181920212223242526// 在object函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。// 从本质上讲，object()对传入其中的对象执行了一次浅复制。function object (o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: 'Tom', friends: ['Shelby', 'Court', 'Van']&#125;;var anotherPerson = object(person);anotherPerson.name = 'Greg';anotherPerson.friends.push('Rob');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'Linda';yetAnotherPerson.friends.push('Barbie');console.log(anotherPerson.friends); // ['Shelby', 'Court', 'Van', 'Rob', 'Barbie']console.log(yetAnotherPerson.friends); // ['Shelby', 'Court', 'Van', 'Rob', 'Barbie']console.log(person.friends); // ['Shelby', 'Court', 'Van', 'Rob', 'Barbie'] ECMAScript5中新增了一个方法Object.create(prototype, descripter)接收两个参数： prototype（必选），用作新对象的原型对象 descripter（可选），为新对象定义额外属性的对象 在传入一个参数的情况下，Object.create()与前面写的object()方法的行为相同。 1234567891011121314151617181920var person = &#123; name: 'Tom', friends: ['Shelby', 'Court', 'Van']&#125;;var anotherPerson = Object.create(person);anotherPerson.name = 'Greg';anotherPerson.friends.push('Rob');var yetAnotherPerson = Object.create(person, &#123; name: &#123; value: 'Linda', enumerable: true &#125;&#125;);yetAnotherPerson.friends.push('Barbie');console.log(anotherPerson.friends); // ['Shelby', 'Court', 'Van', 'Rob', 'Barbie']console.log(yetAnotherPerson.friends); // ['Shelby', 'Court', 'Van', 'Rob', 'Barbie']console.log(person.friends); // ['Shelby', 'Court', 'Van', 'Rob', 'Barbie'] 缺点： 1. 和原型链继承一样，所有子类实例共享父类的引用类型。 5. 寄生式继承基本原理： 寄生式继承是与原型式继承紧密相关的一种思路，创建一个仅用于封装继承过程的函数，该函数内部以某种形式来做增强对象，最后返回对象。 12345678910111213141516171819202122232425function object (o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function createAnother (o) &#123; var clone = object(o); clone.sayHi = function () &#123; console.log('Hi'); &#125; return clone;&#125;var person = &#123; name: 'Tom', friends: ['Shelby', 'Court', 'Van'] &#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // "Hi"anotherPerson.friends.push('Rob');console.log(anotherPerson.friends); // ['Shelby', 'Court', 'Van', 'Rob']var yerAnotherPerson = createAnother(person);console.log(yerAnotherPerson.friends); // ['Shelby', 'Court', 'Van', 'Rob'] 缺点： 1. 和原型链式继承一样，所有子类实例共享父类引用类型。 2. 和借用构造函数继承一样，每次创建对象都会创建一次方法。 6. 寄生组合式继承基本思想： 将寄生式继承和组合继承相结合，解决了组合式继承中会调用两次父类构造函数的缺点。 组合继承是JavaScript最常用的继承模式，它最大的问题就是无论在什么情况下，都会调用两次父类构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数内部。 1234567891011121314151617// 组合继承function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); //第二次调用 SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); //第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123; alert(this.age);&#125;; 组合继承在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是 SuperType 的实例属性，只不过现在位于 SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 其背后的基本思路是：不必为了指定子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本而已。本质上，就是使用寄生式继承来继承父类的prototype，然后再将结果指定给子类的prototype。 寄生组合式继承的基本模型如下： 123456function inheritPrototype(SubType, SuperType) &#123; var prototype = object(SuperType.prototype); // 创建对象 prototype.constructor = SubType; // 增强对象 SubType.prototype = prototype; // 指定对象 &#125; 实现一个完整的寄生组合式继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125;function inheritPrototype(SubType, SuperType) &#123; var prototype = object(SuperType.prototype); // 创建对象 prototype.constructor = SubType; // 增强对象 SubType.prototype = prototype; // 指定对象 &#125;// 父类function SuperType(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;;// 子类function SubType(name, age) &#123; // 继承父类实例属性 SuperType.call(this, name); // 子类实例属性 this.age = age;&#125;// 继承父类方法inheritPrototype(SubType, SuperType);// 子类方法SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;;// 实例var instance1 = new SubType('Tom', 20);instance1.colors.push('black');instance1.sayAge(); // 20instance1.sayName(); // "Tom"console.log(instance1.colors); // ["red", "blue", "green", "black"]var instance2 = new SubType('Peter', 30);instance2.sayAge(); // 30instance2.sayName(); // "Peter"console.log(instance2.colors); // ["red", "blue", "green"] 寄生组合式继承的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了再SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用instanceof和isPrototypeOf()。 开发人员普遍认为寄生组合式继承是引用类型最理想的继承方式。 ES6实现继承123456789101112131415161718192021222324252627282930313233343536373839// 父类class SuperType &#123; constructor(name) &#123; this.name = name; this.colors = ["red", "blue", "green"]; &#125; sayName() &#123; console.log(this.name); &#125;;&#125;// 子类class SubType extends SuperType &#123; constructor(name, age) &#123; // 继承父类实例属性和prototype上的方法 super(name); // 子类实例属性 this.age = age; &#125; // 子类方法 sayAge() &#123; console.log(this.age); &#125;&#125;// 实例var instance1 = new SubType('Tom', 20);instance1.colors.push('black');instance1.sayAge(); // 20instance1.sayName(); // "Tom"console.log(instance1.colors); // ["red", "blue", "green", "black"]var instance2 = new SubType('Peter', 30);instance2.sayAge(); // 30instance2.sayName(); // "Peter"console.log(instance2.colors); // ["red", "blue", "green"] 用ES6的语法来实现继承非常的简单，下面是把这段代码放到Babel里转码的结果图片： 可以看到，底层其实也是用寄生组合式继承来实现的。 总结ES5实现继承有6种方式： 原型链继承 借用构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承 寄生组合式继承是大家公认的最好的实现引用类型继承的方法。 ES6新增class和extends语法，用来定义类和实现继承，底层也是采用了寄生组合式继承。 附图：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>继承</tag>
        <tag>原型链</tag>
        <tag>寄生组合式继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据结构04 - 链表]]></title>
    <url>%2F2018%2F08%2F03%2Fjavascript_data_structure_04_linked_list%2F</url>
    <content type="text"><![CDATA[一、定义1.1 概念前面我们学习了数组这种数据结构。数组（或者也可以称为列表）是一种非常简单的存储数据序列的数据结构。在这一节，我们要学习如何实现和使用链表这种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩容。 要存储多个元素，数组（或列表）可能是最常用的数据结构，它提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数强类型语言中）数组的大小是固定的，需要预先分配，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（注意：在JavaScript中数组的大小随时可变，不需要预先定义长度） 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。 相对于传统的数组，链表的一个好处在于，添加或删除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的元素，而想要访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 火车可以当做生活中一个典型的链表的例子。一列火车是由一系列车厢组成的。每节车厢都相互连接。你很容易分离一节车厢，改变它的位置，添加或移除它。 1.2 分类链表最常用的有三类： 单向链表 双向链表 循环链表 二、链表的实现2.1 单向链表创建单向链表类：123456789101112131415161718192021// SinglyLinkedListfunction SinglyLinkedList () &#123; function Node (element) &#123; this.element = element; this.next = null; &#125; var length = 0; var head = null; this.append = function (element) &#123;&#125;; this.insert = function (position, element) &#123;&#125;; this.removeAt = function (position) &#123;&#125;; this.remove = function (element) &#123;&#125;; this.indexOf = function (element) &#123;&#125;; this.isEmpty = function () &#123;&#125;; this.size = function () &#123;&#125;; this.getHead = function () &#123;&#125;; this.toString = function () &#123;&#125;; this.print = function () &#123;&#125;;&#125; SinglyLinkedList需要一个辅助类Node。Node类表示要加入链表的项。它包含一个element属性，即要添加到链表的值，以及一个next属性，即指向链表中下一个节点项的指针。 链表里面有一些声明的辅助方法： append(element)：向链表尾部添加新项 insert(position, element)：向链表的特定位置插入一个新的项 removeAt(position)：从链表的特定位置移除一项 remove(element)：从链表中移除一项 indexOf(element)：返回元素在链表中的索引。如果链表中没有该元素则返回-1 isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0，返回false size()：返回链表包含的元素个数，与数组的length属性类似 getHead()：返回链表的第一个元素 toString()：由于链表使用了Node类，就需要重写继承自JavaScript对象默认的toString()方法，让其只输出元素的值 print()：打印链表的所有元素 下面我们来一一实现这些辅助方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// 向链表尾部添加一个新的项this.append = function (element) &#123; var node = new Node(element); var currentNode = head; // 判断是否为空链表 if (currentNode === null) &#123; // 空链表 head = node; &#125; else &#123; // 从head开始一直找到最后一个node while (currentNode.next) &#123; // 后面还有node currentNode = currentNode.next; &#125; currentNode.next = node; &#125; length++;&#125;;// 向链表特定位置插入一个新的项this.insert = function (position, element) &#123; if (position &lt; 0 &amp;&amp; position &gt; length) &#123; // 越界 return false; &#125; else &#123; var node = new Node(element); var index = 0; var currentNode = head; var previousNode; if (position === 0) &#123; node.next = currentNode; head = node; &#125; else &#123; while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = node; node.next = currentNode; &#125; length++; return true; &#125;&#125;;// 从链表的特定位置移除一项this.removeAt = function (position) &#123; if (position &lt; 0 &amp;&amp; position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; var currentNode = head; var index = 0; var previousNode; if (position === 0) &#123; head = currentNode.next; &#125; else &#123; while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; &#125; length--; return true; &#125;&#125;;// 从链表的特定位置移除一项this.removeAt = function (position) &#123; if (position &lt; 0 &amp;&amp; position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; var currentNode = head; var index = 0; var previousNode; if (position === 0) &#123; head = currentNode.next; &#125; else &#123; while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; &#125; length--; return true; &#125;&#125;;// 从链表中移除指定项this.remove = function (element) &#123; var index = this.indexOf(element); return this.removeAt(index);&#125;;// 返回元素在链表的索引，如果链表中没有该元素则返回-1this.indexOf = function (element) &#123; var currentNode = head; var index = 0; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; index++; currentNode = currentNode.next; &#125; return -1;&#125;;// 如果链表中不包含任何元素，返回true，如果链表长度大于0，返回falsethis.isEmpty = function () &#123; return length == 0;&#125;;// 返回链表包含的元素个数，与数组的length属性类似this.size = function () &#123; return length;&#125;;// 获取链表头部元素this.getHead = function () &#123; return head.element;&#125;;// 由于链表使用了Node类，就需要重写继承自JavaScript对象默认的toString()方法，让其只输出元素的值this.toString = function () &#123; var currentNode = head; var string = ''; while (currentNode) &#123; string += ',' + currentNode.element; currentNode = currentNode.next; &#125; return string.slice(1);&#125;;this.print = function () &#123; console.log(this.toString());&#125;; 创建单向链表实例进行测试：12345678910111213141516171819// 创建单向链表实例var singlyLinked = new SinglyLinkedList();console.log(singlyLinked.removeAt(0)); // trueconsole.log(singlyLinked.isEmpty()); // truesinglyLinked.append('Tom'); singlyLinked.append('Peter');singlyLinked.append('Paul');singlyLinked.print(); // "Tom,Peter,Paul"singlyLinked.insert(0, 'Susan'); singlyLinked.print(); // "Susan,Tom,Peter,Paul"singlyLinked.insert(1, 'Jack'); singlyLinked.print(); // "Susan,Jack,Tom,Peter,Paul"console.log(singlyLinked.getHead()); // "Susan"console.log(singlyLinked.isEmpty()); // falseconsole.log(singlyLinked.indexOf('Peter')); // 3console.log(singlyLinked.indexOf('Cris')); // -1singlyLinked.remove('Tom'); singlyLinked.removeAt(2); singlyLinked.print(); // "Susan,Jack,Paul" 2.2 双向链表双向链表和普通链表的区别在于，在普通链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。 创建双向链表类：123456789101112// 创建双向链表DoublyLinkedList类function DoublyLinkedList () &#123; function Node (element) &#123; this.element = element; this.next = null; this.prev = null; // 新增 &#125; var length = 0; var head = null; var tail = null; // 新增&#125; 可以看到，双向链表在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性。 双向链表提供了两种迭代列表的方法：从头到尾，或者从尾到头。我们可以访问一个特定节点的下一个或前一个元素。 在单向链表中，如果迭代链表时错过了要找的元素，就需要回到链表起点，重新开始迭代。在双向链表中，可以从任一节点，向前或向后迭代，这是双向链表的一个优点。 实现双向链表的辅助方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// 向链表尾部添加一个新的项this.append = function (element) &#123; var node = new Node(element); var currentNode = tail; // 判断是否为空链表 if (currentNode === null) &#123; // 空链表 head = node; tail = node; &#125; else &#123; currentNode.next = node; node.prev = currentNode; tail = node; &#125; length++;&#125;;// 向链表特定位置插入一个新的项this.insert = function (position, element) &#123; if (position &lt; 0 &amp;&amp; position &gt; length) &#123; // 越界 return false; &#125; else &#123; var node = new Node(element); var index = 0; var currentNode = head; var previousNode; if (position === 0) &#123; if (!head) &#123; head = node; tail = node; &#125; else &#123; node.next = currentNode; currentNode.prev = node; head = node; &#125; &#125; else if (position === length) &#123; this.append(element); &#125; else &#123; while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = node; node.next = currentNode; node.prev = previousNode; currentNode.prev = node; &#125; length++; return true; &#125;&#125;;// 从链表的特定位置移除一项this.removeAt = function (position) &#123; if (position &lt; 0 &amp;&amp; position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; var currentNode = head; var index = 0; var previousNode; if (position === 0) &#123; // 移除第一项 if (length === 1) &#123; head = null; tail = null; &#125; else &#123; head = currentNode.next; head.prev = null; &#125; &#125; else if (position === length - 1) &#123; // 移除最后一项 if (length === 1) &#123; head = null; tail = null; &#125; else &#123; currentNode = tail; tail = currentNode.prev; tail.next = null; &#125; &#125; else &#123; while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; previousNode = currentNode.next.prev; &#125; length--; return true; &#125;&#125;;// 从链表中移除指定项this.remove = function (element) &#123; var index = this.indexOf(element); return this.removeAt(index);&#125;;// 返回元素在链表的索引，如果链表中没有该元素则返回-1this.indexOf = function (element) &#123; var currentNode = head; var index = 0; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; index++; currentNode = currentNode.next; &#125; return -1;&#125;;// 如果链表中不包含任何元素，返回true，如果链表长度大于0，返回falsethis.isEmpty = function () &#123; return length == 0;&#125;;// 返回链表包含的元素个数，与数组的length属性类似this.size = function () &#123; return length;&#125;;// 获取链表头部元素this.getHead = function () &#123; return head.element;&#125;;// 由于链表使用了Node类，就需要重写继承自JavaScript对象默认的toString()方法，让其只输出元素的值this.toString = function () &#123; var currentNode = head; var string = ''; while (currentNode) &#123; string += ',' + currentNode.element; currentNode = currentNode.next; &#125; return string.slice(1); &#125;;this.print = function () &#123; console.log(this.toString());&#125;; 创建双向链表实例进行测试：123456789101112131415161718// 创建双向链表var doublyLinked = new DoublyLinkedList();console.log(doublyLinked.isEmpty()); // truedoublyLinked.append('Tom'); doublyLinked.append('Peter');doublyLinked.append('Paul');doublyLinked.print(); // "Tom,Peter,Paul"doublyLinked.insert(0, 'Susan'); doublyLinked.print(); // "Susan,Tom,Peter,Paul"doublyLinked.insert(1, 'Jack'); doublyLinked.print(); // "Susan,Jack,Tom,Peter,Paul"console.log(doublyLinked.getHead()); // "Susan"console.log(doublyLinked.isEmpty()); // falseconsole.log(doublyLinked.indexOf('Peter')); // 3console.log(doublyLinked.indexOf('Cris')); // -1doublyLinked.remove('Tom'); doublyLinked.removeAt(2); doublyLinked.print(); // "Susan,Jack,Paul" 2.3 循环链表循环链表可以像单向链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和普通链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（next）不是引用null，而是指向第一个元素（head）。这里就不进行代码实现了，大家可以结合上面的单向链表和双向链表自己实现一个循环链表。 三、结束本文会同步到我的个人博客，完整代码可以到我的github仓库查看，如果对你有帮助的话欢迎点一个Star~~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据结构03 - 队列]]></title>
    <url>%2F2018%2F07%2F26%2Fjavascript_data_structure_03_queue%2F</url>
    <content type="text"><![CDATA[一、定义前面我们学习了栈的实现，队列和栈非常类似，但是使用了不同的原则，而非后进先出。 队列是遵循FIFO（First In First Out，先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在计算机科学中，一个最常见的例子就是打印队列。比如说我们要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。 二、队列的实现2.1 普通队列创建普通队列类：123456789101112// Queue类function Queue () &#123; this.items = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.isEmpty = isEmpty; this.size = size; this.clear = clear; this.print = print;&#125; 队列里面有一些声明的辅助方法： enqueue(element)：向队列尾部添加新项 dequeue()：移除队列的第一项（即排在队列最前面的项），并返回被移除的元素 front()：返回队列中第一个元素，队列不做任何变动，和Stack的peek()方法类似 isEmpty()：如果队列中不包含任何元素，返回true，否则返回false size()：返回队列包含的元素个数，与数组的length属性类似 print()：打印队列中的元素 clear()：清空整个队列 下面我们来一一实现这些辅助方法：12345678910111213141516171819202122232425262728293031323334// 向队列尾部添加元素function enqueue (element) &#123; this.items.push(element);&#125;// 移除队列的第一个元素，并返回被移除的元素function dequeue () &#123; return this.items.shift();&#125;// 返回队列的第一个元素function front () &#123; return this.items[0];&#125;// 判断是否为空队列function isEmpty () &#123; return this.items.length === 0;&#125;// 获取队列的长度function size () &#123; return this.items.length;&#125;// 清空队列function clear () &#123; this.items = [];&#125;// 打印队列里的元素function print () &#123; console.log(this.items.toString());&#125; 创建普通队列实例进行测试：123456789101112131415// 创建Queue实例var queue = new Queue();console.log(queue.isEmpty()); // truequeue.enqueue("John"); // undefinedqueue.enqueue("Jack"); // undefinedqueue.enqueue("Camila"); // undefinedqueue.print(); // "John,Jack,Camila"console.log(queue.size()); // 3console.log(queue.isEmpty()); // falsequeue.dequeue(); // "John"queue.dequeue(); // "Jack"queue.print(); // "Camila"queue.clear(); // undefinedconsole.log(queue.size()); // 0 2.2 优先队列2.2.1 定义普通队列的添加和移除只依赖于先后顺序，先来的先添加，后来的后添加，然后按照先后顺序依次从队列移除。 但是，还有一种队列叫优先队列，元素的添加和移除是依赖优先级的。 一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。再比如火车，老年人、孕妇和带小孩的乘客是享有优先检票权的。 2.2.2 分类优先队列分为两类： 最小优先队列 最大优先队列 最小优先队列是把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。比如有四个元素：”John”, “Jack”, “Camila”, “Tom”，他们的优先级值分别为4，3，2，1。 那么最小优先队列排序应该为：“Tom”，”Camila”，”Jack”，”John”。 最大优先队列正好相反，把优先级值最大的元素放置在队列的最前面，以上面的为例，最大优先队列排序应该为：“John”, “Jack”, “Camila”, “Tom”。 2.2.2 实现实现一个优先队列，有两种选项： 设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除 设置优先级，和普通队列一样正常按顺序添加，然后根据优先级移除 这里最小优先队列和最大优先队列我都采用第一种方式实现，大家可以尝试一下第二种。 所以我只重写enqueue()方法和print()方法，其他方法和上面的普通队列完全相同。完整代码见我的github。 实现最小优先队列：123456789101112// 定义最小优先队列function MinPriorityQueue () &#123; this.items = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.isEmpty = isEmpty; this.size = size; this.clear = clear; this.print = print;&#125; 实现最小优先队列enqueue()方法和print()方法：123456789101112131415161718192021222324252627282930313233343536// 优先队列添加元素，要根据优先级判断在队列中的插入顺序function enqueue (element, priority) &#123; var queueElement = &#123; element: element, priority: priority &#125;; if (this.isEmpty()) &#123; this.items.push(queueElement); &#125; else &#123; var added = false; for (var i = 0; i &lt; this.size(); i++) &#123; if (queueElement.priority &lt; this.items[i].priority) &#123; this.items.splice(i, 0, queueElement); added = true; break ; &#125; &#125; if (!added) &#123; this.items.push(queueElement); &#125; &#125;&#125;// 打印队列里的元素function print () &#123; var strArr = []; strArr = this.items.map(function (item) &#123; return `$&#123;item.element&#125;-&gt;$&#123;item.priority&#125;`; &#125;); console.log(strArr.toString());&#125; 最小优先队列测试：12345678910111213141516// 创建最小优先队列minPriorityQueue实例var minPriorityQueue = new MinPriorityQueue();console.log(minPriorityQueue.isEmpty()); // trueminPriorityQueue.enqueue("John", 1); // undefinedminPriorityQueue.enqueue("Jack", 3); // undefinedminPriorityQueue.enqueue("Camila", 2); // undefinedminPriorityQueue.enqueue("Tom", 3); // undefinedminPriorityQueue.print(); // "John-&gt;1,Camila-&gt;2,Jack-&gt;3,Tom-&gt;3"console.log(minPriorityQueue.size()); // 4console.log(minPriorityQueue.isEmpty()); // falseminPriorityQueue.dequeue(); // &#123;element: "John", priority: 1&#125;minPriorityQueue.dequeue(); // &#123;element: "Camila", priority: 2&#125;minPriorityQueue.print(); // "Jack-&gt;3,Tom-&gt;3"minPriorityQueue.clear(); // undefinedconsole.log(minPriorityQueue.size()); // 0 实现最大优先队列最大优先队列只要将优先级的判断改为大于号”&gt;”就可以了：123456789101112131415161718192021222324252627282930313233343536373839// 最大优先队列MaxPriorityQueue类function MaxPriorityQueue () &#123; this.items = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.isEmpty = isEmpty; this.size = size; this.clear = clear; this.print = print;&#125;// 优先队列添加元素，要根据优先级判断在队列中的插入顺序function enqueue (element, priority) &#123; var queueElement = &#123; element: element, priority: priority &#125;; if (this.isEmpty()) &#123; this.items.push(queueElement); &#125; else &#123; var added = false; for (var i = 0; i &lt; this.items.length; i++) &#123; // 注意，只需要将这里改为大于号就可以了 if (queueElement.priority &gt; this.items[i].priority) &#123; this.items.splice(i, 0, queueElement); added = true; break ; &#125; &#125; if (!added) &#123; this.items.push(queueElement); &#125; &#125;&#125; 最大优先队列测试：12345678910111213141516// 创建最大优先队列maxPriorityQueue实例var maxPriorityQueue = new MaxPriorityQueue();console.log(maxPriorityQueue.isEmpty()); // truemaxPriorityQueue.enqueue("John", 1); // undefinedmaxPriorityQueue.enqueue("Jack", 3); // undefinedmaxPriorityQueue.enqueue("Camila", 2); // undefinedmaxPriorityQueue.enqueue("Tom", 3); // undefinedmaxPriorityQueue.print(); // "Jack-&gt;3,Tom-&gt;3,Camila-&gt;2,John-&gt;1"console.log(maxPriorityQueue.size()); // 4console.log(maxPriorityQueue.isEmpty()); // falsemaxPriorityQueue.dequeue(); // &#123;element: "Jack", priority: 3&#125;maxPriorityQueue.dequeue(); // &#123;element: "Tom", priority: 3&#125;maxPriorityQueue.print(); // "Camila-&gt;2,John-&gt;1"maxPriorityQueue.clear(); // undefinedconsole.log(maxPriorityQueue.size()); // 0 2.3 循环队列还有一种队列实现叫做循环队列。 循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。 下面我们在普通队列的基础上，实现一个模拟的击鼓传花游戏：12345678910111213141516171819202122232425262728// 实现击鼓传花function hotPotato (nameList, num) &#123; var queue = new Queue(); for (var i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); &#125; var eliminated = ''; while (queue.size() &gt; 1) &#123; // 循环num次，队首出来去到队尾 for (var i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); &#125; // 循环num次过后，移除当前队首的元素 eliminated = queue.dequeue(); console.log(`$&#123;eliminated&#125;在击鼓传花中被淘汰！`); &#125; // 最后只剩一个元素 return queue.dequeue();&#125;// 测试var nameList = ["John", "Jack", "Camila", "Ingrid", "Carl"];var winner = hotPotato(nameList, 10);console.log(`最后的胜利者是：$&#123;winner&#125;`); 执行结果为：12345// John在击鼓传花中被淘汰！// Ingrid在击鼓传花中被淘汰！ // Jack在击鼓传花中被淘汰！// Camila在击鼓传花中被淘汰！// 最后的胜利者是：Carl 三、结束本文会同步到我的个人博客，完整代码可以到我的github仓库查看，如果对你有帮助的话欢迎点一个Star~~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据结构02 - 栈]]></title>
    <url>%2F2018%2F07%2F25%2Fjavascript_data_structure_02_stack%2F</url>
    <content type="text"><![CDATA[一、定义1.1 背景通过前面一节《JavaScript数据结构01 - 数组》我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。 有两种数据结构类似于数组，但在添加和删除元素时更为可控。 它们就是栈和队列。 1.2 概念栈是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。 二、栈的实现2.1 创建一个类来表示栈这里我还是用构造函数的形式来书写，大家有兴趣可以用ES6的Class来重写一遍。 123456789101112// Stack类function Stack () &#123; this.items = []; this.push = push; this.pop = pop; this.peek = peek; this.isEmpty = isEmpty; this.clear = clear; this.size = size; this.print = print;&#125; 栈里面有一些声明的方法： push(element)：添加一个（或几个）新元素到栈顶 pop()：移除栈顶的元素，同时返回被移除的元素 peek()：返回栈顶的元素，不对栈做任何修改 isEmpty()：如果栈里没有任何元素就返回true，否则返回false clear()：移除栈里的所有元素 size()：返回栈里的元素个数 2.2 实现栈中的辅助方法12345678910111213141516171819202122232425262728293031323334// 添加新元素到栈顶function push (element) &#123; this.items.push(element);&#125;// 移除栈顶元素，同时返回被移除的元素function pop () &#123; return this.items.pop();&#125;// 查看栈顶元素function peek () &#123; return this.items[this.items.length - 1];&#125;// 判断是否为空栈function isEmpty () &#123; return this.items.length === 0;&#125;// 清空栈function clear () &#123; this.items = [];&#125;// 查询栈的长度function size () &#123; return this.items.length;&#125;// 打印栈里的元素function print () &#123; console.log(this.items.toString());&#125; 2.3 创建实例进行测试12345678910111213141516// 创建Stack实例var stack = new Stack();console.log(stack.isEmpty()); // truestack.push(5); // undefinedstack.push(8); // undefinedconsole.log(stack.peek()); // 8stack.push(11); // undefinedconsole.log(stack.size()); // 3console.log(stack.isEmpty()); // falsestack.push(15); // undefinedstack.pop(); // 15console.log(stack.size()); // 3stack.print(); // 5,8,11stack.clear(); // undefinedconsole.log(stack.size()); // 0 三、结束本文会同步到我的个人博客，完整代码可以到我的github仓库查看，如果对你有帮助的话欢迎点一个Star~~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据结构01 - 数组]]></title>
    <url>%2F2018%2F07%2F25%2Fjavascript_data_structure_01_array%2F</url>
    <content type="text"><![CDATA[一、创建数组1.1 使用Array构造函数123var arr1 = new Array(); // 创建一个空数组var arr2 = new Array(10); // 创建一个包含20项的数组var arr3 = new Array('liu', 'wang', 'li'); // 创建一个包含3个字符串的数组 1.2 使用数组字面量表示法123var arr1 = []; // 创建一个空数组var arr2 = [10]; // 创建一个包含1项的数组var arr3 = ['liu', 'wang', 'li']; // 创建一个包含3个字符串的数组 二、常用数组方法 方法名 描述 join 把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔 pop 删除并返回数组的最后一个元素 push 向数组的末尾添加一个或更多元素，并返回新的长度 shift 删除并返回数组的第一个元素 unshift 向数组的开头添加一个或更多元素，并返回新的长度 slice 从某个已有的数组返回指定的元素 indexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1 lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里的最大的值，没有找到则返回-1 sort 对数组的元素进行排序 splice 删除元素，并向数组添加新元素 toString 把数组转换为字符串，并返回结果 toLocaleString 把数组转换为本地字符串，并返回结果 valueOf 返回数组对象的原始值 forEach 对数组中的每一项运行指定函数，这个方法没有返回值 concat 连接2个或更多数组，并返回结果 every 对数组中的每一项运行指定函数，如果该函数对每一项都返回true，则返回true some 对数组中的每一项运行指定函数，如果任一项返回true，则返回true filter 对数组中的每一项运行指定函数，返回该函数会返回true的项组成的数组 reverse 颠倒数组中元素的顺序 map 对数组中的每一项运行指定函数，返回每次函数调用的结果组成的数组 reduce 接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 reduceRight 接收一个函数作为累加器，数组中的每个值（从右到左）开始缩减，最终计算为一个值 PS：原始值是指固定而简单的值，存放在栈中的简单数据段，它们的值直接存储在变量访问的位置。 JavaScript中有五种原始类型，也叫基本类型： Number、String、Boolean、Undefined、Null 三、演示实例3.1 join定义和用法 join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。 语法 arrayObject.join(separator) 参数 描述 seperator 可选。指定要使用的分隔符，如果省略该参数，则使用逗号作为分隔符 返回值 返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。 1234567891011121314var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";var str1 = arr.join();var str2 = arr.join('');var str3 = arr.join(' ');var str4 = arr.join('-');console.log(str1); // "Geroge,John,Thomas"console.log(str2); // "GerogeJohnThomas"console.log(str3); // "Geroge John Thomas"console.log(str4); // "Geroge-John-Thomas" 3.2 pop定义和用法 pop()方法用于删除并返回数组的最后一个元素。 语法 arrayObject.pop() 返回值 arrayObject 的最后一个元素。 说明 pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 12345678var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.pop()); // "Thomas"console.log(arr); // ["Geroge", "Thomas"] 3.3 push定义和用法 push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。 语法 arrayObject.push(newElement1, newElement2, …, newElementX) 参数 描述 newElement1 必需。要添加到数组末尾的第一个元素 newElement2 可选。要添加到数组末尾的第二个元素 newElementX 可选。可添加多个元素 返回值 把指定的值添加到数组后的新长度。 说明 push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。 12345678910var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.push("James")); // 4console.log(arr); // ["Geroge", "John", "Thomas", "James"]console.log(arr.push("Peter", "Sara")); // 6console.log(arr); // ["Geroge", "John", "Thomas", "James", "Peter", "Sara"] 3.4 shift定义和用法 shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 语法 arrayObject.shift() 返回值 数组原来的第一个元素的值。 说明 如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。 12345678var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.shift()); // "Geroge"console.log(arr); // ["John", "Thomas"] 3.5 unshift定义和用法 unshift()方法可向数组的开头添加一个或多个元素，并返回新的长度。 语法 arrayObject.unshift(newElement1, newElement2, …, newElementX) 参数 描述 newElement1 必需。要添加到数组开头的第一个元素 newElement2 可选。要添加到数组开头的第二个元素 newElementX 可选。可添加多个元素 返回值 arrayObject 的新长度。 说明 unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。 请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。 12345678910var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.unshift("James")); // 4console.log(arr); // ["James", "Geroge", "John", "Thomas"]console.log(arr.unshift("Peter", "Sara")); // 6console.log(arr); // ["Peter", "Sara", "James", "Geroge", "John", "Thomas"] 3.6 slice定义和用法 slice()方法可从已有的数组中返回选定的元素。slice()方法不改变原数组。 语法 arrayObject.slice(start, end) 参数 描述 start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。 end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从start到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 说明 请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 12345678910111213141516var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"]console.log(arr.slice(0)); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"]console.log(arr.slice(1)); // ["John", "Thomas", "James", "Adrew", "Martin"]console.log(arr.slice(1, 3)); // ["John", "Thomas"]console.log(arr.slice(1, -2)); // ["John", "Thomas", "James"]console.log(arr.slice(-1, -2)); // []console.log(arr.slice(-2, -1)); // ["Adrew"]console.log(arr); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"] 3.7 indexOf定义和用法 indexOf()方法可返回某个指定的值在数组中首次出现的位置。从左往右找，找不到返回-1。 语法 arrayObject.indexOf(searchValue, fromIndex) 参数 描述 searchValue 必需。规定需检索的值。 fromIndex 可选的整数参数，开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0 1234567891011121314var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr.indexOf('Thomas')); // 2console.log(arr.indexOf('Thomas', 2)); // 2console.log(arr.indexOf('Thomas', 3)); // -1console.log(arr.indexOf('Thomas', -4)); // 2console.log(arr.indexOf('Thomas', -3)); // -1console.log(arr.indexOf('Peter')); // -1 3.8 lastIndexOf定义和用法 lastIndexOf()方法可返回某个指定的值在数组中首次出现的位置。从右往左找，找不到返回-1。 语法 arrayObject.indexOf(searchValue, fromIndex) 参数 描述 searchValue 必需。规定需检索的值。 fromIndex 可选的整数参数，从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找 123456789101112131415var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr.lastIndexOf('Thomas')); // 2console.log(arr.lastIndexOf('Thomas', 2)); // 2console.log(arr.lastIndexOf('Thomas', 3)); // 2console.log(arr.lastIndexOf('Thomas', 1)); // -1console.log(arr.lastIndexOf('Thomas', -4)); // 2console.log(arr.lastIndexOf('Thomas', -3)); // 2console.log(arr.lastIndexOf('Peter')); // -1 3.9 sort定义和用法 sort()方法用于对数组的元素进行排序。 语法 arrayObject.sort(sortby) 参数 描述 sortby 可选。规定排序顺序。必须是函数。 返回值 对数组的引用。请注意，数组在原数组上进行排序，不生成副本。 说明 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说的更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以方便比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b，其返回值如下： 若a小于b，在排序后的数组中a应该出现在b之前，则返回一个小于0的值。 若a等于b，则返回0。 若a大于b，则返回一个大于0的值。 即顺序 return a - b; 倒序 return b - a; a在b前返回负数，a在b后返回正数 1234567891011var arr = new Array(6);arr[0] = "10";arr[1] = "5";arr[2] = "40";arr[3] = "25";arr[4] = "1000";arr[5] = "1";console.log(arr); // ["10", "5", "40", "25", "1000", "1"]console.log(arr.sort()); // ["1", "10", "1000", "25", "40", "5"]console.log(arr); // ["1", "10", "1000", "25", "40", "5"] 1234567891011121314151617181920var arr = new Array(6);arr[0] = "10";arr[1] = "5";arr[2] = "40";arr[3] = "25";arr[4] = "1000";arr[5] = "1";function orderNumber (a, b) &#123; return a - b;&#125;function descOrderNumber (a, b) &#123; return b - a;&#125;console.log(arr); // ["10", "5", "40", "25", "1000", "1"]console.log(arr.sort(orderNumber)); // ["1", "5", "10", "25", "40", "1000"]console.log(arr.sort(descOrderNumber)); // ["1000", "40", "25", "10", "5", "1"]console.log(arr); // ["1000", "40", "25", "10", "5", "1"] 3.10 splice定义和用法 splice()方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。 语法 arrayObject.splice(index, howmany, item1, ……, itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为0，则不会删除项目。 item1,……,itemX 可选。向数组添加的新项目。 返回值 类型 描述 Array 包含被删除项目的新数组，如果有的话。 说明 splice()方法可删除从index处开始的0个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从arrayObject中删除了元素，则返回的是含有被删除的元素的数组。 12345678910111213var arr = new Array(6);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";arr[3] = "James";arr[4] = "Adrew";arr[5] = "Martin";console.log(arr); // ["Geroge", "John", "Thomas", "James", "Adrew", "Martin"] console.log(arr.splice(1, 1, 'Peter', 'Sara')); // ["John"]console.log(arr); // ["Geroge", "Peter", "Sara", "Thomas", "James", "Adrew", "Martin"]console.log(arr.splice(1, 0, 'Ella')); // []console.log(arr); // ["Geroge", "Ella", "Peter", "Sara", "Thomas", "James", "Adrew", "Martin"] 3.11 toString定义和用法 toString()方法可把数组转换为字符串，并返回结果。 语法 arrayObject.toString() 返回值 arrayObject的字符串表示。返回值与没有参数的join()方法返回的字符串相同。 说明 当数组用于字符串环境时，JavaScript会调用这一方法将数组自动转换成字符串。但是在某些情况下，需要显式地调用该方法。 1234567var arr = new Array(4);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr[3] = 20;console.log(arr.toString()); // "Geroge,John,Thomas,20" 3.12 toLocaleString定义和用法 toLocaleString()方法可把数组转换为本地字符串，并返回结果。 语法 arrayObject.toLocaleString() 返回值 arrayObject的本地字符串表示。 说明 首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。 1234567var arr = new Array(4);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr[3] = 20;console.log(arr.toLocaleString()); // "Geroge,John,Thomas,20" 3.13 valueOf定义和用法 valueOf()方法返回Array对象的原始值。该原始值由Array对象派生的所有对象继承。valueOf(）方法通常由JavaScript在后台自动调用，并不显式地出现在代码中。 语法 arrayObject.valueOf() 1234567var arr = new Array(4);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr[3] = 20;console.log(arr.valueOf()); // ["Geroge", "John", "Thomas", 20] 3.14 forEach定义和用法 forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。forEach()对于空数组是不会执行回调函数的。 语法 arrayObject.forEach(function (value, index, arr) {}, thisValue) 参数 描述 function(currentValue, index, arr) 必需。数组中每个元素需要调用的函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。 thisValue 可选。传递给函数的值一般用’this’值。如果这个参数为空，严格模式下把’undefined’会传递给’this’值，普通模式下传入’window’。 123456789101112131415161718var arr = new Array(3);arr[0] = "Geroge";arr[1] = "John";arr[2] = "Thomas";arr.forEach(function (value, index, arr) &#123; console.log(value); // "Geroge" "John" "Thomas" console.log(index); // 0 1 2 console.log(arr); // ["Geroge", "John", "Thomas"] console.log(this); // window&#125;);arr.forEach(function (value, index, arr) &#123; console.log(value); // "Geroge" "John" "Thomas" console.log(index); // 0 1 2 console.log(arr); // ["Geroge", "John", "Thomas"] console.log(this); // ["Geroge", "John", "Thomas"]&#125;, arr); 3.15 concat定义和用法 concat()方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 语法 arrayObject.concat(arrayX,arrayX,……,arrayX) 参数 描述 arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 返回值 返回一个新的数组。该数组是通过把所有arrayX参数添加到arrayObject中生成的。如果要进行concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。 123var a = [1, 2, 3];console.log(a.concat(4, 5, [6, 7], 8, 9)); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 3.16 every定义和用法 every()方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。every()方法使用指定函数检测数组中的所有元素： 如果数组中检测到有一个元素不满足，则整个表达式返回false，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回true。 注意：every()不会对空数组进行检测。注意：every()不会改变原始数组。 语法 arrayObject.every(function (currentValue, index, arr) {}, thisValue) 参数 描述 function (currentValue, index, arr) 必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。 thisValue 可选。对象作为该执行回调时使用，传递给函数。 说明 有一个返回false，则整个every()返回值为false，并且不会执行后续其他项的回调函数。空数组的every()直接返回true。 1234567891011121314var ages = [10, 20, 24, 32, 40];var result = ages.every(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // falseages = [];result = ages.every(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // true 3.17 some定义和用法 some()方法用于检测数组所有元素是否满足指定条件（通过函数提供）。every()方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true，剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 注意：some()不会对空数组进行检测。注意：some()不会改变原始数组。 语法 arrayObject.some(function (currentValue, index, arr) {}, thisValue) 参数 描述 function (currentValue, index, arr) 必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。 thisValue 可选。对象作为该执行回调时使用，传递给函数。 说明 有一个返回true，则整个some()返回值为true，并且不会执行后续其他项的回调函数。空数组的some()直接返回false。 1234567891011121314var ages = [10, 20, 24, 32, 40];var result = ages.some(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // trueages = [];result = ages.some(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // false 3.18 filter定义和用法 filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意：filter()不会对空数组进行检测。注意：filter()不会改变原始数组。 语法 arrayObject.filter(function (currentValue, index, arr) {}, thisValue) 参数 描述 function (currentValue, index, arr) 必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。 thisValue 可选。对象作为该执行回调时使用，传递给函数。 说明 将所有返回true的数组项取出来组成一个新的数组。 123456789101112131415var ages = [10, 20, 24, 32, 40];var result = ages.filter(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // [32, 40]console.log(ages); // [10, 20, 24, 32, 40]ages = [];result = ages.filter(function (value, index, arr) &#123; return value &gt; 25;&#125;);console.log(result); // [] 3.19 reverse定义和用法 reverse()方法用于颠倒数组中元素的顺序。会改变原数组。 语法 arrayObject.reverse() 12345678var arr = new Array(3);arr[0] = "George";arr[1] = "John";arr[2] = "Thomas";console.log(arr); // ["Geroge", "John", "Thomas"]console.log(arr.reverse()); // ["Thomas", "John", "Geroge"]console.log(arr); // ["Thomas", "John", "Geroge"] 3.20 map定义和用法 map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map()方法按照原始数组元素顺序依次处理元素。 注意：map()不会对空数组进行检测。注意：map()不会改变原始数组。 语法 arrayObject.map(function (currentValue, index, arr) {}, thisValue) 参数 描述 function (currentValue, index, arr) 必需。函数，数组中的每个元素都会执行这个函数。currentValue: 必需。当前元素。index: 可选。当前元素的索引值。arr: 可选。当前元素所属的数组对象。 thisValue 可选。对象作为该执行回调时使用，传递给函数。 12345678var numbers = [65, 20, 11, 5];var arr = numbers.map(function (value, index, arr) &#123; return value * 2;&#125;)console.log(numbers); // [65, 20, 11, 5]console.log(arr); // [130, 40, 22, 10] 3.21 reduce定义和用法 reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 注意：reduce()对于空数组是不会执行回调函数的。 语法 arrayObject.reduce(function (total, currentValue, currentIndex, arr) {}, initialValue) 参数 描述 function (total, currentValue, currentIndex, arr) 必需。函数，数组中的每个元素都会执行这个函数。total: 必需。初始值，或者计算结束后的返回值。currentValue: 必需。当前元素。currentIndex: 可选。当前元素的索引。arr: 可选。当前元素所属的数组对象。 initialValue 可选。传递给函数的初始值。 12345678910111213141516171819var numbers = [15, 2, 1, 7];var total = numbers.reduce(function (total, currentValue) &#123; console.log(total); // 15 17 18 25 console.log(currentValue); // 2 1 7 return total + currentValue;&#125;);console.log(total); // 25console.log(numbers); // [15, 2, 1, 7]total = numbers.reduce(function (total, currentValue) &#123; console.log(total); // 20 35 37 38 45 console.log(currentValue); // 15 2 1 7 return total + currentValue;&#125;, 20);console.log(total); // 45console.log(numbers); // [15, 2, 1, 7] 3.22 reduceRight定义和用法 reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。 注意：reduceRight()对于空数组是不会执行回调函数的。 语法 arrayObject.reduceRight(function (total, currentValue, currentIndex, arr) {}, initialValue) 参数 描述 function (total, currentValue, currentIndex, arr) 必需。函数，数组中的每个元素都会执行这个函数。total: 必需。初始值，或者计算结束后的返回值。currentValue: 必需。当前元素。currentIndex: 可选。当前元素的索引。arr: 可选。当前元素所属的数组对象。 initialValue 可选。传递给函数的初始值。 12345678910111213141516171819var numbers = [15, 2, 1, 7];var total = numbers.reduceRight(function (total, currentValue) &#123; console.log(total); // 7 8 10 25 console.log(currentValue); // 1 2 15 return total + currentValue;&#125;);console.log(total); // 25console.log(numbers); // [15, 2, 1, 7]total = numbers.reduceRight(function (total, currentValue) &#123; console.log(total); // 20 27 28 30 45 console.log(currentValue); // 7 1 2 15 return total + currentValue;&#125;, 20);console.log(total); // 45console.log(numbers); // [15, 2, 1, 7] 三、结束本文会同步到我的个人博客，完整代码可以到我的github仓库查看，如果对你有帮助的话欢迎点一个Star~~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript异步编程]]></title>
    <url>%2F2018%2F07%2F20%2Fjavascript_asynchronous_programming%2F</url>
    <content type="text"><![CDATA[前言从我们一开始学习JavaScript的时候就听到过一段话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。 但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。 本文也会同步到我的个人网站。 正文Step1 - 回调函数回调函数大家肯定都不陌生，从我们写一段最简单的定时器开始：123setTimeout(function () &#123; console.log('Time out');&#125;, 1000); 定时器里面的匿名函数就是一个回调函数，因为在JS中函数是一等公民，所以它可以像其他变量一样作为参数进行传递。这样看来，通过回调函数来处理异步挺好的，写着也顺手，为什么要用别的方法呢？ 我们来看这样一个需求： 上面是微信小程序的登录时序图，我们的需求和它类似但又有些差别，想要获取一段业务数据，整个过程分为3步： 调用秘钥接口，获取key 携带key调用登录接口，获取token和userId 携带token和userId调用业务接口，获取数据 可能上述步骤和实际业务中的有些出入，但是却可以用来说明问题，请大家谅解。 我们写一段代码来实现上述需求： 123456789101112131415161718192021222324252627282930313233343536373839404142let key, token, userId;$.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; key = data; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; token = data.token; userId = data.userId; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: token, userId: userId &#125;, success: function (data) &#123; console.log('业务数据：', data); &#125;, error: function (err) &#123; console.log(err); &#125; &#125;); &#125;, error: function (err) &#123; console.log(err); &#125; &#125;); &#125;, error: function (err) &#123; console.log(err); &#125;&#125;); 可以看到，整段代码充满了回调嵌套，代码不仅在纵向扩展，横向也在扩展。我相信，对于任何人来说，调试起来都会很困难，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以查看流程，而最终的结果藏在整段代码的中间位置。真实的JavaScript程序代码可能要混乱的多，使得这种追踪难度会成倍增加。这就是我们常说的回调地狱（Callback Hell）。 为什么会出现这种现象？ 如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，我们还采用回调的方式来处理异步的话，就会出现回调地狱。 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码的难度很大，很容易产生Bug。 这里我们引出了回调函数解决异步的第1个问题：回调地狱。 回调函数还会存在别的问题吗？让我们再深入思考一下回调的概念：12345678// A$.ajax(&#123; ... success: function (...) &#123; // C &#125;&#125;);// B A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。 但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。 这种情况称为控制反转，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。 既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的： 调用回调过早 调用回调过晚 调用回调次数太多或者太少 未能把所需的参数成功传给你的回调函数 吞掉可能出现的错误或异常 …… 这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。 这里，我们引出了回调函数处理异步的第二个问题：控制反转。 综上，回调函数处理异步流程存在2个问题： 1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符2. 缺乏可信任性： 控制反转导致的一系列信任问题 那么如何来解决这两个问题，先驱者们开始了探索之路…… Step2 - Promise开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转。 至于Promise是什么，大家肯定都有所了解，这里是PromiseA+规范，ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，它是一种规范，是一套处理JavaScript异步的机制。 我们把上面那个多层回调嵌套的例子用Promise的方式重构：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970let getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; let key = data; resolve(key); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getDataPromise = function (data) &#123; let token = data.token; let userId = data.userId; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: token, userId: userId &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;getKeyPromise() .then(function (key) &#123; return getTokenPromise(key); &#125;) .then(function (data) &#123; return getDataPromise(data); &#125;) .then(function (data) &#123; console.log('业务数据：', data); &#125;) .catch(function (err) &#123; console.log(err); &#125;); 可以看到，Promise在一定程度上其实改善了回调函数的书写方式，最明显的一点就是去除了横向扩展，无论有再多的业务依赖，通过多个then(…)来获取数据，让代码只在纵向进行扩展；另外一点就是逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。 所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。 这里我想主要讨论的是，Promise是如何解决控制反转带来的信任缺失问题。 首先明确一点，Promise可以保证以下情况，引用自JavaScript | MDN： 在JavaScript事件队列的当前运行完成之前，回调函数永远不会被调用 通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用 通过多次调用 .then，可以添加多个回调函数，它们会按照插入顺序并且独立运行 下面我们针对前面提过的回调函数处理异步导致的一系列信任问题来讨论，如果是用Promise来处理，是否还会存在这些问题，当然前提是实现的Promise完全遵循PromiseA+规范。 调用过早当使用回调函数的时候，我们无法保证或者不知道第三方对于回调函数的调用是何种形式的，如果它在某种情况下是立即完成以同步的方式来调用，那可能就会导致我们代码中的逻辑错误。 但是，根据PromiseA+规范，Promise就不必担心这种问题，因为即使是立即完成的Promise（类似于new Promise(function (resolve, reject) {resolve(2);})），也无法被同步观察到。 也就是说，对一个Promise调用then(…)的时候，即使这个Promise已经决议，提供给then(…)的回调也总会在JavaScript事件队列的当前运行完成后，再被调用，即异步调用。 调用过晚当Promise创建对象调用resolve(…)或reject(…)时，这个Promise通过then(…)注册的回调函数就会在下一个异步时间点上被触发。 并且，这个Promise上的多个通过then(…)注册的回调都会在下一个异步时间点上被依次调用，这些回调中的任意一个都无法影响或延误对其他回调的调用。 举例如下：1234567891011p.then(function () &#123; p.then(function () &#123; console.log('C'); &#125;); console.log('A');&#125;).then(funtion () &#123; console.log('B');&#125;);// 打印 A B C 通过这个例子可以看到，C无法打断或抢占B，所以Promise没有调用过晚的现象，只要你注册了then(…)，就肯定会按顺序依次调用，因为这就是Promise的运作方式。 回调未调用没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议（如果它决议了的话）。如果你对一个Promise注册了一个成功回调和拒绝回调，那么Promise在决议的时候总会调用其中一个。 当然，如果你的回调函数本身包含JavaScript错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。 123456p.then(function (data) &#123; console.log(data); foo.bar(); // 这里没有定义foo，所以这里会报Type Error, foo is not defined&#125;, function (err) &#123;&#125;); 调用次数太多或者太少根据PromiseA+规范，回调被调用的正确次数应该是1次。“太少”就是不调用，前面已经解释过了。 “太多”的情况很容易解释，Promise的定义方式使得它只能被决议一次。如果处于多种原因，Promise创建代码试图调用多次resolve(…)或reject(…)，或者试图两者都调用，那么这个Promise将只会接受第一次决议，并默默忽略任何后续调用。 由于Promise只能被决议一次，所以任何通过then(…)注册的回调就只会被调用一次。 未能传递参数值如果你没有把任何值传递给resolve(…)或reject(…)，那么这个值就是undefined。但不管这个值是什么，它都会被传给所有注册在then(…)中的回调函数。 如果使用多个参数调用resolve(…)或reject(…)，那么第一个参数之后的所有参数都会被忽略。如果要传递多个值，你就必须把它们封装在单个值中进行传递，比如一个数组或对象。 吞掉可能出现的错误或异常如果在Promise的创建过程中或在查看其决议结果的过程中的任何时间点上，出现了一个JavaScript异常错误，比如一个TypeError或ReferenceError，这个异常都会被捕捉，并且会使这个Promise被拒绝。 举例如下：12345678910var p = new Promise(function (resolve, reject) &#123; foo.bar(); // foo未定义 resolve(2);&#125;);p.then(function (data) &#123; console.log(data); // 永远也不会到达这里&#125;, function (err) &#123; console.log(err); // err将会是一个TypeError异常对象来自foo.bar()这一行&#125;); foo.bar()中发生的JavaScript异常导致了Promise的拒绝，你可以捕捉并对其作出响应。 不是所有的thenable都可以信任到目前为止，我们讨论了使用Promise可以避免上述多种由控制反转导致的信任问题。但是，你肯定也注意到了，Promise并没有完全摆脱回调，它只是改变了传递回调的位置。我们并不是把回调传递给foo(…)让第三方去执行，而是从foo(…)得到某个东西（Promise对象），然后把回调传递给这个东西。 但是，为什么这就比单纯使用回调更值得信任呢？如何能够确定返回的这个东西实际上就是一个可信任的Promise呢？ Promise对于这个问题已经有了解决方案，ES6实现的Promise的解决方案就是Promise.resolve(…)。 如果向Promise.resolve(…)传递一个非Promise，非thenable得立即值，就会得到一个用这个值填充的Promise。 举例如下：1234567var p1 = new Promise(function (resolve, reject) &#123; resolve(2);&#125;);var p2 = Promise.resolve(2);// 这里p1和p2的效果是一样的 而如果向Promise.resolve(…)传递一个真正的Promise，就只会返回同一个Promise。 1234var p1 = Promise.resolve(2);var p2 = Promise.resolve(p1);p1 === p2; // true 更重要的是，如果向Promise.resolve(…)传递了一个非Promise的thenable值，前者就会试图展开这个值，而且展开过程中会持续到提取出一个具体的非类Promise的最终值。 举例如下：12345678910111213var p = &#123; then: function (cb, errCb) &#123; cb(2); errCb('haha'); &#125;&#125;;// 这可以工作，因为函数是一等公民，可以当做参数进行传递p.then(function (data) &#123; console.log(data); // 2&#125;, function (err) &#123; console.log(err); // haha&#125;); 这个p是一个thenable，但不是一个真正的Promise，其行为和Promise并不完全一致，它同时触发了成功回调和拒绝回调，它是不可信任的。 尽管如此，我们还是都可以把这样的p传给Promise.resolve(…)，然后就会得到期望中的规范化后的安全结果：123456Promise.resolve(p) .then(function (data) &#123; console.log(data); // 2 &#125;, function (err) &#123; console.log(err); // 永远不会到达这里 &#125;); 因为前面讨论过，一个Promise只接受一次决议，如果多次调用resolve(…)或reject(…)，后面的会被自动忽略。 Promise.resolve(…)可以接受任何thenable，将其解封为它的非thenable值。从Promise.resolve(…)得到的是一个真正的Promise，是一个可以信任的值。如果你传入的已经是真正的Promise，那么你得到的就是它本身，所以通过Promise.resolve(…)过滤来获得可信任性完全没有坏处。 综上，我们明确了，使用Promise处理异步可以解决回调函数控制反转带来的一系列信任问题。很好，我们又向前迈了一步。 Step3 - 生成器Gererator在Step1中，我们确定了用回调表达异步流程的两个关键问题： 基于回调的异步不符合大脑对任务步骤的规范方式 由于控制反转，回调并不是可信任的 在Step2中，我们详细介绍了Promise是如何把回调的控制反转又反转过来，恢复了可信任性。 现在，我们把注意力转移到一种顺序、看似同步的异步流程控制表达风格，这就是ES6中的生成器（Gererator）。 可迭代协议和迭代器协议了解Generator之前，必须先了解ES6新增的两个协议：可迭代协议和迭代器协议。 可迭代协议可迭代协议运行JavaScript对象去定义或定制它们的迭代行为，例如（定义）在一个for…of结构中什么值可以被循环（得到）。以下内置类型都是内置的可迭代对象并且有默认的迭代行为： Array Map Set String TypedArray 函数的Arguments对象 NodeList对象 注意，Object不符合可迭代协议。 为了变成可迭代对象，一个对象必须实现@@iterator方法，意思是这个对象（或者它原型链prototype chain上的某个对象）必须有一个名字是Symbol.iterator的属性： 属性 值 [Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议 当一个对象需要被迭代的时候（比如开始用于一个for…of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。 迭代器协议迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值。当一个对象被认为是一个迭代器时，它实现了一个next()的方法并且拥有以下含义：| 属性 | 值 ||——|—|| next | 返回一个对象的无参函数，被返回对象拥有两个属性： 1. done（boolean） - 如果迭代器已经经过了被迭代序列时为true。这时value可能描述了该迭代器的返回值 - 如果迭代器可以产生序列中的下一个值，则为false。这等效于连同done属性也不指定。 2. value - 迭代器返回的任何JavaScript值。done为true时可以忽略。 | 使用可迭代协议和迭代器协议的例子：123456789101112131415161718var str = 'hello';// 可迭代协议使用for...of访问typeof str[Symbol.iterator]; // 'function'for (var s of str) &#123; console.log(s); // 分别打印 'h'、'e'、'l'、'l'、'o'&#125;// 迭代器协议next方法var iterator = str[Symbol.iterator]();iterator.next(); // &#123;value: "h", done: false&#125;iterator.next(); // &#123;value: "e", done: false&#125;iterator.next(); // &#123;value: "l", done: false&#125;iterator.next(); // &#123;value: "l", done: false&#125;iterator.next(); // &#123;value: "o", done: false&#125;iterator.next(); // &#123;value: undefined, done: true&#125; 我们自己实现一个对象，让其符合可迭代协议和迭代器协议：1234567891011121314151617181920212223242526var something = (function () &#123; var nextVal; return &#123; // 可迭代协议，供for...of消费 [Symbol.iterator]: function () &#123; return this; &#125;, // 迭代器协议，实现next()方法 next: function () &#123; if (nextVal === undefined) &#123; nextVal = 1; &#125; else &#123; nextVal = (3 * nextVal) + 6; &#125; return &#123;value: nextVal, done: false&#125;; &#125; &#125;;&#125;)();something.next().value; // 1something.next().value; // 9something.next().value; // 33something.next().value; // 105 用Generator实现异步如果我们用Generator改写上面回调嵌套的例子会是什么样的呢？见代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function getKey () &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; key = data; it.next(key); &#125; error: function (err) &#123; console.log(err); &#125; &#125;);&#125;function getToken (key) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; loginData = data; it.next(loginData); &#125; error: function (err) &#123; console.log(err); &#125; &#125;);&#125;function getData (loginData) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: loginData.token, userId: loginData.userId &#125;, success: function (busiData) &#123; it.next(busiData); &#125; error: function (err) &#123; console.log(err); &#125; &#125;);&#125;function *main () &#123; let key = yield getKey(); let LoginData = yield getToken(key); let busiData = yield getData(loginData); console.log('业务数据：', busiData);&#125;// 生成迭代器实例var it = main();// 运行第一步it.next();console.log('不影响主线程执行'); 我们注意*main()生成器内部的代码，不看yield关键字的话，是完全符合大脑思维习惯的同步书写形式，把异步的流程封装到外面，在成功的回调函数里面调用it.next()，将传回的数据放到任务队列里进行排队，当JavaScript主线程空闲的时候会从任务队列里依次取出回调任务执行。 如果我们一直占用JavaScript主线程的话，是没有时间去执行任务队列中的任务：12345// 运行第一步it.next();// 持续占用JavaScript主线程while(1) &#123;&#125;; // 这里是拿不到异步数据的，因为没有机会去任务队列里取任务执行 综上，生成器Generator解决了回调函数处理异步流程的第一个问题：不符合大脑顺序、线性的思维方式。。 Step4 - Async/Await上面我们介绍了Promise和Generator，把这两者结合起来，就是Async/Await。 Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。 我们把最开始的例子用Async/Await的方式改写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let getKeyPromise = function () &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/apiKey', success: function (data) &#123; let key = data; resolve(key); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getTokenPromise = function (key) &#123; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getToken', data: &#123; key: key &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;let getDataPromise = function (data) &#123; let token = data.token; let userId = data.userId; return new Promsie(function (resolve, reject) &#123; $.ajax(&#123; type: 'get', url: 'http://localhost:3000/getData', data: &#123; token: token, userId: userId &#125;, success: function (data) &#123; resolve(data); &#125;, error: function (err) &#123; reject(err); &#125; &#125;); &#125;);&#125;;async function main () &#123; let key = await getKeyPromise(); let loginData = await getTokenPromise(key); let busiData = await getDataPromise(loginData); console.log('业务数据：', busiData);&#125;main();console.log('不影响主线程执行'); 可以看到，使用Async/Await，完全就是同步的书写方式，逻辑和数据依赖都非常清楚，只需要把异步的东西用Promise封装出去，然后使用await调用就可以了，也不需要像Generator一样需要手动控制next()执行。 Async/Await是Generator和Promise的组合，完全解决了基于回调的异步流程存在的两个问题，可能是现在最好的JavaScript处理异步的方式了。 总结本文通过四个阶段来讲述JavaScript异步编程的发展历程： 第一个阶段 - 回调函数，但会导致两个问题: 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 缺乏可信任性： 控制反转导致的一系列信任问题 第二个阶段 - Promise，Promise是基于PromiseA+规范的实现，它很好的解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来。 第三个阶段 - 生成器函数Generator，使用Generator，可以让我们用同步的方式来书写代码，解决了顺序性的问题，但是需要手动去控制next(…)，将回调成功返回的数据送回JavaScript主流程中。 第四个阶段 - Async/Await，Async/Await结合了Promise和Generator，在await后面跟一个Promise，它会自动等待Promise的决议值，解决了Generator需要手动控制next(…)执行的问题，真正实现了用同步的方式书写异步代码。 我们可以看到，每项技术的突破都是为了解决现有技术存在的一些问题，它是循序渐进的，我们在学习的过程中，要真正去理解这项技术解决了哪些痛点，它为什么会存在，这样会有益于我们构建体系化的知识，同时也会更好的去理解这门技术。 最后，希望大家可以通过这篇文章对JavaScript异步编程有一个更宏观的体系化的了解，我们一起进步。 参考： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>异步编程</tag>
        <tag>Promise</tag>
        <tag>Generator</tag>
        <tag>Async/Await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看图学HTTPS]]></title>
    <url>%2F2018%2F05%2F21%2Flearn_https_through_photos%2F</url>
    <content type="text"><![CDATA[前言之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。 我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。 本文也会同步到我的个人网站。 正文HTTP是什么样的？HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述： 客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。 加个密呢？因为上图中数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密，如下图： 这种加密方式叫做：对称加密。加密和解密用同一个秘钥的加密方式叫做对称加密。 好了，我们对数据进行加密了，问题解决了吗？ 多个客户端怎么办？这是一个客户端，但是在WWW上，是成千上万的客户端，情况会怎样呢？ 为所有的客户端都应用同一个秘钥A，这种方式很显然是不合理的，破解了一个用户，所有的用户信息都会被盗取。 想一想，是不是还有别的办法呢？ 相信大家都可以想到，如果对每一个客户端都用不同的秘钥进行传输是不是就解决这个问题了： 对称加密秘钥如何传输？我们对每个客户端应用不同的对称加密秘钥，那么这个秘钥客户端或者服务端是如何知道的呢，只能是在一端生成一个秘钥，然后通过HTTP传输给另一端： 那么这个传输秘钥的过程，又如何保证加密？如果被中间人拦截，秘钥也会被获取。也许你会说，对秘钥再进行加密，那又如何保证对秘钥加密的过程，是加密的呢？ 好像我们走入了 while(1)，出不来了。 非对称加密在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫非对称加密，比如RSA。非对称加密会有一对秘钥：公钥和私钥。公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。 私钥只保存在服务器端，公钥可以发送给所有的客户端。 在传输公钥的过程中，肯定也会有被中间人获取的风险，但在目前的情况下，至少可以保证客户端通过公钥加密的内容，中间人是无法破解的，因为私钥只保存在服务器端，只有私钥可以破解公钥加密的内容。 现在我们还存在一个问题，如果公钥被中间人拿到篡改呢： MITM：Man-in-the-MiddleAttack 客户端拿到的公钥是假的，如何解决这个问题？ 第三方认证公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。 在HTTPS中，使用 证书 + 数字签名 来解决这个问题。 这里假设加密方式是MD5，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名。 数字证书 = 网站信息 + 数字签名 假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。 浏览器安装后会内置一些权威第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等，验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。 为什么要有签名？大家可以想一下，为什么要有数字签名这个东西呢？ 第三方认证机构是一个开放的平台，我们可以去申请，中间人也可以去申请呀： 如果没有签名，只对网站信息进行第三方机构私钥加密的话，会存在下面的问题： 因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。 对称加密在安全的拿到服务器的公钥之后，客户端会随机生成一个对称秘钥，使用服务器公钥加密，传输给服务端，此后，相关的 Application Data 就通过这个随机生成的对称秘钥进行加密/解密，服务器也通过该对称秘钥进行解密/加密： 整体流程图HTTPS = HTTP + TLS/SSL HTTPS中具体的内容还有很多，可以通过下图做一个参考： 总结HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。 参考文章https://en.wikipedia.org/wiki/HTTPShttps://www.instantssl.com/https-tutorials/what-is-https.htmlhttps://tasaid.com/blog/20161003001126.htmlhttps://www.west.cn/faq/list.asp?unid=1346https://www.cnblogs.com/zhangshitong/p/6478721.htmlhttps://www.wired.com/2016/04/hacker-lexicon-what-is-https-encryption/]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>HTTPS</tag>
        <tag>SSL/TLS</tag>
        <tag>非对称加密</tag>
        <tag>对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊V8引擎的垃圾回收]]></title>
    <url>%2F2018%2F04%2F14%2Fv8_garbage_collection%2F</url>
    <content type="text"><![CDATA[前言我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~ 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 为什么要有垃圾回收在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。 不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。 内存结构分配由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在64位系统下大约为1.4GB，在32位系统下大约为700MB。 在NodeJS环境中，我们可以通过process.memoryUsage()来查看内存分配。 process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，含义如下： 1234567rss（resident set size）：所有内存占用，包括指令区和堆栈heapTotal：V8引擎可以分配的最大堆内存，包含下面的 heapUsedheapUsed：V8引擎已经分配使用的堆内存external： V8管理C++对象绑定到JavaScript对象上的内存 以上所有内存单位均为字节（Byte）。 如果说想要扩大Node可用的内存空间，可以使用Buffer等堆外内存内存，这里不详细说明了，大家有兴趣可以去看一些资料。 下面是Node的整体架构图，有助于大家理解上面的内容： 123456789Node Standard Library: 是我们每天都在用的标准库，如Http, Buffer 模块Node Bindings: 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务第三层是支撑 Node.js 运行的关键，由 C/C++ 实现：1. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机2. Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力3. C-ares：提供了异步处理 DNS 相关的能力4. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力 垃圾回收机制1. 如何判断是否可以回收1.1 标记清除当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。 （1）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。 （2）然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记 （3）此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。 （4）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 活动对象就是上面的root，如果不清楚活动对象的可以先查一下资料，当一个对象和其关联对象不再通过引用关系被当前root引用了，这个对象就会被垃圾回收。 1.2 引用计数引用计数的垃圾收集策略不太常见。含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。 如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。 当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。 循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用，看个例子：1234567function foo () &#123; var objA = new Object(); var objB = new Object(); objA.otherObj = objB; objB.anotherObj = objA;&#125; 这个例子中，objA和objB通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2。 在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是问题。 但在采用引用次数策略的实现中，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0。 加入这个函数被重复多次调用，就会导致大量内存无法回收。为此，Netscape在Navigator 4.0中也放弃了引用计数方式，转而采用标记清除来实现其垃圾回收机制。 还要注意的是，我们大部分人时刻都在写着循环引用的代码，看下面这个例子，相信大家都这样写过：1234var el = document.getElementById('#el');el.onclick = function (event) &#123; console.log('element was clicked');&#125; 我们为一个元素的点击事件绑定了一个匿名函数，我们通过event参数是可以拿到相应元素el的信息的。 大家想想，这是不是就是一个循环引用呢？el有一个属性onclick引用了一个函数（其实也是个对象），函数里面的参数又引用了el，这样el的引用次数一直是2，即使当前这个页面关闭了，也无法进行垃圾回收。 如果这样的写法很多很多，就会造成内存泄露。我们可以通过在页面卸载时清除事件引用，这样就可以被回收了：123456789101112var el = document.getElementById('#el');el.onclick = function (event) &#123; console.log('element was clicked');&#125;// ...// ...// 页面卸载时将绑定的事件清空window.onbeforeunload = function()&#123; el.onclick = null;&#125; V8垃圾回收策略自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。 所以，V8采用了一种代回收的策略，将内存分为两个生代：新生代（new generation）和老生代（old generation）。 新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升，后面我会详细说明。 分代内存默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。 新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。 新生代1. 分配方式新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。 2. 算法新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。 Cheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。 处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。 我画了一套详细的流程图，接下来我会结合流程图来详细说明Cheney算法是怎么工作的。垃圾回收在下面我统称为 GC（Garbage Collection）。 step1. 在From空间中分配了3个对象A、B、C step2. GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象 step3. 将活跃对象A、C从From空间复制到To空间 step4. 清空From空间的全部内存 step5. 交换From空间和To空间 step6. 在From空间中又新增了2个对象D、E step7. 下一轮GC进来发现对象D没有引用了，做标记 step8. 将活跃对象A、C、E从From空间复制到To空间 step9. 清空From空间全部内存 step10. 继续交换From空间和To空间，开始下一轮 通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。 由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。 3. 晋升当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。 对象从新生代移动到老生代的过程叫作晋升。 对象晋升的条件主要有两个： 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。 当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。 老生代1. 介绍在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题： 由于存活对象较多，复制存活对象的效率会很低。 采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。 所以，V8在老生代中主要采用了Mark-Sweep和Mark-Sweep相结合的方式进行垃圾回收。 2. Mark-SweepMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。 与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。 也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。 我们还是通过流程图来看一下： step1. 老生代中有对象A、B、C、D、E、F step2. GC进入标记阶段，将A、C、E标记为存活对象 step3. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间 可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。 如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 2. Mark-Compact为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。 Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示： step1. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样） step2. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样） step3. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间 step4. GC进入清除阶段，将边界另一侧的内存一次性全部回收 3. 两者结合在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。 由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。 总结V8的垃圾回收机制分为新生代和老生代。 新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。 老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。 以上就是本文的全部内容，书写过程中参考了很多中外文章，参考书籍包括朴大大的《深入浅出NodeJS》以及《JavaScript高级程序设计》等。我们这里并没有对具体的算法实现进行探讨，感兴趣的朋友可以继续深入研究一下。 最后，谢谢大家能够读到这里，如果文中有任何不明确或错误的地方，欢迎给我留言~~ 参考链接https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8http://alinode.aliyun.com/blog/14http://www.ruanyifeng.com/blog/2017/04/memory-leak.htmlhttps://segmentfault.com/a/1190000000440270]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>V8</tag>
        <tag>垃圾回收</tag>
        <tag>Scavenge</tag>
        <tag>Mark-Sweep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾调用和尾递归]]></title>
    <url>%2F2018%2F04%2F10%2Ftail_call%2F</url>
    <content type="text"><![CDATA[尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: , 依次举例：123const a = x =&gt; x ? f() : g();// f() 和 g() 都在尾部。 12345678910111213141516const a = () =&gt; f() || g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return fResult; &#125; else &#123; return g(); // tail call &#125;&#125;// 只有当f()的结果为falsey的时候，g()才是尾调用 12345678910111213141516const a = () =&gt; f() &amp;&amp; g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return g(); // tail call &#125; else &#123; return fResult; &#125;&#125;// 只有当f()的结果为truthy的时候，g()才是尾调用 12345678910const a = () =&gt; (f() , g());// g()是尾调用// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; f(); return g();&#125; 2. 尾调用优化函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：12345function foo () &#123; console.log(111); &#125;function bar () &#123; foo(); &#125;function baz () &#123; bar(); &#125;baz(); 造成这种结果是因为每个函数在调用另一个函数的时候，并没有 return 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。 baz() 里面调用了 bar() 函数，并没有 return 该调用，所以在调用栈中保持自己的调用帧，同时 bar() 函数的调用帧在调用栈中生成，同理，bar() 函数又调用了 foo() 函数，最后执行到 foo() 函数的时候，没有再调用其他函数，这里没有显示声明 return，所以这里默认 return undefined。 foo() 执行完了，销毁调用栈中自己的记录，依次销毁 bar() 和 baz() 的调用帧，最后完成整个流程。 如果对上面的例子做如下修改：12345function foo () &#123; console.log(111); &#125;function bar () &#123; return foo(); &#125;function baz () &#123; return bar(); &#125;baz(); 这里要注意：尾调用优化只在严格模式下有效。 在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈： func.arguments: 表示对 func最近一次调用所包含的参数 func.caller: 引用对 func最近一次调用的那个函数 在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。 如果尾调用优化生效，流程图就会变成这样： 我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。 这就叫做尾调用优化，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。 尾递归1. 定义先来看一下递归，当一个函数调用自身，就叫做递归。123function foo () &#123; foo();&#125; 上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。 那么什么是尾递归？前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做尾递归。123function foo () &#123; return foo();&#125; 2. 作用那么尾递归相比递归而言，有哪些不同呢？我们通过下面这个求阶乘的例子来看一下：12345678function factorial (num) &#123; if (num === 1) return 1; return num * factorial(num - 1);&#125;factorial(5); // 120factorial(10); // 3628800factorial(500000); // Uncaught RangeError: Maximum call stack size exceeded 上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。 这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。 如果用尾递归来计算阶乘呢？123456789101112131415'use strict';function factorial (num, total) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5, 1); // 120factorial(10, 1); // 3628800factorial(500000, 1); // 分情况// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js// node最新版本已经移除了--harmony_tailcalls功能 通过尾递归，我们把复杂度从O(n)降低到了O(1)，如果数据足够大的话，会节省很多的计算时间。由此可见，尾调用优化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。 避免改写递归函数尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的factorial()函数改写一样。 这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？解决这个问题的办法有两个： 1. ES6参数默认值123456789'use strict';function factorial (num, total = 1) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 2. 用一个符合语义的函数去调用改写后的尾递归函数1234567891011function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;function factorial (num) &#123; return tailFactorial(num, 1);&#125;factorial(5); // 120factorial(10); // 3628800 上面这种写法其实有点类似于做了一个函数柯里化，但不完全符合柯里化的概念。函数柯里化是指把接受多个参数的函数转换为接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数。 概念看着很绕口，我们来个例子感受一下：1234567891011121314151617// 普通加法函数function add (x, y, z) &#123; return x + y + z;&#125;add(1, 2, 3); // 6// 改写为柯里化加法函数function add (x) &#123; return function (y) &#123; return function (z) &#123; return x + y + z; &#125; &#125;&#125;add(1)(2)(3); // 6 可以看到，柯里化函数通过闭包找到父作用域里的变量，最后依次相加输出结果。通过这个例子，可能看不出为什么要用柯里化，有什么好处，这个我们以后再谈，这里先引出一个概念。 是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 如果用柯里化改写求阶乘的例子：12345678910111213141516171819202122232425262728293031323334353637383940// 柯里化函数function curry (fn) &#123; var _fnArgLength = fn.length; function wrap (...args) &#123; var _args = args; var _argLength = _args.length; // 如果传的是所有参数，直接返回fn调用 if (_fnArgLength === _argLength) &#123; return fn.apply(null, args); &#125; function act (...args) &#123; _args = _args.concat(args); if (_args.length === _fnArgLength) &#123; return fn.apply(null, _args); &#125; return act; &#125; return act; &#125; return wrap;&#125;// 尾递归函数function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;// 改写var factorial = curry(tailFactorial);factorial(5)(1); // 120factorial(10)(1); // 3628800 这是符合柯里化概念的写法，在阮一峰老师的文章中是这样写的：1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 我个人认为，这种写法其实不是柯里化，因为并没有将多参数的tailFacrotial改写为接受单参数的形式，只是换了一种写法，和下面这样写意义是一样的：1234567891011function factorial (num) &#123; return tailFactorial(num, 1);&#125;function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 结束这篇文章我们主要讨论了尾调用优化和柯里化。要注意的是，经过测试，Chrome和Firefox并没有对尾调用进行优化，Safari对尾调用进行了优化。Node高版本也已经去除了通过–harmony_tailcalls参数启用尾调用优化。 有任何问题，欢迎大家留言讨论~~ 参考链接http://www.ruanyifeng.com/blog/2015/04/tail-call.htmlhttps://juejin.im/post/5a4d898a518825698e7277d1https://github.com/lamdu/lamdu/issues/90]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>尾调用</tag>
        <tag>尾递归</tag>
        <tag>函数式</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 karma + jasmine 测试环境]]></title>
    <url>%2F2018%2F04%2F03%2Ffront_end_test_karma_jasmine%2F</url>
    <content type="text"><![CDATA[在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。 在 init 时会让你选择一些配置项： test framework我这里选择的是jasmine，它是一款JavaScript断言测试库use Require.js根据个人情况，我选择的是nocapture any browsers automatically选择浏览器，我选择的是无头浏览器PhantomJSlocation of your source files为空any of files included by the previous patterns be excluted为空karma to watch all files and run the tests on change是否监测，我选择的是no 在选择完所有配置项后，会自动生成karma.conf.js配置文件。 根据配置项的选择安装插件（1） 测试框架选择的是jasmine，安装步骤如下：1$ npm install jasmine-core karma-jasmine -D 这里要装两个，一个是jasmine的核心，另一个是karma对jasmine的封装。 （2） 浏览器选择的是PhantomJS，安装步骤如下：1$ npm install karma-phantomjs-launcher -D （3） 如果涉及到对以ES6编写的代码进行测试，就要安装Babel及其相关插件：12$ npm install babel-cli babel-preset-env babel-plugin-transform-es2015-modules-umd -D$ npm install karma-babel-preprocessor -D （4） 安装生成代码覆盖率报告的插件：1$ npm install karma-coverage -D 修改karma配置文件123456789101112131415161718192021222324252627282930// karma.conf.jsmodule.exports = function(config) &#123; config.set(&#123; basePath: '', frameworks: ['jasmine'], files: [ './src/**/*.js', './test/**/*.spec.js' ], exclude: [ ], preprocessors: &#123; './src/**/*.js': ['babel'], './test/**/*.spec.js': ['babel', 'coverage'] &#125;, reporters: ['progress', 'coverage'], coverageReporter: &#123; type: 'html', dir: 'coverage/' &#125;, port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: ['PhantomJS'], singleRun: true, concurrency: Infinity &#125;)&#125; 修改Babel配置文件：123456// .babelrc&#123; "presets": ["env"], "plugins": ["transform-es2015-modules-umd"], "auxiliaryCommentBefore": "istanbul ignore next"&#125; 写测试文件1234567891011// PraiseButton.spec.jsimport PraiseButton from '../src/PraiseButton.js';describe('测试点赞组件', function () &#123; it('addOne() 函数', function () &#123; var testPraiseButton = new PraiseButton(); testPraiseButton.addOne(); expect(testPraiseButton.countNum).toBe(1); &#125;);&#125;); 运行测试1$ karma start 结束按照上述步骤，大家应该可以配置好自己的 karma + jasmine 测试环境，如果遇到问题或者文中有写错的地方，欢迎大家来讨论。文章末尾是需要安装模块的链接，大家可以一键直达。 参考链接karma官网https://karma-runner.github.io/2.0/intro/installation.htmlkarma-clihttps://www.npmjs.com/package/karma-clikarma-jasminehttps://www.npmjs.com/package/karma-jasminejasmine-corehttps://www.npmjs.com/package/jasmine-corekarma-coveragehttps://www.npmjs.com/package/karma-coverage]]></content>
      <categories>
        <category>前端测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>karma</tag>
        <tag>jasmine</tag>
        <tag>phantomJS</tag>
        <tag>Babel</tag>
        <tag>ES6</tag>
        <tag>System</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 07 - 标签声明（Label Statement）]]></title>
    <url>%2F2018%2F03%2F10%2Fjavascript_07_label_statement%2F</url>
    <content type="text"><![CDATA[引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？ 再看一个例子，你也一定见到过这样的写法：12345// 假设str是你通过ajax接收到的JSON串var str = '&#123;"name": "liu", "age": 20&#125;';var obj = eval('(' + str + ')');console.log(obj); 那么，你有没有想过 eval 里面为什么要加上括号呢？如果不加又是什么情况？（提前剧透，不加括号这里会报错哦）。 接着往下看，当你读完这篇文章的时候，心中的疑惑会完全解开。 Label Statement学过C语言的同学知道，C的语法中有一个语句叫：goto，同时老师也多次强调不让我们使用goto语句，因为会大大影响程序的可读性和可维护性。 我们先来看一段C语言的goto代码：12345678910111213void main()&#123; int a=2, b=3; if(a&gt;b) &#123; goto aa; &#125; printf("hello"); aa: printf("s"); return 0;&#125; 当 a &lt; b 的时候，这里会打印字符串 “hello”，然后结束。当 a &gt; b 的时候，由于goto语句的作用，就会跳过 print(“hello”)，直接跳到 aa 标签声明的代码块中，打印字符 “s”，然后结束。 这就是goto语句的作用，通过标签声明一个代码块，然后在任何地方都可以执行 goto ‘labe’ 来进行程序跳转。 显而易见，这样的写法，违背了程序顺序执行的原则，会跳来跳去，最后导致根本无法维护，所以，记住老师的话，不要使用 goto 语句。 那么，看完了C语言中的 goto 语句，和我们的 JavaScript 又有什么关系呢？这就引出了今天的主题：Label Statement，它就是 JS 中的 goto 语句。 用法首先明确一个原则，在JavaScript中，语句优先。也就是说，如果一段代码既能够以语句的方式解析，也能用语法的方式解析，在JS中，会优先按语句来解析。 1&#123; a : 1 &#125; 上面这段代码，在JS中的执行结果是什么呢？大家思考2分钟…. 好，2分钟已过，大家有结果了吗？千万不要在浏览器的控制台中去写这段代码，虽然结果和你开始想的结果一样，但是，它是错误的。 这是在console控制台中执行的结果： 这是在watch中的执行结果： 可以看到两个结果是不一样的。console是经过处理的这里不能相信，watch是直接JS的运行环境执行后的结果，是正确的。 为什么 { a : 1 } 结果会是 1 呢？ 我换一个写法：123&#123; a : 1&#125; 相信有的同学已经明白了，在JS中，{}既可以代表代码块，又可以作为Object的语法标志。那么我们前面说过，JS是语句优先的，当一段代码既可以按照语句解析，又可以按照语法解析的时候，会优先按语句解析。 当把{}当做是代码块的时候，里面的 a : 1，是不是很像C语言goto语句的标签声明呢？开头我们提出的第一个问题，如果用这种方式来解决，代码如下：1234567891011aa : &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) break aa; &#125; &#125;&#125;console.log('done'); aa是标签声明，包裹一个代码块，break 的作用是跳出当前的循环，本来是无法跳出外面那层for循环的，但是 break aa，这里跳出了整个代码块。 当然，这种写法是完全不提倡的，这里只是用来说明JS中的Label Statement这个特性，大家千万不要这样写代码。 再来看开头提出的第二个问题：12345// 假设str是你通过ajax接收到的JSON串var str = '&#123;"name": "liu", "age": 20&#125;';var obj = eval('(' + str + ')');console.log(obj); 我们知道，eval(str)会把接收到的字符串在当前上下文中执行，如果不加括号：1eval('&#123;"name": "liu", "age": 20&#125;&#125;') 这里的执行语句就会变成：123&#123; "name" : "liu", "age" : 20&#125; {}按照语句解析，执行里面的逗号表达式，我们知道逗号表达式要求每一项都必须是表达式，输出最后一项的结果，而这里不满足要求，所以会报错。 但是加上括号就变成了这样：123(&#123; "name" : "liu", "age" : 20&#125;) 小括号可以把里面的内容当做表达式来解析，那么里面的内容就是一个对象了。 这也是立即执行函数的原理：123(function () &#123; console.log('IIFE');&#125;)() 小括号把函数声明变成了函数表达式，后面再跟一个小括号表示调用。 结束这里通过几个例子，引出了 JavaScript 的标签声明语句（Label Statement），从而解释了一些我们常用写法的原理。 以后万一有人问你为什么 eval() 解析JSON要加括号呢？这回知道怎么说了吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Label Statement</tag>
        <tag>C语言</tag>
        <tag>Goto语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML - 移动端 meta viewport]]></title>
    <url>%2F2017%2F12%2F10%2Fhtml_meta_viewport%2F</url>
    <content type="text"><![CDATA[我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。 CSS 像素（css pixel） / 密度独立像素（density independent pixels - dip）CSS 像素是 web 编程中的概念，是抽象的，不是实际存在的。它是独立于设备用于逻辑上衡量像素的单位，所以又叫密度独立像素。dip 有时候也缩写为 dp 。 屏幕尺寸指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。 屏幕像素密度（pixels per inch - ppi）指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的 ppi = √(1920^2+1080^2) / 5.5 ≈ 401ppi 。也就是说它每英寸可以显示 440 个物理像素点。 设备像素比指物理像素和密度独立像素的比值。window.devicePixelRatio = 物理像素 / dip。可以通过 window.devicePixelRatio 获得，该属性被所有WebKit浏览器以及Opera所支持。 viewportviewport 是指 web 页面上用户的可见区域。 viewport 的大小是和设备相关的，在移动端例如手机上，viewport 的大小是比 PC 端要小的，一般无论手机还是平板，默认的 viewport 大小都是 980px 。刚开始 web 页面仅仅是在 PC 端进行查看的，但是后来随着移动互联网的发展，越来越多的 web 访问是通过移动端进行的，但是因为 PC 的 viewport 要比移动端大，所以为了快速修复这个问题，移动端的浏览器默认只是把整个页面等比例缩小到移动端的 viewport 大小。 这样做的后果就是，用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。 那么回到我们最开始写的 meta 标签：1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt; device-width 是指这个设备最理想的 viewport 宽度。iPhone6 之前的 device-width 都是 320px ，iPhone6 是 375px ，iPhone6 Plus 是 414px ，而这个 device-width 是和 CSS像素（也叫密度独立像素 dip）是相同的。也就是说，web 页面中的 CSS像素的值等于 device-width 时，对应到手机上就是占满全屏的宽度。 安卓手机的 device-width 有320px、360px 和 384px 等等，不同的设备 device-width 是不一样的。 initial-scale=1.0 是指初始化的时候缩放大小是1，也就是不缩放。 user-scalable=0 是指禁止用户进行缩放。 maximum-scale=1.0 是指用户最大缩放大小是1，其实在禁止用户缩放以后，这一句可以省略。 在设计人员为移动端设计页面的时候经常可以听到2倍图和3倍图这些词语，这又是什么意思呢，我们以 iPhone6 举例： iPhone6 的分辨率（也就是物理像素）是 1334*750 像素，它的 device-width 是 375px 。 如果我们将屏幕横向分成 375 份，CSS 中 1px 占用的1份，因为屏幕就那么大，CSS中 width 等于 375px 时横向就会占满全屏，但是实际上存在的物理像素点横向是750个 ，所以在我们写 CSS 时 1px 对应到屏幕上是占用了2个物理像素点。 如果我们不写 width=device-width 这一句的话，默认 viewport 宽是 980px 。那么把 iPhone6 的屏幕横向分成980份，CSS 中 1px 占用1份，但是真正的像素点横向只有750个，这就意味着，实际上渲染出来的宽度是 75/98 个像素大小（只是理论上）。 设计人员在设计原型图的时候以 750px 的宽度为基准，我们在写 CSS的时候缩写一半来使用，但是在渲染的时候 1px 等于 2px 的物理像素，所以整个图片还是按 750px 的宽度来显示的，不会失真。 如果设计人员以 375px 的宽度为基准，那么我们在使用的时候直接把设计图中的像素宽度用在 CSS 中，那么在渲染的时候，1px 等于 2px 的物理像素，相当于图片会放大2倍，就会产生失真。 总结在添加 之后，移动端的 viewport 宽度会从默认的 980px 变成各个设备的 device-width 。 CSS 中的 100% 就等于 device-width 。 知道了这些，我们就可以结合别的知识，为页面进行响应式布局了。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>meta</tag>
        <tag>viewport</tag>
        <tag>pt</tag>
        <tag>dip</tag>
        <tag>ppi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 06 - 变量对象]]></title>
    <url>%2F2017%2F08%2F10%2Fjavascript_06_variable_object%2F</url>
    <content type="text"><![CDATA[上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明： Variable Object 就代表变量对象。Scope Chain 代表作用域链。thisValue 代表神秘的 this 。 作用域链和 this 留到后面再讲，今天我们先来弄明白变量对象。 变量对象 A variable object is a scope of data related with the execution context. It’s a special object associated with the context and which stores variables and function declarations are being defined within the context. 变量对象(variable object) 是与执行上下文相关的数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 变量对象（Variable Object – 简写 VO）是一个抽象的概念，指代与执行上下文相关的特殊对象，它存储着在上下文中声明的： 变量（var） 函数声明 （function declaration，简写 FD） 函数的形参（arguments） 我们假设变量对象为一个普通 ECMAScript 对象：1VO = &#123;&#125;; 就像前面讲过的，VO 是执行上下文的一个属性：12345activeExecutionContext = &#123; VO: &#123; // 上下文数据 （vars, FD, arguments） &#125;&#125; 因为变量对象是一个抽象的概念，所以并不能通过变量对象的名称直接访问，但是却可以通过别的方法来间接访问变量对象，例如在全局上下文环境的变量对象会有一个属性 window (DOM 中) 可以引用变量对象自身，全局上下文环境的另一个属性 this 也指向全局上下文环境的变量对象。 举个例子：1234567891011var a = 2;function foo (num) &#123; var b = 5;&#125;(function exp () &#123; console.log(111);&#125;)foo(10); 这里对应的变量对象是：123456789101112131415161718// 全局上下文环境的变量对象VO(globalContext) = &#123; // 一些全局环境初始化时系统自动创建的属性： Math、String、Date、parseInt等等 ··· // 全局上下文的变量对象中有一个属性可以访问到自身，在浏览器中这个属性是 window ，在 node 中这个属性是 global window: global // 自己定义的属性 a: 10, foo: &lt;reference to function&gt;&#125;;// foo 函数上下文的变量对象VO(foo functionContext) = &#123; num: 10, b: 5&#125;; 注意：函数表达式并不包括在变量对象中。 不同执行上下文中的变量对象执行上下文包括：全局上下文、函数上下文和 eval() 上下文。 全局上下文中的变量对象这里我们先来了解一下什么是全局对象：12全局对象（global object）是指在进入任何执行上下文之前就已经创建了的对象。这个对象只有一份，它的属性在程序中的任何地方都可以访问，全局对象的生命周期终止于程序退出的那一刻。 全局对象初始化时系统将创建并初始化一系列原始属性，例如：Math、String、Date、parseInt、window等等，之后是我们在全局上下文中自己定义的全局变量。在 DOM 中，全局对象的 window 属性可以引用全局对象自身，全局上下文环境的 this 属性也可以引用全局对象。1234567891011121314151617// 全局执行上下文环境EC(globalContext) = &#123; // 全局对象（全局上下文环境的变量对象） global: &#123; Math: &lt;...&gt;, String: &lt;...&gt;, ... ... window: global // 引用全局对象自身 &#125;, // this 属性 this: global // 作用域链 ...&#125; 举个例子：12345var a = 10;console.log(a); // 10console.log(window.a); // 10console.log(this.a); // 10 因此，在全局上下文环境中，变量对象用全局对象来表示。 函数上下文中的变量对象在函数上下文中，变量对象用活动对象 AO（Active Object）来表示。1VO(functionContext) = AO 活动对象是在进入函数上下文时刻被创建的，它是通过函数的 arguments 属性进行初始化。arguments 也是一个对象。12345AO = &#123; arguments: &#123; ... &#125;&#125; arguments 是活动对象的一个属性，它也是一个对象，包括以下属性： callee - 指向当前函数的引用 length - 真正传递的参数个数 properties-indexes - index 是字符串类型的整数，例如”1”: “aa”，类似于数组类型，也可以通过arguments[1]来访问，但是不能用数组的方法（push, pop等等）。另外，properties-indexes 的值和实际传递进来的参数之间是共享的，一个改变，另一个也随之改变。 举个例子：123456789101112131415161718192021222324252627282930function foo (x, y, z) &#123; // 声明的函数参数数量 console.log(foo.length); // 3 // 实际传递进来的参数数量 console.log(arguments.length); // 2 // arguments 的 callee 属性指向当前函数 console.log(arguments.callee === foo) // true // 参数共享 console.log(x === arguments[0]); // true console.log(x); // 10 arguments[0] = 20; console.log(x); // 20 x = 30; console.log(arguments[0]); // 30 // 但是注意，没有传递进来的参数 z ，和第3个索引值是不共享的 z = 40; console.log(arguments[2]); // undefined arguments[2] = 50; console.log(z); // 40&#125;foo(10, 20); 代码是如何被处理的在第1节中我们讲过js 代码的编译过程，其中有一步叫作预编译，是说在代码执行前的几微秒会首先对代码进行编译，形成词法作用域，然后执行。 那么执行上下文的代码就就可以分成两个阶段来处理： 进入执行上下文（预编译） 执行代码 而变量对象的修改变化和这两个阶段是紧密相关的。并且所有类型的执行上下文都会有这2个阶段。 进入执行上下文当引擎进入执行上下文时（代码还未执行），VO 里已经包含了一些属性： 函数的所有形参（如果是函数执行上下文）由名称和对应值组成的一个变量对象的属性被创建，如果没有传递对应的实参，那么由名称和 undefined 组成的一种变量对象的属性也会被创建。 所有的函数声明（Function Declaration - FD）由名称和对应值（函数对象 function object）组成的一个变量对象的属性被创建，如果变量对象已经存在相同名称函数的属性，则完全替换这个属性。 所有的变量声明（Variable Declaration - var）由名称和对应值（在预编译阶段所有变量值都是 undefined）组成的一个变量对象的属性被创建，如果变量名和已经声明的形参或者函数相同，则变量名不会干扰已经存在的这类属性，如果已经存在相同的变量名，则跳过当前声明的变量名。 注意：变量碰到相同名称的变量是忽略，函数碰到相同名称的函数是覆盖。 举个例子：1234567891011function foo (a, b) &#123; var c = 5; function bar () &#123;&#125;; var d = function _d () &#123;&#125;; (function f () &#123;&#125;);&#125;foo(10); 当进入带有实参10的 foo 函数上下文时（预编译时，此时代码还没有执行），AO 结构如下：12345678AO(foo) = &#123; a: 10, b: undefined, c: undefined, bar: &lt;reference to FunctionDelcaration "bar"&gt;, d: undefined &#125;; 注意，函数表达式 f 并不包含在活动对象 AO 内。也就是说，只有函数声明会被包含在变量对象 VO 里面，函数表达式并不会影响变量对象。 行内函数表达式 _d 则只能在该函数内部可以使用， 也不会包含在 VO 内。 这之后，就会进入第2个阶段，代码执行阶段。 代码执行在这个阶段，AO/VO 已经有了属性（并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined）。 AO 在代码执行阶段被修改如下：12AO['c'] = 5;AO['d'] = &lt;reference to FunctionDelcaration "_d"&gt; 再次要提醒大家，因为函数表达式 _d 已经保存到了声明的变量 d 上面，所以变量 d 仍然存在于 VO/AO 中。我们可以通 d() 来执行函数。但是函数表达式 f 却不存在于 VO/AO 中，也就是说，如果我们想尝试调用 f 函数，不管在函数定义前还是定义后，都会出现一个错误”f is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。 再来一个经典例子：12345678910console.log(x); // functionvar x = 10;console.log(x); // 10x = 20;function x () &#123;&#125;;console.log(x); // 20 这里为什么是这样的结果呢？ 上边我们说过，在代码执行之前的预编译，会为变量对象生成一些属性，先是形参，再是函数声明，最后是变量，并且变量并不会影响同名的函数声明。 所以，在进入执行上下文时，AO/VO 结构如下：12345AO = &#123; x: &lt;reference to FunctionDeclaration "x"&gt; // 在碰到变量声明 x 时，因为已经存在了函数声明 x ，所以会忽略&#125; 紧接着，在代码执行阶段，AO/VO 被修改如下：12AO['x'] = 10;AO['x'] = 20; 希望大家可以好好理解变量对象，对于理解我们后边要讲的作用域链有很大的帮助。 变量有一些文章说过： 不管是使用 var 关键字（在全局上下文）还是不使用 var 关键字（在任何地方），都可以声明一个变量。 请记住，这是错误的观念。 任何时候，变量都只能通过使用 var 关键字来声明（ES6 之前）。 1a = 10; 上面的赋值语句，仅仅是给全局对象创建了一个新属性（在在非严格模式，严格模式下会报错），但注意，它不是变量。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript 规范中变量的概念。 让我们通过一个例子来看一下两者的区别：12345console.log(a); // undefinedconsole.log(b); // 报错，b is not definedb = 10;var a = 20; 只要我们很好的理解了：变量对象、预编译阶段和执行代码阶段，就可以迅速的给出答案。 预编译（进入上下文）阶段：123VO = &#123; a: undefined&#125; 我们可以看到，因为 b 不是通过 var 声明的，所以这个阶段根本就没有 b ，b 只有在代码执行阶段才会出现。但是在这个例子中，还没有执行到 b 那就已经报错了。 我们稍微更改一下示例代码：123456789console.log(a); // undefinedb = 10;console.log(b); // 10 代码执行阶段被创建console.log(window.b); // 10console.log(this.b); // 10var a = 20;console.log(a); // 20 代码执行阶段被修改 关于变量，还有一个很重要的知识点。 变量不能用 delete 操作符来删除。1234567891011121314a = 10;console.log(window.a); // 10console.log(delete a); // trueconsole.log(window.a); // undefinedvar b = 20;console.log(window.b); // 20console.log(delete b); // falseconsole.log(window.b); // 20 注意：这个规则在 eval() 上下文中不起作用。 123456eval('var a = 10;');console.log(window.a); // 10console.log(delete a); // trueconsole.log(window.a); // undefined 总结这一节中我们讲了变量对象，下一节就是我们的重头戏 - 作用域链。希望大家可以持续关注我，我们一起进步。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>执行上下文</tag>
        <tag>变量对象</tag>
        <tag>Execution Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 05 - 执行上下文]]></title>
    <url>%2F2017%2F06%2F03%2Fjavascript_05_execution_context%2F</url>
    <content type="text"><![CDATA[在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。 可执行代码有几种前面说到当引擎执行到可执行代码的时候，就会将当前上下文压入上下文栈中。那么可执行的代码又分为几种？ 在这里，我们先假设定义执行上下文栈是一个数组：1EC = []; 第一种可执行代码 – 全局代码：全局类型代码是在加载外部的 js 文件或者本地 标签中的代码。注意，在全局代码中，并不包含定义在全局环境 function 内的代码。 程序启动后进入初始化全局环境：123EC = [ globalContext]; 第二种可执行代码 – 函数代码：当定义的函数被执行时，就进入了函数代码，当前函数上下文被压入 EC 栈中。注意，在函数代码中，也不包含定义在该函数内部环境 function 内的代码。 例如：123456789var a = 10;function foo () &#123; var b = 20; foo();&#125;foo(); 这个例子中的 EC 是什么样子的呢？ 1234567891011121314151617181920212223242526272829// 初始化EC = [ globalContext];// 第一次调用 foo 函数EC = [ &lt;foo&gt; functionContext, globalContext];// 在 foo 内递归调用自己EC = [ &lt;foo&gt; functionContext - recursively, &lt;foo&gt; functionContext, globalContext];// 继续递归调用自己EC = [ ...... &lt;foo&gt; functionContext - recursively2, &lt;foo&gt; functionContext - recursively, &lt;foo&gt; functionContext, globalContext];// 递归会不断调用下去，因为没有结束条件，所以这是一个死循环// 所以，EC 只会不断增加新的上下文，但是却不会退出 只有每次 return 的时候，才会退出当前执行上下文，相应上下文会从栈中弹出，栈指针会自动移动位置。 注意，当函数没有明确指明 return 什么的时候，默认 return undefined 。 如果有抛出的异常没有被截获的话，也有可能从一个或多个执行上下文中退出。当所有代码执行完以后，EC 中只会包含全局上下文（global context），当程序退出以后，全局上下文也会退出。 第三种可执行代码 – eval 代码：eval 函数在调用的时候会产生上下文。例如：12345678eval('var a = 10');(function foo () &#123; eval('var b = 20');&#125;());alert(a); // 10alert(b); // ReferenceError，b is not defined 这个例子中 EC 的变化如下：123456789101112131415161718192021222324252627282930313233343536373839// 初始化EC = [ globalContext];// eval('var a = 10');EC = [ evalContext, globalContext];// eval 执行完毕EC = [ globalContext];// 立即执行函数 fooEC = [ &lt;foo&gt; functionContext, globalContext];// eval('var b = 20');EC = [ evalContext, &lt;foo&gt; functionContext, globalContext];// eval 执行完毕EC = [ &lt;foo&gt; functionContext, globalContext];// foo 执行完毕EC = [ globalContext]; 这就是一个典型的逻辑调用上下文栈。 在 setTimeout 和 setInterval 函数中的第一个参数也可以传入代码字符串，但是这个一般不会这么去用，所以这里也就不讨论了。 结论执行上下文环境是我们了解变量对象和作用域链的基础，大家一定要好好理解（其实也并不难），下一节我们来讨论变量对象，相信会让大家有一定的收获。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 04 - 提升]]></title>
    <url>%2F2017%2F05%2F10%2Fjavascript_04__variable_lifting%2F</url>
    <content type="text"><![CDATA[到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。 声明提升先看代码：12345a = 2;var a;console.log(a); 大家认为这里会输出什么？ 有一些人认为是 undefined ，因为 var a; 是在 a = 2; 之后，所以会觉得 undefined 覆盖了 a 的值。但是，真正的结果是 2 。 再看一段代码：1234567891011121314console.log(a);var a = 2;``` 鉴于上一个例子，有些人会认为这里会输出 2 ，也有人认为由于 a 在使用前并没有声明，所以这里会报错。但是，这里的结果是 undefined 。之前讨论编译器的时候，我们知道 JS 引擎会在解释代码之前首先对其进行编译。编译阶段的第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。因此，正确的思路是，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。当你看到 ***var a = 2;*** 时，JavaScript 实际上会将其看成两个声明：***var a;*** 和 ***a = 2;*** 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。所以，在第一个例子中，代码的等价形式是这样的： var a; a = 2; console.log(a);1第二个例子中，代码的等价形式是这样的： var a; console.log(a); a = 2;12345这个过程就好像是变量和函数声明从它们的代码中出现的位置被“移动”到了最上面。这个过程就叫作“提升”。**注意**，只有声明本身会被提升，而赋值操作和其他运行逻辑都会停留在原地，想象一下，如果提升会改变代码的执行顺序，那么会造成非常严重的破坏。还有一点，函数声明会被提升，但是函数表达式不会被提升。 foo(); // 报错，TypeError: foo is not a function，因为这里 foo 是 undefined，并不是一个函数 var foo = function foo() { // something else}123这段程序中的变量标识符 foo 被提升并分配给所在的作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError 。但是，foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会被赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，所以会抛出 TypeError 异常。同时，即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： foo();bar(); var foo = function bar () { // something else};1这段代码经过提升后，实际上等价于： var foo; foo();bar(); foo = function () { var bar = …self… // something else};12345### 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节是，**函数声明会首先被提升，然后才是变量。**考虑如下代码： foo(); // 1 var foo; function foo () { console.log(1);} foo = function () { console.log(2);};1这里会输出 1 而不是 2 。这段代码其实等价于： function foo () { console.log(1);} foo(); // 1 foo = function () { console.log(2);};123***var foo;*** 尽管出现在 function foo() &#123;...&#125; 声明之前，但是它是重复声明，所以会被编译器忽略，因为函数声明会被提升到变量声明之前。注意，尽管重复的 var 声明会被忽略，但重复的函数声明却会覆盖前一个同名函数。 foo(); // 3 function foo () { console.log(1);} var foo = function () { console.log(2);}; foo(); // 2 function foo () { cosole.log(3);}1这个例子充分说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。上面那个例子，等价于： function foo () { cosole.log(3);} foo(); // 3 foo = function () { console.log(2);}; foo(); // 212还有一些人会犯如下错误： foo(); // 2 var a = true; if (a) { function foo () { console.log(1); }} else { function foo () { console.log(2); }}1因为 if 并没有块作用域，所以这里的函数声明会提升到其作用域最前边，而后一个 function 声明会覆盖前一个，所以这里结果是 2 。这里代码等价如下： function foo () { console.log(2);} var a; foo(); // 2 a = true; if (a) { } else { }` 总结我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a; 和 a = 2; 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被处理（预编译）。可以将这个过程想象成所有的声明（变量和函数）都会被“移动”到各自的作用域的最顶端，这个过程叫作提升。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 03 - 函数作用域和块作用域]]></title>
    <url>%2F2017%2F04%2F10%2Fjavascript_03__function_scope%2F</url>
    <content type="text"><![CDATA[在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上 在这段代码中，函数 foo 的作用域包含了标识符a、b、c 和 bar ，函数 bar 的作用域中又包含别的标识符。 由于标识符 a、b、c 和 bar都属于函数 foo 的作用域，所以在全局作用域中访问会报错，因为它们都没有定义，但是在函数 foo 内部，这些标识符都是可以访问的，这就是函数作用域。 为什么要有这些作用域当我们用作用域把代码包起来的时候，其实就是对它们进行了“隐藏”，让我们对其有控制权，想让谁访问就可以让谁访问，想禁止访问也很容易。 想像一下，如果所有的变量和函数都在全局作用域中，当然我们可以在内部的嵌套作用域中访问它们，但是因为暴露了太多的变量或函数，它们可能被有意或者无意的篡改，以非预期的方式使用，这就导致我们的程序会出现各种各样的问题，严重会导致数据泄露，造成无法挽回的后果。 例如：123456789var obj = &#123; a: 2, getA: function () &#123; return this.a; &#125;&#125;;obj.a = 4;obj.getA(); // 4 这个例子中，我们可以任意修改对象 obj 内部的值，在某种情况下这并不是我们所期望的，采用函数作用域就可以解决这个问题，私有化变量 a 。12345678910111213141516var obj = (function () &#123; var a = 2; return &#123; getA: function () &#123; return a; &#125;, setA: function (val) &#123; a = val; &#125; &#125;&#125;());obj.a = 4;obj.getA(); // 2obj.setA(8);obj.getA(); // 8 这里通过立即执行函数（IIFE）返回一个对象，只能通过对象内的方法对变量 a 进行操作，其实这里有闭包的存在，这个我们在以后会深入讨论。 “隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，冲突会导致变量的值被意外覆盖。 例如：123456789101112function foo () &#123; function bar (a) &#123; i = 3; // 修改了 for 循环所属作用域中的 i console.log(a + i); &#125; for (var i = 0; i &lt; 10; i++) &#123; bar(i * 2); // 这里因为 i 总会被设置为 3 ，导致无限循环 &#125;&#125;foo(); bar(…) 内部的赋值表达式 i = 3 意外的覆盖了声明在 foo(…) 内部 for 循环中的 i ，在这个例子中因为 i 始终被设置为 3 ，永远满足小于 10 这个条件，导致无限循环。 bar(…) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3; 就可以满足这个要求。另外一种方法是采用一个完全不同的标识符名称，比如 var j = 3; 。但是软件设计在某种情况下可能自然而然的要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。 总结来说，作用域可以起到两个作用： 私有化变量或函数 规避同名冲突 函数声明和函数表达式如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 函数声明举个例子：123function foo () &#123; // something else&#125; 这就是一个函数声明。 函数表达式分为匿名函数表达式和具名函数表达式。 对于函数表达式来说，最熟悉的场景可能就是回调参数了，例如：123setTimeout(function () &#123; console.log("I wait for one second.")&#125;, 1000); 这个叫作匿名函数表达式，因为 function ()… 没有名称标识符。函数表达式可以是匿名的，但是函数声明不可以省略函数名，在 javascript 中这是非法的。 匿名函数表达式书写简便，但是它也有几个缺点需要注意： 匿名函数在浏览器栈追踪中不会显示出有意义的函数名，这会加大调试难度。 如果没有函数名，当函数需要引用自身的时候就只能使用已经不是标准的 arguments.callee 来引用，比如递归。在事件触发后的事件监听器中也有可能需要通过函数名来解绑自身。 匿名函数对代码的可读性和可理解性有一定的影响。一个有意义的函数名可以让代码不言自明。 具名函数表达式又叫行内函数表达式，例如：123setTimeout(function timerHandler () &#123; console.log("I wait for one second.")&#125;, 1000); 这样，在函数内部需要引用自身的时候就可以通过函数名来引用，当然要注意，这个函数名只能在这个函数内部使用，在函数外使用时未定义的。 立即执行函数表达式（IIFE）IIFE 全写是 Immediately Invoked Function Expression，立即执行函数。12345678var a = 2;(function foo () &#123; var a = 3; console.log(a); // 3&#125;)();console.log(a); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个函数表达式，通过在末尾加上另一对 ( ) 括号可以立即执行这个函数，比如 (function () {})() 。第一个 ( ) 将函数变成函数表达式，第二个 ( ) 执行了这个函数。 也有另外一种立即执行函数的写法，(function () {}()) 也可以立即执行这个函数。12345678var a = 2;(function foo () &#123; var a = 3; console.log(a); // 3&#125;());console.log(a); // 2 这两种写法功能是完全一样的，具体看大家使用。 IIFE 的另一种普遍的进阶用法是把它们当做函数调用并传递参数进去。123456789var a = 2;(function (global) &#123; var a = 3; console.log(a); // 3 console.log(global.a) // 2&#125;)(window);console.log(a); // 2 我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递你需要的任何东西，并将变量命名为任何你觉得合适的文字。这对于改进代码风格是非常有帮助的。 这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖的异常（这并不常见）。将一个参数命名为 undefined ，但是并不传入任何值，这样就可以保证在代码块中 undefined 的标识符的值就是 undefined 。12345678undefined = true;(function IIFE (undefined) &#123; var a; if (a === undefined) &#123; console.log("Undefined is safe here.") &#125;&#125;()); 块作用域ES5 及以前 JavaScript 中具有块作用域的只有 with 和 try…catch 语句，在 ES6 及以后的版本添加了具有块作用域的变量标识符 let 和 const 。 with123456789101112var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); // 2 console.log(b); // 3&#125;console.log(a); // 报错，a is not definedconsole.log(b); // 报错，a is not defined 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 try…catch1234567try &#123; undefined(); // 非法操作&#125; catch (err) &#123; console.log(err); // 正常执行&#125;console.log(err); // 报错，err is not defined try/catch 中的 catch 分句会创建一个块作用域，其中的变量声明仅在 catch 内部有效。 letlet 关键字可以将变量绑定到任意作用域中（通常是 {…} 内部）。换句话说，let 为其声明的变量隐式的劫持了所在的块作用域。1234567891011var foo = true;if (foo) &#123; let a = 2; var b = 2; console.log(a); // 2 console.log(b); // 2&#125;console.log(b); // 2console.log(a); // 报错，a is not defined 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些代码块作用域中有绑定的变量，并且习惯性的移动这些块或者将其包含到其他块中，就会导致代码混乱。 为块作用域显示的创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。12345678var foo = true;if (foo) &#123; &#123; let a = 2; console.log(a); // 2 &#125;&#125; 在代码的任意位置都可以使用 {…} 括号来为 let 创建一个用于绑定的块。 还有一点要注意的是，在使用 var 进行变量声明的时候会存在变量提升，提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会存在作用域提升，声明的变量在被运行之前，并不存在。123456789console.log(a); // undefinedconsole.log(b); // 报错， b is not defined// 在浏览器中运行这段代码时，因为前面报错了，所以不会看到接下来打印的结果，但是理论上就是这样的结果var a = 2;console.log(a); // 2 let b = 4;console.log(b); // 4 2.3.1 垃圾收集另一个块作用域非常有用的原因和闭包及垃圾内存的回收机制有关。举个例子：12345678910111213function processData (data) &#123; // do something&#125;var bigData = &#123;...&#125;;processData(bigData);var btn = document.getElementById('my_button');btn.addEventListener('click', function () &#123; console.log('button clicked');&#125;, false); 这个按钮点击事件的回调函数中并不需要 bigData 这个非常占内存的数据，理论上来说，当 processData 函数处理完之后，这个占有大量空间的数据结构就可以被垃圾回收了。但是，由于这个事件回调函数形成了一个覆盖当前作用域的闭包，JavaScript 引擎极有可能依然保存着这个数据结构（取决于具体实现）。 使用块作用域可以解决这个问题，可以让引擎清楚的知道没有必要继续保存这个 bigData 。123456789101112131415function processData (data) &#123; // do something&#125;&#123; let bigData = &#123;...&#125;; processData(bigData);&#125;var btn = document.getElementById('my_button');btn.addEventListener('click', function () &#123; console.log('button clicked');&#125;, false); 2.3.2 let 循环一个 let 可以发挥优势的典型例子就是 for 循环。12345678910var lists = document.getElementsByTagName('li');for (let i = 0, length = lists.length; i &lt; length; i++) &#123; console.log(i); lists[i].onclick = function () &#123; console.log(i); // 点击每个 li 元素的时候，都是相对应的 i 值，而不像用 var 声明 i 的时候，因为没有块作用域，所以在回调函数通过闭包查找 i 的时候找到的都是最后的 i 值 &#125;;&#125;;console.log(i); // 报错，i is not defined for 循环头部的 let 不仅将 i 绑定到 fir 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保上一个循环迭代结束时的值重新进行赋值。 当然，我们在 for 循环中使用 var 时也可以通过立即执行函数形成一个新的闭包来解决这个问题。123456789var lists = document.getElementsByTagName('li');for (var i = 0, length = lists.length; i &lt; length; i++) &#123; lists[i].onclick = (function (j) &#123; return function () &#123; console.log(j); &#125; &#125;(i));&#125; 或者123456789var lists = document.getElementsByTagName('li');for (var i = 0, length = lists.length; i &lt; length; i++) &#123; (function (i) &#123; lists[i].onclick = function () &#123; console.log(i); &#125; &#125;(i));&#125; 其实原理无非就是，为每个迭代创建新的闭包，立即执行函数执行完后本来应该销毁变量，释放内存，但是因为这里有回调函数的存在，所以形成了闭包，然后通过形参进行同名变量覆盖，所以找到的 i 值就是每个迭代新闭包中的形参 i 。 const除了 let 以外，ES6 还引入了 const ，同样可以用来创建作用域变量，但其值是固定的（常亮）。之后任何试图修改值的操作都会引起错误。123456789101112var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常亮 a = 3; // 正常 b = 4; // 报错，TypeError: Assignment to constant variable&#125;console.log(a); // 3console.log(b); // 报错， b is not defined 和 let 一样，const 声明的变量也不存在“变量提升”。 总结函数是 JavaScript 中最常见的作用域单元。块作用域指的是变量和函数不仅可以属于所处的函数作用域，也可以属于某个代码块。 本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用哪种作用域，创造可读、可维护的优良代码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 02 - 词法作用域]]></title>
    <url>%2F2017%2F03%2F05%2Fjavascript_02_static_scope%2F</url>
    <content type="text"><![CDATA[两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。 举个例子：12345678910111213var a = 2;function foo1 () &#123; console.log(a);&#125;function foo2 () &#123; var a = 10; foo1();&#125;foo2(); 这里输出结果是多少呢？ 注意，这里结果打印的是 2。 可能会有一些同学认为是 10，那就是没有搞清楚词法作用域的概念。前边介绍了，词法作用域只取决于代码书写时的位置，那么在这个例子中，函数 foo1 定义时的位置决定了它的作用域，通过下图理解： foo1 和 foo2 都是分别定义在全局作用域中的函数，它们是并列的，所以在 foo1 的作用域链中并不包含 foo2 的作用域，虽然在 foo2 中调用了 foo1，但是 foo1 对变量 a 进行 RHS 查询时，在自己的作用域没有找到，引擎会去 foo1 的上级作用域（也就是全局作用域）中查找，而并不会去 foo2 的作用域中查找，最终在全局作用域中找到 a 的值为 2。 总结来说，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法JavaScript 中有 3 种方式可以用来“欺骗词法”，动态改变作用域。 第一种： eval JavaScript 中 eval(…) 函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 在执行 eval(…) 之后的代码时，引擎并不知道或在意前面的代码是以动态形式插入进来并对词法作用域环境进行修改的，引擎只会像往常一样正常进行词法作用域的查找。 举个例子：123456789function foo (str) &#123; eval(str); // "欺骗"词法 console.log(a);&#125;var a = 2;foo("var a = 10;"); 如大家所想，输出结果为 10。因为 eval(“var a = 10;”) 在 foo 的作用域中新创建了一个同名变量 a，引擎在 foo 作用域中对 a 进行 RHS 查询，找到了新定义的 a，值为 10，所以不再向上查找全局作用域中的 a，所以导致输出结果为 10，这就是 eval(…) 的作用。 在严格模式下，eval(…) 在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。 1234567891011'use strict;'function foo (str) &#123; eval(str); // eval() 有自己的作用域，所以并不会修改 foo 的词法作用域 console.log(a);&#125;var a = 2;foo("var a = 10;"); 这里输出结果为 2。 JavaScript 中还有一些功能和 eval(…) 类似的函数，例如 setTimeout(…) 和 setInterval(…) 的第一个参数可以是一个字符串，字符串的内容可以解释为一段动态生成的代码。这些功能已经过时并且不被提倡，最好不要使用它们。new Function(…) 函数的最后一个参数也可以接受代码字符串，并将其转化为动态生成的函数，也尽量避免使用。 在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。 第二种： withwith 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 举个例子：123456789101112var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); // 2 console.log(b); // 3 c = 4; &#125;;console.log(c); // 4, c 被泄露到全局作用域上 如上所示，我们对 c 进行 LHS 查询，因为在 with 引入的新作用域中没有找到 c，所以向上一级作用域（这里是全局作用域）查找，也没有找到，在非严格模式下，在全局对象中新建了一个属性 c 并赋值为 4。 with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会限制在这个块作用域中，而是被添加到 with 所处的函数作用域中。 严格模式下，with 被完全禁止使用。1234567891011121314'use strict';var obj = &#123; a: 2, b: 3&#125;;with (obj) &#123; console.log(a); console.log(b); c = 4; &#125;;console.log(c); 第三种： try…catchtry…catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。 举个例子：12345678910try &#123; foo();&#125; catch (err) &#123; console.log(err); var a = 2; // 打印出 "ReferenceError: foo is not defined at &lt;anonymous&gt;:2:4"&#125;console.log(a); // 2 当 try 中的代码出现错误时，就会进入 catch 块，此时会把异常对象添加到作用域链的最前端，类似于 with 一样，catch 中定义的局部变量也都会添加到包含 try…catch 的函数作用域（或全局作用域）中。 性能JavaScript 引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数定义的位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了 eval(…)、with 和 try…catch ，它只能简单的假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(…) 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 最悲观的情况是如果出现了这些动态添加作用域的代码，所有的优化可能都是无意义的，因此最简单的做法就是完全不进行任何优化。 如果代码中大量使用 eval(…) 和 with，那么运行起来一定会变得非常缓慢。 结论很多时候我们对代码的分析出错，就是源于对词法作用域的忽略，所以让我们重新审视代码，继续努力！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习系列 01 - 编译原理和作用域]]></title>
    <url>%2F2017%2F02%2F10%2Fjavascript_01_principles_of_compiler%2F</url>
    <content type="text"><![CDATA[在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。 编译原理大家通常把 javascript 归类为一种“动态”或“解释执行”的语言，但事实上，它是一门编译语言，但和传统的编译语言不同，它不是提前编译的，编译结果也不能进行移植。 在传统编译语言中，程序在执行之前会经历三个步骤，统称为“编译”： 分词/词法分析这个过程会把字符串分解成有意义的代码块，这些代码块被称为词法单元。例如 var a = 5; 这段程序通常会被分解成下面这些词法单元： var、a、=、5、; 。空格是否会被当成词法单元取决于空格在这门语言中是否有意义。 解析/语法分析这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。var a = 5; 的抽象语法树中可能如下图所示： 代码生成将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。简单来说，就是通过某种方法可以将 var a = 5; 的 AST 转化为一组机器指令，用来创建一个叫做 a 的变量（包括分配内存等），并将一个值 5 存储在 a 中。 比起那些编译过程只有三个步骤的语言的编译器来说，javascript 引擎要复杂的多。例如，在词法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 首先我们要清楚，javaScript 引擎不会有太多的时间来进行优化（相对于其它语言的编译器来说），因为与其它语言不同，javascript 的编译过程不是发生在构建之前的。 对于 javascript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在我们将要讨论的作用域背后，javascript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至重新编译）来保证性能最佳。 总结来说，任何 javascript 代码片段在执行前都要进行编译（预编译）。因此，javascript 编译器首先会对 var a = 5; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。 三位好友要真正理解作用域，我们首先要知道 javascript 中有三位好朋友： 引擎从头到尾负责整个 javascript 程序的编译及执行过程。 编译器负责语法分析及代码生成。 作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 当遇见 var a = 5; 这一段代码时，其实执行了两个步骤： （1）var a; 编译器会询问作用域是否已经有一个该名称的变量存在于同一作用域的集合中。如果是，编译器会忽略该声明，继续进行编译，否则它会要求在当前作用域的集合中声明一个新的变量，并命名为 a 。（2）a = 5; 编译器会为引擎生成运行时所需的代码，这些代码用来处理 a = 5; 这个赋值操作。引擎运行时会首先询问作用域，在当前作用域的集合中是否存在一个叫作 a 的变量，如果是，引擎就会使用这个变量。如果否，引擎会继续向父级作用域中查找，直到找到全局作用域，如果在全局作用域中仍没有找到 a ，那么在非严格模式下，引擎会为全局对象新建一个属性 a ，并将其赋值为5，在严格模式下，引擎会报错误 ReferenceError: a is not defined。 总结来说，变量的赋值会执行两个操作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在当前作用域中查找该变量（找不到就向上一级作用域查找），如果能够找到就会对它赋值。 LHS 和 RHS前面说到引擎在为变量赋值的时候会在作用域中查找变量，但是执行怎样的查找，用什么方式，会对最终的查找结果造成影响。 在 var a = 5; 这个例子中，引擎会对 a 进行 LHS 查询，当然，另外一个查找类型叫作 RHS。 对变量进行赋值所执行的查询叫 LHS。找到并使用变量值所执行的查询叫 RHS。 举个例子：12345678910function foo(a) &#123; // 这里隐式包含了 a = 2 这个赋值，所以对 a 进行了 LHS 查询 var b = a; // 这里对 a 进行了 RHS 查询，找到 a 的值，然后对 b 进行 LHS 查询，把 2 赋值给 b return a + b; // 这里包含了对 a 和 b 进行的 RHS 查询&#125;var c = foo(2);// 这里首先对 foo 进行 RHS 查询，找到它是一个函数，然后对 c 进行 LHS 查询把 foo 赋值给 c 所以上面的例子共包含 3 个 LHS 查询和 4 个 RHS 查询，你们都找对了吗？ 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 举个例子：1234567function foo(a) &#123; console.log(a + b);&#125;var b = 2;foo(2); // 4 这里对 b 进行的 RHS 查询在 foo 作用域中无法找到，但可以在上一级作用域（这个例子中就是全局作用域）中找到。 总结来说，遍历嵌套作用域链的规则很简单：引擎从当前执行的作用域中开始查找变量，如果都找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 总结编译器、引擎和作用域是 javascript 代码执行的基础，掌握好这些会对我们深入学习 javascript 起到事半功倍的效果，我们的学习之路才刚刚开始，大家加油！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
