{"title":"liuxuan的博客","description":"科大讯飞","language":"zh-Hans","link":"//blog.liuxuan.site","pubDate":"Wed, 25 Jul 2018 14:36:00 GMT","lastBuildDate":"Wed, 25 Jul 2018 15:13:45 GMT","generator":"hexo-generator-json-feed","webMaster":"liuxuan","items":[{"title":"JavaScript数据结构02 - 栈","link":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/","description":"![label-statement](http://image.liuxuan.site/blog/20180725/stack.jpg?imageView2/1/w/1000/h/400) ## 一、定义 ### 1.1 背景 通过前面一节[《JavaScript数据结构01 - 数组》](https://blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/)我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。 有两种数据结构类似于数组，但在添加和删除元素时更为可控。 它们就是**栈和队列**。 ### 1.2 概念 **栈**是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作**栈顶**，另一端就叫**栈底**。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。","pubDate":"Wed, 25 Jul 2018 14:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/","category":"JavaScript"},{"title":"JavaScript数据结构01 - 数组","link":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/","description":"![label-statement](http://image.liuxuan.site/blog/20180725/array.jpg?imageView2/1/w/1000/h/400) ## 一、创建数组 #### 1.1 使用Array构造函数 123var arr1 = new Array(); // 创建一个空数组var arr2 = new Array(10); // 创建一个包含20项的数组var arr3 = new Array('liu', 'wang', 'li'); // 创建一个包含3个字符串的数组 #### 1.2 使用数组字面量表示法 123var arr1 = []; // 创建一个空数组var arr2 = [10]; // 创建一个包含1项的数组var arr3 = ['liu', 'wang', 'li']; // 创建一个包含3个字符串的数组","pubDate":"Wed, 25 Jul 2018 08:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/","category":"JavaScript"},{"title":"JavaScript异步编程","link":"//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/","description":"前言从我们一开始学习JavaScript的时候就听到过一段话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。 但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。 本文也会同步到我的个人网站。","pubDate":"Fri, 20 Jul 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/","category":"异步编程"},{"title":"看图学HTTPS","link":"//blog.liuxuan.site/2018/05/21/learn_https_through_photos/","description":"前言之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。 我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。 本文也会同步到我的个人网站。 正文HTTP是什么样的？HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述： 客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。","pubDate":"Mon, 21 May 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/05/21/learn_https_through_photos/","category":"HTTP"},{"title":"聊聊V8引擎的垃圾回收","link":"//blog.liuxuan.site/2018/04/14/v8_garbage_collection/","description":"前言我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~ 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 为什么要有垃圾回收在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。 不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。","pubDate":"Sat, 14 Apr 2018 08:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/14/v8_garbage_collection/","category":"JavaScript"},{"title":"尾调用和尾递归","link":"//blog.liuxuan.site/2018/04/10/tail_call/","description":"尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: ,","pubDate":"Tue, 10 Apr 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/10/tail_call/","category":"JavaScript"},{"title":"搭建 karma + jasmine 测试环境","link":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","description":"在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。","pubDate":"Tue, 03 Apr 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","category":"前端测试"},{"title":"JS学习系列 07 - 标签声明（Label Statement）","link":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","description":"引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？","pubDate":"Sat, 10 Mar 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","category":"JavaScript"},{"title":"HTML - 移动端 meta viewport","link":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","description":"我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。","pubDate":"Sun, 10 Dec 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","category":"HTML"},{"title":"JS学习系列 06 - 变量对象","link":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","description":"上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明：","pubDate":"Thu, 10 Aug 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","category":"JavaScript"},{"title":"JS学习系列 05 - 执行上下文","link":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","description":"在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。","pubDate":"Sat, 03 Jun 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","category":"JavaScript"},{"title":"JS学习系列 04 - 提升","link":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","description":"到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。","pubDate":"Wed, 10 May 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","category":"JavaScript"},{"title":"JS学习系列 03 - 函数作用域和块作用域","link":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","description":"在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上","pubDate":"Mon, 10 Apr 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","category":"JavaScript"},{"title":"JS学习系列 02 - 词法作用域","link":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","description":"两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。","pubDate":"Sun, 05 Mar 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","category":"JavaScript"},{"title":"JS学习系列 01 - 编译原理和作用域","link":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","description":"在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。","pubDate":"Fri, 10 Feb 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","category":"JavaScript"}]}