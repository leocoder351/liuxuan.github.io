{"title":"liuxuan的博客","description":"科大讯飞","language":"zh-Hans","link":"//blog.liuxuan.site","pubDate":"Wed, 10 Oct 2018 12:36:00 GMT","lastBuildDate":"Sun, 11 Nov 2018 08:09:18 GMT","generator":"hexo-generator-json-feed","webMaster":"liuxuan","items":[{"title":"带你五步学会Vue SSR","link":"//blog.liuxuan.site/2018/10/10/javascript_vue_ssr/","description":"前言SSR大家肯定都不陌生，通过服务端渲染，可以优化SEO抓取，提升首页加载速度等，我在学习SSR的时候，看过很多文章，有些对我有很大的启发作用，有些就只是照搬官网文档。通过几天的学习，我对SSR有了一些了解，也从头开始完整的配置出了SSR的开发环境，所以想通过这篇文章，总结一些经验，同时希望能够对学习SSR的朋友起到一点帮助。 我会通过五个步骤，一步步带你完成SSR的配置： 纯浏览器渲染 服务端渲染，不包含Ajax初始化数据 服务端渲染，包含Ajax初始化数据 服务端渲染，使用serverBundle和clientManifest进行优化 一个完整的基于Vue + VueRouter + Vuex的SSR工程 如果你现在对于我上面说的还不太了解，没有关系，跟着我一步步向下走，最终你也可以独立配置一个SSR开发项目，所有源码我会放到github上，大家可以作为参考。","pubDate":"Wed, 10 Oct 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/10/10/javascript_vue_ssr/","category":"JavaScript"},{"title":"从0到1实现Promise","link":"//blog.liuxuan.site/2018/09/28/javascript_promise/","description":"前言Promise大家一定都不陌生了，JavaScript异步流程从最初的Callback，到Promise，到Generator，再到目前使用最多的Async/Await（如果对于这些不熟悉的可以参考我另一篇文章《JavaScript异步编程》），这不仅仅是技术实现的发展，更是思想上对于如何控制异步的递进。Promise作为后续方案的基础，是重中之重，也是面试时候最常被问到的。 今天我们就一起从0到1实现一个基于A+规范的Promise，过程中也会对Promise的异常处理，以及是否可手动终止做一些讨论，最后会对我们实现的Promise做单元测试。完整的代码已经上传到github，想直接看代码的可以点这里。 虽然已经有很多带你实现Promise类的文章了，但每个人理解的程度不一样，也许不同的文章可以带给你不同的思考呢，那我们就开始吧。","pubDate":"Fri, 28 Sep 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/09/28/javascript_promise/","category":"JavaScript"},{"title":"带你彻底弄懂Event Loop","link":"//blog.liuxuan.site/2018/09/05/javascript_eventloop/","description":"前言我在学习浏览器和NodeJS的Event Loop时看了大量的文章，那些文章都写的很好，但是往往是每篇文章有那么几个关键的点，很多篇文章凑在一起综合来看，才可以对这些概念有较为深入的理解。 于是，我在看了大量文章之后，想要写这么一篇博客，不采用官方的描述，结合自己的理解以及示例代码，用最通俗的语言表达出来。希望大家可以通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。如果在文中出现书写错误的地方，欢迎大家留言一起探讨。 （PS：说到Event Loop肯定会提到Promise，我根据Promise A+规范自己实现了一个简易Promise库，源码放到Github上，大家有需要的可以当做参考，后续我也会也写一篇博客来讲Promise，如果对你有用，就请给个Star吧~）","pubDate":"Wed, 05 Sep 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/09/05/javascript_eventloop/","category":"JavaScript"},{"title":"JavaScript实现函数重载","link":"//blog.liuxuan.site/2018/08/29/javascript_function_overload/","description":"概念重载是指函数或者方法有相同的名称，但是参数个数或类型不相同的情形，这样的同名不同参的函数或者方法之间，互相称之为重载函数或方法。 我们知道，JavaScript函数可以随意传递任意数量、任意类型的参数，那么它有没有重载呢？ 答案是有的，下面我们通过3种方法来实现JavaScript的函数重载。","pubDate":"Wed, 29 Aug 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/08/29/javascript_function_overload/","category":"JavaScript"},{"title":"JavaScript实现继承","link":"//blog.liuxuan.site/2018/08/28/javascript_extend/","description":"简介本文不准备深入细节，主要是对《JavaScript高级程序设计中》介绍的JS如何实现继承做一个总结，毕竟好记性不如烂笔头。文末会附带一张神图，搞清楚这张图，原型链也就没有什么问题了。","pubDate":"Tue, 28 Aug 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/08/28/javascript_extend/","category":"JavaScript"},{"title":"JavaScript数据结构04 - 链表","link":"//blog.liuxuan.site/2018/08/03/javascript_data_structure_04_linked_list/","description":"一、定义1.1 概念前面我们学习了数组这种数据结构。数组（或者也可以称为列表）是一种非常简单的存储数据序列的数据结构。在这一节，我们要学习如何实现和使用链表这种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩容。 要存储多个元素，数组（或列表）可能是最常用的数据结构，它提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数强类型语言中）数组的大小是固定的，需要预先分配，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（注意：在JavaScript中数组的大小随时可变，不需要预先定义长度） 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。","pubDate":"Fri, 03 Aug 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/08/03/javascript_data_structure_04_linked_list/","category":"JavaScript"},{"title":"JavaScript数据结构03 - 队列","link":"//blog.liuxuan.site/2018/07/26/javascript_data_structure_03_queue/","description":"一、定义前面我们学习了栈的实现，队列和栈非常类似，但是使用了不同的原则，而非后进先出。 队列是遵循FIFO（First In First Out，先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在计算机科学中，一个最常见的例子就是打印队列。比如说我们要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。","pubDate":"Thu, 26 Jul 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/26/javascript_data_structure_03_queue/","category":"JavaScript"},{"title":"JavaScript数据结构02 - 栈","link":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/","description":"一、定义1.1 背景通过前面一节《JavaScript数据结构01 - 数组》我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。 有两种数据结构类似于数组，但在添加和删除元素时更为可控。 它们就是栈和队列。 1.2 概念栈是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。","pubDate":"Wed, 25 Jul 2018 14:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/","category":"JavaScript"},{"title":"JavaScript数据结构01 - 数组","link":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/","description":"一、创建数组1.1 使用Array构造函数123var arr1 = new Array(); // 创建一个空数组var arr2 = new Array(10); // 创建一个包含20项的数组var arr3 = new Array('liu', 'wang', 'li'); // 创建一个包含3个字符串的数组 1.2 使用数组字面量表示法123var arr1 = []; // 创建一个空数组var arr2 = [10]; // 创建一个包含1项的数组var arr3 = ['liu', 'wang', 'li']; // 创建一个包含3个字符串的数组","pubDate":"Wed, 25 Jul 2018 08:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/","category":"JavaScript"},{"title":"JavaScript异步编程","link":"//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/","description":"前言从我们一开始学习JavaScript的时候就听到过一段话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。 但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。 本文也会同步到我的个人网站。","pubDate":"Fri, 20 Jul 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/","category":"异步编程"},{"title":"看图学HTTPS","link":"//blog.liuxuan.site/2018/05/21/learn_https_through_photos/","description":"前言之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。 我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。 本文也会同步到我的个人网站。 正文HTTP是什么样的？HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述： 客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。","pubDate":"Mon, 21 May 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/05/21/learn_https_through_photos/","category":"HTTP"},{"title":"聊聊V8引擎的垃圾回收","link":"//blog.liuxuan.site/2018/04/14/v8_garbage_collection/","description":"前言我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~ 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 为什么要有垃圾回收在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。 不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。","pubDate":"Sat, 14 Apr 2018 08:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/14/v8_garbage_collection/","category":"JavaScript"},{"title":"尾调用和尾递归","link":"//blog.liuxuan.site/2018/04/10/tail_call/","description":"尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: ,","pubDate":"Tue, 10 Apr 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/10/tail_call/","category":"JavaScript"},{"title":"搭建 karma + jasmine 测试环境","link":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","description":"在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。","pubDate":"Tue, 03 Apr 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","category":"前端测试"},{"title":"JS学习系列 07 - 标签声明（Label Statement）","link":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","description":"引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？","pubDate":"Sat, 10 Mar 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","category":"JavaScript"},{"title":"HTML - 移动端 meta viewport","link":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","description":"我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。","pubDate":"Sun, 10 Dec 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","category":"HTML"},{"title":"JS学习系列 06 - 变量对象","link":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","description":"上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明：","pubDate":"Thu, 10 Aug 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","category":"JavaScript"},{"title":"JS学习系列 05 - 执行上下文","link":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","description":"在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。","pubDate":"Sat, 03 Jun 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","category":"JavaScript"},{"title":"JS学习系列 04 - 提升","link":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","description":"到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。","pubDate":"Wed, 10 May 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","category":"JavaScript"},{"title":"JS学习系列 03 - 函数作用域和块作用域","link":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","description":"在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上","pubDate":"Mon, 10 Apr 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","category":"JavaScript"},{"title":"JS学习系列 02 - 词法作用域","link":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","description":"两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。","pubDate":"Sun, 05 Mar 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","category":"JavaScript"},{"title":"JS学习系列 01 - 编译原理和作用域","link":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","description":"在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。","pubDate":"Fri, 10 Feb 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","category":"JavaScript"}]}