{"title":"liuxuan的博客","description":"科大讯飞","language":"zh-Hans","link":"//blog.liuxuan.site","pubDate":"Tue, 10 Apr 2018 13:36:00 GMT","lastBuildDate":"Tue, 10 Apr 2018 13:41:26 GMT","generator":"hexo-generator-json-feed","webMaster":"liuxuan","items":[{"title":"尾调用和尾递归","link":"//blog.liuxuan.site/2018/04/10/tail_call/","description":"尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: , 依次举例：123const a = x =&gt; x ? f() : g();// f() 和 g() 都在尾部。 12345678910111213141516const a = () =&gt; f() || g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return fResult; &#125; else &#123; return g(); // tail call &#125;&#125;// 只有当f()的结果为falsey的时候，g()才是尾调用 12345678910111213141516const a = () =&gt; f() &amp;&amp; g();// g()有可能是尾调用，f()不是// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; const fResult = f(); // not a tail call if (fResult) &#123; return g(); // tail call &#125; else &#123; return fResult; &#125;&#125;// 只有当f()的结果为truthy的时候，g()才是尾调用 12345678910const a = () =&gt; (f() , g());// g()是尾调用// 因为上述写法和下面的写法等效：const a = () =&gt; &#123; f(); return g();&#125; 2. 尾调用优化函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：12345function foo () &#123; console.log(111); &#125;function bar () &#123; foo(); &#125;function baz () &#123; bar(); &#125;baz(); 造成这种结果是因为每个函数在调用另一个函数的时候，并没有 return 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。 baz() 里面调用了 bar() 函数，并没有 return 该调用，所以在调用栈中保持自己的调用帧，同时 bar() 函数的调用帧在调用栈中生成，同理，bar() 函数又调用了 foo() 函数，最后执行到 foo() 函数的时候，没有再调用其他函数，这里没有显示声明 return，所以这里默认 return undefined。 foo() 执行完了，销毁调用栈中自己的记录，依次销毁 bar() 和 baz() 的调用帧，最后完成整个流程。 如果对上面的例子做如下修改：12345function foo () &#123; console.log(111); &#125;function bar () &#123; return foo(); &#125;function baz () &#123; return bar(); &#125;baz(); 这里要注意：尾调用优化只在严格模式下有效。 在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈： func.arguments: 表示对 func最近一次调用所包含的参数 func.caller: 引用对 func最近一次调用的那个函数 在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。 如果尾调用优化生效，流程图就会变成这样： 我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。 这就叫做尾调用优化，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。 尾递归1. 定义先来看一下递归，当一个函数调用自身，就叫做递归。123function foo () &#123; foo();&#125; 上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。 那么什么是尾递归？前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做尾递归。123function foo () &#123; return foo();&#125; 2. 作用那么尾递归相比递归而言，有哪些不同呢？我们通过下面这个求阶乘的例子来看一下：12345678function factorial (num) &#123; if (num === 1) return 1; return num * factorial(num - 1);&#125;factorial(5); // 120factorial(10); // 3628800factorial(500000); // Uncaught RangeError: Maximum call stack size exceeded 上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。 这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。 如果用尾递归来计算阶乘呢？123456789101112131415'use strict';function factorial (num, total) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5, 1); // 120factorial(10, 1); // 3628800factorial(500000, 1); // 分情况// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js// node最新版本已经移除了--harmony_tailcalls功能 通过尾递归，我们把复杂度从O(n)降低到了O(1)，如果数据足够大的话，会节省很多的计算时间。由此可见，尾调用优化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。 避免改写递归函数尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的factorial()函数改写一样。 这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？解决这个问题的办法有两个： 1. ES6参数默认值123456789'use strict';function factorial (num, total = 1) &#123; if (num === 1) return total; return factorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 2. 用一个符合语义的函数去调用改写后的尾递归函数1234567891011function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;function factorial (num) &#123; return tailFactorial(num, 1);&#125;factorial(5); // 120factorial(10); // 3628800 上面这种写法其实有点类似于做了一个函数科里化，但不完全符合科里化的概念。函数科里化是指把接受多个参数的函数转换为接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数。 概念看着很绕口，我们来个例子感受一下：1234567891011121314151617// 普通加法函数function add (x, y, z) &#123; return x + y + z;&#125;add(1, 2, 3); // 6// 改写为科里化加法函数function add (x) &#123; return function (y) &#123; return function (z) &#123; return x + y + z; &#125; &#125;&#125;add(1)(2)(3); // 6 可以看到，科里化函数通过闭包找到父作用域里的变量，最后依次相加输出结果。通过这个例子，可能看不出为什么要用科里化，有什么好处，这个我们以后再谈，这里先引出一个概念。 是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 如果用科里化改写求阶乘的例子：12345678910111213141516171819202122232425262728293031323334353637383940// 科里化函数function curry (fn) &#123; var _fnArgLength = fn.length; function wrap (...args) &#123; var _args = args; var _argLength = _args.length; // 如果传的是所有参数，直接返回fn调用 if (_fnArgLength === _argLength) &#123; return fn.apply(null, args); &#125; function act (...args) &#123; _args = _args.concat(args); if (_args.length === _fnArgLength) &#123; return fn.apply(null, _args); &#125; return act; &#125; return act; &#125; return wrap;&#125;// 尾递归函数function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;// 改写var factorial = curry(tailFactorial);factorial(5)(1); // 120factorial(10)(1); // 3628800 这是符合科里化概念的写法，在阮一峰老师的文章中是这样写的：1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 我个人认为，这种写法其实不是科里化，因为并没有将多参数的tailFacrotial改写为接受单参数的形式，只是换了一种写法，和下面这样写意义是一样的：1234567891011function factorial (num) &#123; return tailFactorial(num, 1);&#125;function tailFactorial (num, total) &#123; if (num === 1) return total; return tailFactorial(num - 1, num * total);&#125;factorial(5); // 120factorial(10); // 3628800 结束这篇文章我们主要讨论了尾调用优化和科里化。要注意的是，经过测试，Chrome和Firefox并没有对尾调用进行优化，Safari对尾调用进行了优化。Node高版本也已经去除了通过–harmony_tailcalls参数启用尾调用优化。 有任何问题，欢迎大家留言讨论~~ 参考链接http://www.ruanyifeng.com/blog/2015/04/tail-call.htmlhttps://juejin.im/post/5a4d898a518825698e7277d1https://github.com/lamdu/lamdu/issues/90","pubDate":"Tue, 10 Apr 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/10/tail_call/","category":"Javascript"},{"title":"搭建 karma + jasmine 测试环境","link":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","description":"在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。","pubDate":"Tue, 03 Apr 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","category":"前端测试"},{"title":"JS学习系列 07 - 标签声明（Label Statement）","link":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","description":"引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？","pubDate":"Sat, 10 Mar 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","category":"JavaScript"},{"title":"HTML - 移动端 meta viewport","link":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","description":"我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。","pubDate":"Sun, 10 Dec 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","category":"HTML"},{"title":"JS学习系列 06 - 变量对象","link":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","description":"上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明：","pubDate":"Thu, 10 Aug 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","category":"JavaScript"},{"title":"JS学习系列 05 - 执行上下文","link":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","description":"在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。","pubDate":"Sat, 03 Jun 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","category":"JavaScript"},{"title":"JS学习系列 04 - 提升","link":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","description":"到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。","pubDate":"Wed, 10 May 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","category":"JavaScript"},{"title":"JS学习系列 03 - 函数作用域和块作用域","link":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","description":"在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上","pubDate":"Mon, 10 Apr 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","category":"JavaScript"},{"title":"JS学习系列 02 - 词法作用域","link":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","description":"两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。","pubDate":"Sun, 05 Mar 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","category":"JavaScript"},{"title":"JS学习系列 01 - 编译原理和作用域","link":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","description":"在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。","pubDate":"Fri, 10 Feb 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","category":"JavaScript"}]}