{"title":"liuxuan的博客","description":"科大讯飞","language":"zh-Hans","link":"//blog.liuxuan.site","pubDate":"Wed, 10 Oct 2018 12:36:00 GMT","lastBuildDate":"Sat, 27 Oct 2018 06:39:09 GMT","generator":"hexo-generator-json-feed","webMaster":"liuxuan","items":[{"title":"带你五步学会Vue SSR","link":"//blog.liuxuan.site/2018/10/10/javascript_vue_ssr/","description":"前言SSR大家肯定都不陌生，通过服务端渲染，可以优化SEO抓取，提升首页加载速度等，我在学习SSR的时候，看过很多文章，有些对我有很大的启发作用，有些就只是照搬官网文档。通过几天的学习，我对SSR有了一些了解，也从头开始完整的配置出了SSR的开发环境，所以想通过这篇文章，总结一些经验，同时希望能够对学习SSR的朋友起到一点帮助。 我会通过五个步骤，一步步带你完成SSR的配置： 纯浏览器渲染 服务端渲染，不包含123456789101112133. 服务端渲染，包含```Ajax```初始化数据4. 服务端渲染，使用```serverBundle```和```clientManifest```进行优化5. 一个完整的基于```Vue + VueRouter + Vuex```的SSR工程&lt;!-- more --&gt;如果你现在对于我上面说的还不太了解，没有关系，跟着我一步步向下走，最终你也可以独立配置一个SSR开发项目，**所有源码我会放到[github](https://github.com/leocoder351/vue-ssr-demo)上，大家可以作为参考**。## 正文### 1. 纯浏览器渲染这个配置相信大家都会，就是基于```weback + vue```的一个常规开发配置，这里我会放一些关键代码，完整代码可以去[github](https://github.com/leocoder351/vue-ssr-demo/tree/master/01)查看。##### 目录结构 node_modules components Bar.vue Foo.vue App.vue app.js index.html webpack.config.js package.json yarn.lock postcss.config.js .babelrc .gitignore12##### app.js import Vue from ‘vue’;import App from ‘./App.vue’; let app = new Vue({ el: ‘#app’, render: h =&gt; h(App)});12##### App.vue import Foo from './components/Foo.vue'; import Bar from './components/Bar.vue'; export default { components: { Foo, Bar } } 12##### index.html 纯浏览器渲染 12##### components/Foo.vue Foo Component .foo { background: yellowgreen; } 12##### components/Bar.vue Bar Component .bar { background: bisque; } 12##### webpack.config.js const path = require('path'); const VueLoaderPlugin = require('vue-loader/lib/plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const ExtractTextPlugin = require('extract-text-webpack-plugin'); module.exports = { mode: 'development', entry: './app.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' }, module: { rules: [ { test: /\\.js$/, use: 'babel-loader' }, { test: /\\.css$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader'] // 如果需要单独抽出CSS文件，用下面这个配置 // use: ExtractTextPlugin.extract({ // fallback: 'vue-style-loader', // use: [ // 'css-loader', // 'postcss-loader' // ] // }) }, { test: /\\.(jpg|jpeg|png|gif|svg)$/, use: { loader: 'url-loader', options: { limit: 10000 // 10Kb } } }, { test: /\\.vue$/, use: 'vue-loader' } ] }, plugins: [ new VueLoaderPlugin(), new HtmlWebpackPlugin({ template: './index.html' }), // 如果需要单独抽出CSS文件，用下面这个配置 // new ExtractTextPlugin(\"styles.css\") ] }; 12##### postcss.config.js module.exports = { plugins: [ require('autoprefixer') ] }; 12##### .babelrc { \"presets\": [ \"@babel/preset-env\" ], \"plugins\": [ // 让其支持动态路由的写法 const Foo = () => import('../components/Foo.vue') \"dynamic-import-webpack\" ] } 123##### package.json { \"name\": \"01\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": { \"start\": \"yarn run dev\", \"dev\": \"webpack-dev-server\", \"build\": \"webpack\" }, \"dependencies\": { \"vue\": \"^2.5.17\" }, \"devDependencies\": { \"@babel/core\": \"^7.1.2\", \"@babel/preset-env\": \"^7.1.0\", \"babel-plugin-dynamic-import-webpack\": \"^1.1.0\", \"autoprefixer\": \"^9.1.5\", \"babel-loader\": \"^8.0.4\", \"css-loader\": \"^1.0.0\", \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\", \"file-loader\": \"^2.0.0\", \"html-webpack-plugin\": \"^3.2.0\", \"postcss\": \"^7.0.5\", \"postcss-loader\": \"^3.0.0\", \"url-loader\": \"^1.1.1\", \"vue-loader\": \"^15.4.2\", \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.5.17\", \"webpack\": \"^4.20.2\", \"webpack-cli\": \"^3.1.2\", \"webpack-dev-server\": \"^3.1.9\" } } 1234##### 命令###### 启动开发环境 yarn start 12###### 构建生产环境 yarn run build 1234567891011121314最终效果截图：![纯浏览器渲染](http://p54fus2hp.bkt.clouddn.com/blog/20181010/browser_render.png)完整代码查看[github](https://github.com/leocoder351/vue-ssr-demo/tree/master/01)### 2. 服务端渲染，不包含```Ajax```初始化数据服务端渲染SSR，类似于同构，最终要让一份代码既可以在服务端运行，也可以在客户端运行。如果说在SSR的过程中出现问题，还可以回滚到纯浏览器渲染，保证用户正常看到页面。那么，顺着这个思路，肯定就会有两个```webpack```的入口文件，一个用于浏览器端渲染```weboack.client.config.js```，一个用于服务端渲染```webpack.server.config.js```，将它们的公有部分抽出来作为```webpack.base.cofig.js```，后续通过```webpack-merge```进行合并。同时，也要有一个```server```来提供```http```服务，我这里用的是```koa```。我们来看一下新的目录结构： - node_modules - config // 新增 - webpack.base.config.js - webpack.client.config.js - webpack.server.config.js - src - components - Bar.vue - Foo.vue - App.vue - app.js - entry-client.js // 新增 - entry-server.js // 新增 - index.html - index.ssr.html // 新增 - package.json - yarn.lock - postcss.config.js - .babelrc - .gitignore 123456在纯客户端应用程序(client-only app)中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染(cross-request state pollution)。所以，我们要对```app.js```做修改，将其包装为一个工厂函数，每次调用都会生成一个全新的根组件。**app.js** import Vue from 'vue'; import App from './App.vue'; export function createApp() { const app = new Vue({ render: h => h(App) }); return { app }; } 1234在浏览器端，我们直接新建一个根组件，然后将其挂载就可以了。**entry-client.js** import { createApp } from './app.js'; const { app } = createApp(); app.$mount('#app'); 1234在服务器端，我们就要返回一个函数，该函数的作用是接收一个```context```参数，同时每次都返回一个新的根组件。这个```context```在这里我们还不会用到，后续的步骤会用到它。**entry-server.js** import { createApp } from './app.js'; export default context => { const { app } = createApp(); return app; } 12然后再来看一下```index.ssr.html **index.ssr.html** 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;服务端渲染&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= htmlWebpackPlugin.options.files.js %&gt;\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910```&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= htmlWebpackPlugin.options.files.js %&gt;&quot;&gt;&lt;/script&gt;```是为了将```webpack```通过```webpack.client.config.js```打包出的文件放到这里（这里是为了简单演示，后续会有别的办法来做这个事情）。因为服务端吐出来的就是一个```html```字符串，后续的```Vue```相关的响应式、事件响应等等，都需要浏览器端来接管，所以就需要将为浏览器端渲染打包的文件在这里引入。用官方的词来说，叫**客户端激活（client-side hydration）**。所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。在 entry-client.js 中，我们用下面这行挂载(mount)应用程序： // 这里假定 App.vue template 根元素的 `id=\"app\"` app.$mount('#app') 1234由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要\"激活\"这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性： 123456```Vue```在浏览器端就依靠这个属性将服务器吐出来的```html```进行激活，我们一会自己构建一下就可以看到了。接下来我们看一下```webpack```相关的配置：**webpack.base.config.js** const path = require('path'); const VueLoaderPlugin = require('vue-loader/lib/plugin'); module.exports = { mode: 'development', resolve: { extensions: ['.js', '.vue'] }, output: { path: path.resolve(__dirname, '../dist'), filename: '[name].bundle.js' }, module: { rules: [ { test: /\\.vue$/, use: 'vue-loader' }, { test: /\\.js$/, use: 'babel-loader' }, { test: /\\.css$/, use: ['vue-style-loader', 'css-loader', 'postcss-loader'] }, { test: /\\.(jpg|jpeg|png|gif|svg)$/, use: { loader: 'url-loader', options: { limit: 10000 // 10Kb } } } ] }, plugins: [ new VueLoaderPlugin() ] }; 12**webpack.client.config.js** const path = require('path'); const merge = require('webpack-merge'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const base = require('./webpack.base.config'); module.exports = merge(base, { entry: { client: path.resolve(__dirname, '../src/entry-client.js') }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve(__dirname, '../src/index.html'), filename: 'index.html' }) ] }); 1234注意，这里的入口文件变成了```entry-client.js```，将其打包出的```client.bundle.js```插入到```index.html```中。**webpack.server.config.js** const path = require('path'); const merge = require('webpack-merge'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const base = require('./webpack.base.config'); module.exports = merge(base, { target: 'node', entry: { server: path.resolve(__dirname, '../src/entry-server.js') }, output: { libraryTarget: 'commonjs2' }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve(__dirname, '../src/index.ssr.html'), filename: 'index.ssr.html', files: { js: 'client.bundle.js' }, excludeChunks: ['server'] }) ] }); 123这里有几个点需要注意一下：1. 入口文件是 ```entry-server.js 2. 因为是打包服务器端依赖的代码，所以123456这里关于```HtmlWebpackPlugin```配置的意思是，不要在```index.ssr.html```中引入打包出的```server.bundle.js```，要引为浏览器打包的```client.bundle.js```，原因前面说过了，是为了让```Vue```可以将服务器吐出来的```html```进行激活，从而接管后续响应。那么打包出的```server.bundle.js```在哪用呢？接着往下看就知道啦~~**package.json** { \"name\": \"01\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": { \"start\": \"yarn run dev\", \"dev\": \"webpack-dev-server\", \"build:client\": \"webpack --config config/webpack.client.config.js\", \"build:server\": \"webpack --config config/webpack.server.config.js\" }, \"dependencies\": { \"koa\": \"^2.5.3\", \"koa-router\": \"^7.4.0\", \"koa-static\": \"^5.0.0\", \"vue\": \"^2.5.17\", \"vue-server-renderer\": \"^2.5.17\" }, \"devDependencies\": { \"@babel/core\": \"^7.1.2\", \"@babel/preset-env\": \"^7.1.0\", \"autoprefixer\": \"^9.1.5\", \"babel-loader\": \"^8.0.4\", \"css-loader\": \"^1.0.0\", \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\", \"file-loader\": \"^2.0.0\", \"html-webpack-plugin\": \"^3.2.0\", \"postcss\": \"^7.0.5\", \"postcss-loader\": \"^3.0.0\", \"style-loader\": \"^0.23.0\", \"url-loader\": \"^1.1.1\", \"vue-loader\": \"^15.4.2\", \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.5.17\", \"webpack\": \"^4.20.2\", \"webpack-cli\": \"^3.1.2\", \"webpack-dev-server\": \"^3.1.9\", \"webpack-merge\": \"^4.1.4\" } } 1234接下来我们看```server```端关于```http```服务的代码：**server/server.js** const Koa = require('koa'); const Router = require('koa-router'); const serve = require('koa-static'); const path = require('path'); const fs = require('fs'); const backendApp = new Koa(); const frontendApp = new Koa(); const backendRouter = new Router(); const frontendRouter = new Router(); const bundle = fs.readFileSync(path.resolve(__dirname, '../dist/server.js'), 'utf-8'); const renderer = require('vue-server-renderer').createBundleRenderer(bundle, { template: fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8') }); // 后端Server backendRouter.get('/index', (ctx, next) => { // 这里用 renderToString 的 promise 返回的 html 有问题，没有样式 renderer.renderToString((err, html) => { if (err) { console.error(err); ctx.status = 500; ctx.body = '服务器内部错误'; } else { console.log(html); ctx.status = 200; ctx.body = html; } }); }); backendApp.use(serve(path.resolve(__dirname, '../dist'))); backendApp .use(backendRouter.routes()) .use(backendRouter.allowedMethods()); backendApp.listen(3000, () => { console.log('服务器端渲染地址： http://localhost:3000'); }); // 前端Server frontendRouter.get('/index', (ctx, next) => { let html = fs.readFileSync(path.resolve(__dirname, '../dist/index.html'), 'utf-8'); ctx.type = 'html'; ctx.status = 200; ctx.body = html; }); frontendApp.use(serve(path.resolve(__dirname, '../dist'))); frontendApp .use(frontendRouter.routes()) .use(frontendRouter.allowedMethods()); frontendApp.listen(3001, () => { console.log('浏览器端渲染地址： http://localhost:3001'); }); 1234这里对两个端口进行监听，3000端口是服务端渲染，3001端口是直接输出```index.html```，然后会在浏览器端走```Vue```的那一套，主要是为了和服务端渲染做对比使用。这里的关键代码是如何在服务端去输出``html```字符串。 const bundle = fs.readFileSync(path.resolve(__dirname, '../dist/server.bundle.js'), 'utf-8'); const renderer = require('vue-server-renderer').createBundleRenderer(bundle, { template: fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8') }); 1234可以看到，```server.bundle.js```在这里被使用啦，因为它的入口是一个函数，接收```context```作为参数（非必传），输出一个根组件```app```。这里我们用到了```vue-server-renderer```插件，它有两个方法可以做渲染，一个是```createRenderer```，另一个是```createBundleRenderer```。 const { createRenderer } = require('vue-server-renderer') const renderer = createRenderer({ /* 选项 */ }) 12 const { createBundleRenderer } = require('vue-server-renderer') const renderer = createBundleRenderer(serverBundle, { /* 选项 */ }) 12345678910```createRenderer```无法接收为服务端打包出的```server.bundle.js```文件，所以这里只能用```createBundleRenderer```。```serverBundle``` 参数可以是以下之一：- 绝对路径，指向一个已经构建好的 ```bundle``` 文件（```.js``` 或 ```.json```）。必须以 ```/``` 开头才会被识别为文件路径。- 由 ```webpack + vue-server-renderer/server-plugin``` 生成的 ```bundle``` 对象。- ```JavaScript``` 代码字符串（不推荐）。这里我们引入的是.js文件，后续会介绍如何使用.json文件以及有什么好处。 renderer.renderToString((err, html) => { if (err) { console.error(err); ctx.status = 500; ctx.body = '服务器内部错误'; } else { console.log(html); ctx.status = 200; ctx.body = html; } }); 123456使用```createRenderer```和```createBundleRenderer```返回的```renderer```函数包含两个方法```renderToString```和```renderToStream```，我们这里用的是```renderToString```成功后直接返回一个完整的字符串，```renderToStream```返回的是一个```Node```流。```renderToString```支持```Promise```，但是我在使用```Prmoise```形式的时候样式会渲染不出来，暂时还不知道原因，如果大家知道的话可以给我留言啊。配置基本就完成了，来看一下如何运行。 yarn run build:client // 打包浏览器端需要bundle yarn run build:server // 打包SSR需要bundle yarn start // 其实就是 node server/server.js，提供http服务 1234最终效果展示：访问```http://localhost:3000/index ![SSR没有ajax数据](http://p54fus2hp.bkt.clouddn.com/blog/20181010/server_render.png) 我们看到了前面提过的123456789101112131415161718192021222324252627282930313233343536访问```http://localhost:3001/index```还和第一步实现的效果一样，纯浏览器渲染，这里就不放截图了。完整代码查看[github](https://github.com/leocoder351/vue-ssr-demo/tree/master/02)### 3. 服务端渲染，包含Ajax初始化数据如果SSR需要初始化一些异步数据，那么流程就会变得复杂一些。 我们先提出几个问题： 1. 服务端拿异步数据的步骤在哪做？ 2. 如何确定哪些组件需要获取异步数据？ 3. 获取到异步数据之后要如何塞回到组件内？ 带着问题我们向下走，希望看完这篇文章的时候上面的问题你都找到了答案。 服务器端渲染和浏览器端渲染组件经过的生命周期是有区别的，**在服务器端，只会经历```beforeCreate```和```created```两个生命周期**。因为SSR服务器直接吐出```html```字符串就好了，不会渲染DOM结构，所以不存在```beforeMount```和```mounted```的，也不会对其进行更新，所以也就不存在```beforeUpdate```和```updated```等。 我们先来想一下，在纯浏览器渲染的```Vue```项目中，我们是怎么获取异步数据并渲染到组件中的？一般是在```created```或者```mounted```生命周期里发起异步请求，然后在成功回调里执行```this.data = xxx```，```Vue```监听到数据发生改变，走后面的```Dom Diff```，打```patch```，做```DOM```更新。 那么服务端渲染可不可以也这么做呢？**答案是不行的**。 1. 在```mounted```里肯定不行，因为```SSR```都没有```mounted```生命周期，所以在这里肯定不行。 2. 在```beforeCreate```里发起异步请求是否可以呢，也是不行的。因为请求是异步的，可能还没有等接口返回，服务端就已经把```html```字符串拼接出来了。 所以，参考一下[官方文档](https://ssr.vuejs.org/guide/data.html)，我们可以得到以下思路： 1. 在渲染前，要预先获取所有需要的异步数据，然后存到```Vuex```的```store```中。 2. 在后端渲染时，通过```Vuex```将获取到的数据注入到相应组件中。 3. 把```store```中的数据设置到```window.__INITIAL_STATE__```属性中。 4. 在浏览器环境中，通过```Vuex```将```window.__INITIAL_STATE__```里面的数据注入到相应组件中。 正常情况下，通过这几个步骤，服务端吐出来的```html```字符串相应组件的数据都是最新的，所以第4步并不会引起```DOM```更新，但如果出了某些问题，吐出来的```html```字符串没有相应数据，```Vue```也可以在浏览器端通过````Vuex```注入数据，进行```DOM```更新。 **更新后的目录结构：** - node_modules - config - webpack.base.config.js - webpack.client.config.js - webpack.server.config.js - src - components - Bar.vue - Foo.vue - store // 新增 store.js - App.vue - app.js - entry-client.js - entry-server.js - index.html - index.ssr.html - package.json - yarn.lock - postcss.config.js - .babelrc - .gitignore 1234先来看一下```store.js```:**store/store.js** import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); const fetchBar = function() { return new Promise((resolve, reject) => { setTimeout(() => { resolve('bar 组件返回 ajax 数据'); }, 1000); }); }; function createStore() { const store = new Vuex.Store({ state: { bar: '' }, mutations: { 'SET_BAR'(state, data) { state.bar = data; } }, actions: { fetchBar({ commit }) { return fetchBar().then((data) => { commit('SET_BAR', data); }).catch((err) => { console.error(err); }) } } }); if (typeof window !== 'undefined' && window.__INITIAL_STATE__) { console.log('window.__INITIAL_STATE__', window.__INITIAL_STATE__); store.replaceState(window.__INITIAL_STATE__); } return store; } export default createStore; typeof window 12345678如果不太了解```Vuex```，可以去[Vuex官网](https://vuex.vuejs.org/)先看一些基本概念。![vuex](https://vuex.vuejs.org/vuex.png)这里```fetchBar```可以看成是一个异步请求，这里用```setTimeout```模拟。在成功回调中```commit```相应的```mutation```进行状态修改。这里有一段关键代码： if (typeof window !== 'undefined' && window.__INITIAL_STATE__) { console.log('window.__INITIAL_STATE__', window.__INITIAL_STATE__); store.replaceState(window.__INITIAL_STATE__); } 1234因为```store.js```同样也会被打包到服务器运行的```server.bundle.js```中，所以运行环境不一定是浏览器，这里需要对```window```做判断，防止报错，同时如果有```window.__INITIAL_STATE__```属性，说明服务器已经把所有初始化需要的异步数据都获取完成了，要对```store```中的状态做一个替换，保证统一。**components/Bar.vue** Bar Component 异步Ajax数据： const fetchInitialData = ({ store }) => { store.dispatch('fetchBar'); }; export default { asyncData: fetchInitialData, methods: { onHandleClick() { alert('bar'); } }, mounted() { // 因为服务端渲染只有 beforeCreate 和 created 两个生命周期，不会走这里 // 所以把调用 Ajax 初始化数据也写在这里，是为了供单独浏览器渲染使用 let store = this.$store; fetchInitialData({ store }); }, computed: { msg() { return this.$store.state.bar; } } } .bar { background: bisque; } 123456这里在```Bar```组件的默认导出对象中增加了一个方法```asyncData```，在该方法中会```dispatch```相应的```action```，进行异步数据获取。**需要注意的是，我在```mounted```中也写了获取数据的代码，这是为什么呢？** 因为想要做到同构，代码单独在浏览器端运行，也应该是没有问题的，又由于服务器没有```mounted```生命周期，所以我写在这里就可以解决单独在浏览器环境使用也可以发起同样的异步请求去初始化数据。**components/Foo.vue** Foo Component export default { methods: { onHandleClick() { alert('foo'); } }, } .foo { background: yellowgreen; } 1234这里我对两个组件都添加了一个点击事件，为的是证明在服务器吐出首页```html```后，后续的步骤都会被浏览器端的```Vue```接管，可以正常执行后面的操作。**app.js** import Vue from ‘vue’;import createStore from ‘./store/store.js’;import App from ‘./App.vue’; export function createApp() { const store = createStore(); const app = new Vue({ store, render: h =&gt; h(App) }); return { app, store, App };}123456在建立根组件的时候，要把```Vuex的store```传进去，同时要返回，后续会用到。最后来看一下```entry-server.js```，关键步骤在这里：**entry-server.js** import { createApp } from ‘./app.js’; export default context =&gt; { return new Promise((resolve, reject) =&gt; { const { app, store, App } = createApp(); let components = App.components; let asyncDataPromiseFns = []; Object.values(components).forEach(component =&gt; { if (component.asyncData) { asyncDataPromiseFns.push(component.asyncData({ store })); } }); Promise.all(asyncDataPromiseFns).then((result) =&gt; { // 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中 context.state = store.state; console.log(222); console.log(store.state); console.log(context.state); console.log(context); resolve(app); }, reject); });}12345678我们通过导出的```App```拿到了所有它下面的```components```，然后遍历，找出哪些```component```有```asyncData```方法，有的话调用并传入```store```，该方法会返回一个```Promise```，我们使用```Promise.all```等所有的异步方法都成功返回，才```resolve(app)```。```context.state = store.state```作用是，当使用```createBundleRenderer```时，如果设置了```template```选项，那么会把```context.state```的值作为```window.__INITIAL_STATE__```自动插入到模板```html```中。**这里需要大家多思考一下，弄清楚整个服务端渲染的逻辑。**如何运行： yarn run build:clientyarn run build:server yarn start1234567891011121314151617181920212223242526272829303132最终效果截图：**服务端渲染：打开```http://localhost:3000/index```**![server-remder-ajax](http://p54fus2hp.bkt.clouddn.com/blog/20181010/server_render_ajax.png)可以看到```window.__INITIAL_STATE__```被自动插入了。我们来对比一下```SSR```到底对加载性能有什么影响吧。**服务端渲染时```performance```截图**：![sercer_render_ajax_performance](http://p54fus2hp.bkt.clouddn.com/blog/20181010/sercer_render_ajax_performance.png)**纯浏览器端渲染时```performance```截图**：![client_render_ajax_performance](http://p54fus2hp.bkt.clouddn.com/blog/20181010/client_render_ajax_performance.png)同样都是在```fast 3G```网络模式下，纯浏览器端渲染首屏加载花费时间**2.9s**，因为```client.js```加载就花费了**2.27s**，因为没有```client.js```就没有```Vue```，也就没有后面的东西了。服务端渲染首屏时间花费**0.8s**，虽然```client.js```加载扔花费```2.27s```，但是首屏已经不需要它了，它是为了让```Vue```在浏览器端进行后续接管。从这我们可以真正的看到，服务端渲染对于提升首屏的响应速度是很有作用的。当然有的同学可能会问，在服务端渲染获取初始```ajax```数据时，我们还延时了1s，在这个时间用户也是看不到页面的。没错，接口的时间我们无法避免，就算是纯浏览器渲染，首页该调接口还是得调，如果接口响应慢，那么纯浏览器渲染看到完整页面的时间会更慢。完整代码查看[github](https://github.com/leocoder351/vue-ssr-demo/tree/master/03)## 4. 使用serverBundle和clientManifest进行优化前面我们创建服务端```renderer```的方法是： const bundle = fs.readFileSync(path.resolve(dirname, ‘../dist/server.js’), ‘utf-8’);const renderer = require(‘vue-server-renderer’).createBundleRenderer(bundle, { template: fs.readFileSync(path.resolve(dirname, ‘../dist/index.ssr.html’), ‘utf-8’)});123456789101112131415```serverBundle```我们用的是打包出的```server.bundle.js```文件。这样做的话，在每次编辑过应用程序源代码之后，都必须停止并重启服务。这在开发过程中会影响开发效率。此外，Node.js 本身不支持 source map。```vue-server-renderer``` 提供一个名为 ```createBundleRenderer``` 的 API，用于处理此问题，通过使用 ```webpack``` 的自定义插件，```server bundle``` 将生成为可传递到 ```bundle renderer``` 的特殊 ```JSON``` 文件。所创建的 ```bundle renderer```，用法和普通 ```renderer``` 相同，但是 ```bundle renderer``` 提供以下优点：- 内置的 ```source map``` 支持（在 ```webpack``` 配置中使用 ```devtool: 'source-map'```）- 在开发环境甚至部署过程中热重载（通过读取更新后的 ```bundle```，然后重新创建 ```renderer``` 实例）- 关键 ```CSS(critical CSS)``` 注入（在使用 ```*.vue``` 文件时）：自动内联在渲染过程中用到的组件所需的```CSS```。更多细节请查看 ```CSS``` 章节。- 使用 ```clientManifest``` 进行资源注入：自动推断出最佳的预加载(```preload```)和预取(```prefetch```)指令，以及初始渲染所需的代码分割 ```chunk```。```preload```和```prefetch```有不了解的话可以自行查一下它们的作用哈。那么我们来修改```webpack```配置：**webpack.client.config.js** const path = require(‘path’);const merge = require(‘webpack-merge’);const HtmlWebpackPlugin = require(‘html-webpack-plugin’);const VueSSRClientPlugin = require(‘vue-server-renderer/client-plugin’);const base = require(‘./webpack.base.config’); module.exports = merge(base, { entry: { client: path.resolve(__dirname, ‘../src/entry-client.js’) }, plugins: [ new VueSSRClientPlugin(), // 新增 new HtmlWebpackPlugin({ template: path.resolve(__dirname, ‘../src/index.html’), filename: ‘index.html’ }) ]});12**webpack.server.config.js** const path = require(‘path’);const merge = require(‘webpack-merge’);const nodeExternals = require(‘webpack-node-externals’);const HtmlWebpackPlugin = require(‘html-webpack-plugin’);const VueSSRServerPlugin = require(‘vue-server-renderer/server-plugin’);const base = require(‘./webpack.base.config’); module.exports = merge(base, { target: ‘node’, // 对 bundle renderer 提供 source map 支持 devtool: ‘#source-map’, entry: { server: path.resolve(dirname, ‘../src/entry-server.js’) }, externals: [nodeExternals()], // 新增 output: { libraryTarget: ‘commonjs2’ }, plugins: [ new VueSSRServerPlugin(), // 这个要放到第一个写，否则 CopyWebpackPlugin 不起作用，原因还没查清楚 new HtmlWebpackPlugin({ template: path.resolve(dirname, ‘../src/index.ssr.html’), filename: ‘index.ssr.html’, files: { js: ‘client.bundle.js’ }, excludeChunks: [‘server’] }) ]});123456因为是服务端引用模块，所以不需要打包```node_modules```中的依赖，直接在代码中```require```引用就好，所以配置```externals: [nodeExternals()]```。两个配置文件会分别生成```vue-ssr-client-manifest.json```和```vue-ssr-server-bundle.json```。作为```createBundleRenderer```的参数。来看```server.js server.js 123456789const serverBundle = require(path.resolve(__dirname, '../dist/vue-ssr-server-bundle.json'));const clientManifest = require(path.resolve(__dirname, '../dist/vue-ssr-client-manifest.json'));const template = fs.readFileSync(path.resolve(__dirname, '../dist/index.ssr.html'), 'utf-8');const renderer = createBundleRenderer(serverBundle, &#123; runInNewContext: false, template: template, clientManifest: clientManifest&#125;); 效果和第三步就是一样的啦，就不截图了，完整代码查看github。 5. 配置一个完整的基于Vue + VueRouter + Vuex的SSR这里和第四步不一样的是引入了1234在```src```下新增```router```目录。**router/index.js** import Vue from ‘vue’;import Router from ‘vue-router’;import Bar from ‘../components/Bar.vue’; Vue.use(Router); function createRouter() { const routes = [ { path: ‘/bar’, component: Bar }, { path: ‘/foo’, component: () =&gt; import(‘../components/Foo.vue’) // 异步路由 } ]; const router = new Router({ mode: ‘history’, routes }); return router;} export default createRouter;123456这里我们把```Foo```组件作为一个异步组件引入，做成按需加载。在```app.js```中引入```router```，并导出：**app.js** import Vue from ‘vue’;import createStore from ‘./store/store.js’;import createRouter from ‘./router’;import App from ‘./App.vue’; export function createApp() { const store = createStore(); const router = createRouter(); const app = new Vue({ router, store, render: h =&gt; h(App) }); return { app, store, router, App };}1234修改```App.vue```引入路由组件：**App.vue** Goto Bar Goto Foo export default { beforeCreate() { console.log(‘App.vue beforeCreate’); }, created() { console.log(‘App.vue created’); }, beforeMount() { console.log(‘App.vue beforeMount’); }, mounted() { console.log(‘App.vue mounted’); }}1234最重要的修改在```entry-server.js```中，**entry-server.js** import { createApp } from ‘./app.js’; export default context =&gt; { return new Promise((resolve, reject) =&gt; { const { app, store, router, App } = createApp(); router.push(context.url); router.onReady(() =&gt; { const matchedComponents = router.getMatchedComponents(); console.log(context.url) console.log(matchedComponents) if (!matchedComponents.length) { return reject({ code: 404 }); } Promise.all(matchedComponents.map(component =&gt; { if (component.asyncData) { return component.asyncData({ store }); } })).then(() =&gt; { // 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中 context.state = store.state; // 返回根组件 resolve(app); }); }, reject); });}1234567891011121314151617181920这里前面提到的```context```就起了大作用，它将用户访问的```url```地址传进来，供```vue-router```使用。因为有异步组件，所以在```router.onReady```的成功回调中，去找该```url```路由所匹配到的组件，获取异步数据那一套还和前面的一样。于是，我们就完成了一个基本完整的基于```Vue + VueRouter + Vuex```SSR配置，完成代码查看[github](https://github.com/leocoder351/vue-ssr-demo/tree/master/05)。最终效果演示：访问```http://localhost:3000/bar```：![ssr-router](http://p54fus2hp.bkt.clouddn.com/blog/20181010/ssr_router.png)完整代码查看[github](https://github.com/leocoder351/vue-ssr-demo/tree/master/05)## 后续上面我们通过五个步骤，完成了从纯浏览器渲染到完整服务端渲染的同构，代码既可以运行在浏览器端，也可以运行在服务器端。那么，回过头来我们在看一下是否有优化的空间，又或者有哪些扩展的思考。##### 1. 优化- 我们目前是使用```renderToString```方法，完全生成```html```后，才会向客户端返回，如果使用```renderToStream```，应用```bigpipe```技术可以向浏览器持续不断的返回一个流，那么文件的加载浏览器可以尽早的显示一些东西出来。 const stream = renderer.renderToStream(context)12返回的值是 ```Node.js stream```： let html = ‘’ stream.on(‘data’, data =&gt; { html += data.toString()}) stream.on(‘end’, () =&gt; { console.log(html) // 渲染完成}) stream.on(‘error’, err =&gt; { // handle error…})` 在流式渲染模式下，当 renderer 遍历虚拟 DOM 树(virtual DOM tree)时，会尽快发送数据。这意味着我们可以尽快获得”第一个 chunk“，并开始更快地将其发送给客户端。 然而，当第一个数据 chunk 被发出时，子组件甚至可能不被实例化，它们的生命周期钩子也不会被调用。这意味着，如果子组件需要在其生命周期钩子函数中，将数据附加到渲染上下文(render context)，当流(stream)启动时，这些数据将不可用。这是因为，大量上下文信息(context information)（如头信息(head information)或内联关键 CSS(inline critical CSS)）需要在应用程序标记(markup)之前出现，我们基本上必须等待流(stream)完成后，才能开始使用这些上下文数据。 因此，如果你依赖由组件生命周期钩子函数填充的上下文数据，则不建议使用流式传输模式。 webpack优化 webpack优化又是一个大的话题了，这里不展开讨论，感兴趣的同学可以自行查找一些资料，后续我也可能会专门写一篇文章来讲webpack优化。 2. 思考 是否必须使用vuex？ 答案是不用。Vuex只是为了帮助你实现一套数据存储、更新、获取的机制，入股你不用Vuex，那么你就必须自己想一套方案可以将异步获取到的数据存起来，并且在适当的时机将它注入到组件内，有一些文章提出了一些方案，我会放到参考文章里，大家可以阅读一下。 是否使用SSR就一定好？ 这个也是不一定的，任何技术都有使用场景。SSR可以帮助你提升首页加载速度，优化搜索引擎SEO，但同时由于它需要在node中渲染整套Vue的模板，会占用服务器负载，同时只会执行beforeCreate和created两个生命周期，对于一些外部扩展库需要做一定处理才可以在SSR中运行等等。 结语本文通过五个步骤，从纯浏览器端渲染开始，到配置一个完整的基于Vue + vue-router + Vuex的SSR环境，介绍了很多新的概念，也许你看完一遍不太理解，那么结合着源码，去自己手敲几遍，然后再来看几遍文章，相信你一定可以掌握SSR。 最后，本文所有源代码都放在我的github上，如果对你有帮助的话，就来点一个赞吧~~ 参考链接 https://ssr.vuejs.org/zh/ https://zhuanlan.zhihu.com/p/35871344 http://www.cnblogs.com/qingmingsang/articles/8719679.html https://juejin.im/entry/590ca74b2f301e006c10465f https://github.com/youngwind/blog/issues/112","pubDate":"Wed, 10 Oct 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/10/10/javascript_vue_ssr/","category":"JavaScript"},{"title":"从0到1实现Promise","link":"//blog.liuxuan.site/2018/09/28/javascript_promise/","description":"前言Promise大家一定都不陌生了，JavaScript异步流程从最初的Callback，到Promise，到Generator，再到目前使用最多的Async/Await（如果对于这些不熟悉的可以参考我另一篇文章《JavaScript异步编程》），这不仅仅是技术实现的发展，更是思想上对于如何控制异步的递进。Promise作为后续方案的基础，是重中之重，也是面试时候最常被问到的。 今天我们就一起从0到1实现一个基于A+规范的Promise，过程中也会对Promise的异常处理，以及是否可手动终止做一些讨论，最后会对我们实现的Promise做单元测试。完整的代码已经上传到github，想直接看代码的可以点这里。 虽然已经有很多带你实现Promise类的文章了，但每个人理解的程度不一样，也许不同的文章可以带给你不同的思考呢，那我们就开始吧。","pubDate":"Fri, 28 Sep 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/09/28/javascript_promise/","category":"JavaScript"},{"title":"带你彻底弄懂Event Loop","link":"//blog.liuxuan.site/2018/09/05/javascript_eventloop/","description":"前言我在学习浏览器和NodeJS的Event Loop时看了大量的文章，那些文章都写的很好，但是往往是每篇文章有那么几个关键的点，很多篇文章凑在一起综合来看，才可以对这些概念有较为深入的理解。 于是，我在看了大量文章之后，想要写这么一篇博客，不采用官方的描述，结合自己的理解以及示例代码，用最通俗的语言表达出来。希望大家可以通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。如果在文中出现书写错误的地方，欢迎大家留言一起探讨。 （PS：说到Event Loop肯定会提到Promise，我根据Promise A+规范自己实现了一个简易Promise库，源码放到Github上，大家有需要的可以当做参考，后续我也会也写一篇博客来讲Promise，如果对你有用，就请给个Star吧~）","pubDate":"Wed, 05 Sep 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/09/05/javascript_eventloop/","category":"JavaScript"},{"title":"JavaScript实现函数重载","link":"//blog.liuxuan.site/2018/08/29/javascript_function_overload/","description":"概念重载是指函数或者方法有相同的名称，但是参数个数或类型不相同的情形，这样的同名不同参的函数或者方法之间，互相称之为重载函数或方法。 我们知道，JavaScript函数可以随意传递任意数量、任意类型的参数，那么它有没有重载呢？ 答案是有的，下面我们通过3种方法来实现JavaScript的函数重载。","pubDate":"Wed, 29 Aug 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/08/29/javascript_function_overload/","category":"JavaScript"},{"title":"JavaScript实现继承","link":"//blog.liuxuan.site/2018/08/28/javascript_extend/","description":"简介本文不准备深入细节，主要是对《JavaScript高级程序设计中》介绍的JS如何实现继承做一个总结，毕竟好记性不如烂笔头。文末会附带一张神图，搞清楚这张图，原型链也就没有什么问题了。","pubDate":"Tue, 28 Aug 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/08/28/javascript_extend/","category":"JavaScript"},{"title":"JavaScript数据结构04 - 链表","link":"//blog.liuxuan.site/2018/08/03/javascript_data_structure_04_linked_list/","description":"一、定义1.1 概念前面我们学习了数组这种数据结构。数组（或者也可以称为列表）是一种非常简单的存储数据序列的数据结构。在这一节，我们要学习如何实现和使用链表这种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩容。 要存储多个元素，数组（或列表）可能是最常用的数据结构，它提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数强类型语言中）数组的大小是固定的，需要预先分配，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（注意：在JavaScript中数组的大小随时可变，不需要预先定义长度） 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。","pubDate":"Fri, 03 Aug 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/08/03/javascript_data_structure_04_linked_list/","category":"JavaScript"},{"title":"JavaScript数据结构03 - 队列","link":"//blog.liuxuan.site/2018/07/26/javascript_data_structure_03_queue/","description":"一、定义前面我们学习了栈的实现，队列和栈非常类似，但是使用了不同的原则，而非后进先出。 队列是遵循FIFO（First In First Out，先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 在计算机科学中，一个最常见的例子就是打印队列。比如说我们要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。","pubDate":"Thu, 26 Jul 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/26/javascript_data_structure_03_queue/","category":"JavaScript"},{"title":"JavaScript数据结构02 - 栈","link":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/","description":"一、定义1.1 背景通过前面一节《JavaScript数据结构01 - 数组》我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。 有两种数据结构类似于数组，但在添加和删除元素时更为可控。 它们就是栈和队列。 1.2 概念栈是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。","pubDate":"Wed, 25 Jul 2018 14:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/","category":"JavaScript"},{"title":"JavaScript数据结构01 - 数组","link":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/","description":"一、创建数组1.1 使用Array构造函数123var arr1 = new Array(); // 创建一个空数组var arr2 = new Array(10); // 创建一个包含20项的数组var arr3 = new Array('liu', 'wang', 'li'); // 创建一个包含3个字符串的数组 1.2 使用数组字面量表示法123var arr1 = []; // 创建一个空数组var arr2 = [10]; // 创建一个包含1项的数组var arr3 = ['liu', 'wang', 'li']; // 创建一个包含3个字符串的数组","pubDate":"Wed, 25 Jul 2018 08:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/","category":"JavaScript"},{"title":"JavaScript异步编程","link":"//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/","description":"前言从我们一开始学习JavaScript的时候就听到过一段话：JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。 但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。 本文也会同步到我的个人网站。","pubDate":"Fri, 20 Jul 2018 12:36:00 GMT","guid":"//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/","category":"异步编程"},{"title":"看图学HTTPS","link":"//blog.liuxuan.site/2018/05/21/learn_https_through_photos/","description":"前言之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。 我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。 本文也会同步到我的个人网站。 正文HTTP是什么样的？HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述： 客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。","pubDate":"Mon, 21 May 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/05/21/learn_https_through_photos/","category":"HTTP"},{"title":"聊聊V8引擎的垃圾回收","link":"//blog.liuxuan.site/2018/04/14/v8_garbage_collection/","description":"前言我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~ 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 为什么要有垃圾回收在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。 不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。","pubDate":"Sat, 14 Apr 2018 08:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/14/v8_garbage_collection/","category":"JavaScript"},{"title":"尾调用和尾递归","link":"//blog.liuxuan.site/2018/04/10/tail_call/","description":"尾调用1. 定义尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。 注意这里函数的调用方式是无所谓的，以下方式均可：1234函数调用: func(···)方法调用: obj.method(···)call调用: func.call(···)apply调用: func.apply(···) 并且只有下列表达式会包含尾调用：1234条件操作符: ? :逻辑或: ||逻辑与: &amp;&amp;逗号: ,","pubDate":"Tue, 10 Apr 2018 13:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/10/tail_call/","category":"JavaScript"},{"title":"搭建 karma + jasmine 测试环境","link":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","description":"在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。 什么是 karmakarma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma1$ npm install karma -D 这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。 初始化1$ ./node-modules/.bin/karma init 这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli1$ npm install karma-cli -g 以后就可以在任何路径执行 karma start 并且运行的 karma 都是在当前项目下安装的版本。","pubDate":"Tue, 03 Apr 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/","category":"前端测试"},{"title":"JS学习系列 07 - 标签声明（Label Statement）","link":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","description":"引言假设有这么一道题：12345678for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); &#125;&#125;console.log('done'); 我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？ 可能有的同学会想到这样：1234567891011121314function foo () &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(i); for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 2) return; &#125; &#125;&#125;foo();console.log('done'); 这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？","pubDate":"Sat, 10 Mar 2018 02:36:00 GMT","guid":"//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/","category":"JavaScript"},{"title":"HTML - 移动端 meta viewport","link":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","description":"我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 viewport 到底是什么。 单位在讨论 viewport 之前，我们需要理解一些单位的概念： 设备像素 / 物理像素（physical pixels）是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。","pubDate":"Sun, 10 Dec 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/12/10/html_meta_viewport/","category":"HTML"},{"title":"JS学习系列 06 - 变量对象","link":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","description":"上一节我们讨论了执行上下文，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。 变量对象就是执行上下文和作用域链中间的桥梁。剧透一下，神秘的 this 就存在于执行上下文环境之中！当然，之后我会单独用几节来彻底讲明白 this 到底是什么（其实 this 很简单）。 接下来，我们进入正文。 执行上下文包含什么一个执行上下文我们可以抽象的理解为对象（object）。每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。 我用一个结构图来说明：","pubDate":"Thu, 10 Aug 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/","category":"JavaScript"},{"title":"JS学习系列 05 - 执行上下文","link":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","description":"在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：执行上下文、变量对象和作用域链。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。 这一章我们就来讨论一下到底什么是执行上下文。 定义当 JS 引擎开始执行预编译生成的代码时，就会进入到一个执行上下文（Executable Code - 简称 EC）。 在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。 但是在逻辑上，我们可以将活动的执行上下文看成一个栈结构。栈底部永远是全局上下文（global context），而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。","pubDate":"Sat, 03 Jun 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/","category":"JavaScript"},{"title":"JS学习系列 04 - 提升","link":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","description":"到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。 但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。","pubDate":"Wed, 10 May 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/","category":"JavaScript"},{"title":"JS学习系列 03 - 函数作用域和块作用域","link":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","description":"在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。 今天，我们就来深入研究一下函数作用域和块作用域。 函数中的作用域函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。 举个例子：1234567891011121314function foo (a) &#123; var b = 2; // something else function bar () &#123; // something else &#125; var c = 3;&#125;bar(); // 报错，ReferenceError: bar is not definedconsole.log(a, b, c); // 报错，原因同上","pubDate":"Mon, 10 Apr 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/","category":"JavaScript"},{"title":"JS学习系列 02 - 词法作用域","link":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","description":"两种作用域“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 作用域有两种主要工作模型：词法作用域和动态作用域。 大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。 词法大部分标准语言编译器的第一个工作阶段叫作词法化。简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。","pubDate":"Sun, 05 Mar 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/","category":"JavaScript"},{"title":"JS学习系列 01 - 编译原理和作用域","link":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","description":"在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。 这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。","pubDate":"Fri, 10 Feb 2017 02:36:00 GMT","guid":"//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/","category":"JavaScript"}]}