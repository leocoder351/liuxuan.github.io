<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuxuan的博客</title>
  <icon>https://www.gravatar.com/avatar/19bc11b7d38a5520912b73217b1993fc</icon>
  <subtitle>苍山如海, 残阳如血</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//blog.liuxuan.site/"/>
  <updated>2019-12-08T05:13:05.582Z</updated>
  <id>//blog.liuxuan.site/</id>
  
  <author>
    <name>liuxuan</name>
    <email>619962351@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微前端落地系列（第0篇）：技术选型</title>
    <link href="//blog.liuxuan.site/2019/12/08/micro-frontend-series-0/"/>
    <id>//blog.liuxuan.site/2019/12/08/micro-frontend-series-0/</id>
    <published>2019-12-08T05:00:00.000Z</published>
    <updated>2019-12-08T05:13:05.582Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20191208/microfrontend.png?imageView2/1/w/1000/h/400" alt="https"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>微前端，相信大家就算没用过，也一定听过。什么是微前端，为什么要上微前端，它和iframe的区别是什么，大家在网上可以找到很多相关的文章，这里就不在赘述了。我想通过这个《微前端落地系列》，把我对某个公有云系统做整体微前端架构改进的过程分享出来，向大家展示一条真正走过的路，踩过的坑。希望在此过程中，能和大家一起讨论，一起学习，一起进步。</p><a id="more"></a><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li><a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener">Single-Spa</a></li><li><a href="https://github.com/CanopyTax/single-spa" target="_blank" rel="noopener">Vue</a></li><li><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">ElementUI</a></li><li><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">webpack</a></li><li><a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">gulp</a></li><li><a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener">SystemJS</a></li></ul><h2 id="前端架构演进"><a href="#前端架构演进" class="headerlink" title="前端架构演进"></a>前端架构演进</h2><p><img src="http://image.liuxuan.site/blog/20190808/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84.jpg" alt=""></p><h2 id="微前端概览"><a href="#微前端概览" class="headerlink" title="微前端概览"></a>微前端概览</h2><p><img src="http://image.liuxuan.site/blog/20190808/%E6%A6%82%E8%A7%88.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20191208/microfrontend.png?imageView2/1/w/1000/h/400&quot; alt=&quot;https&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;微前端，相信大家就算没用过，也一定听过。什么是微前端，为什么要上微前端，它和iframe的区别是什么，大家在网上可以找到很多相关的文章，这里就不在赘述了。我想通过这个《微前端落地系列》，把我对某个公有云系统做整体微前端架构改进的过程分享出来，向大家展示一条真正走过的路，踩过的坑。希望在此过程中，能和大家一起讨论，一起学习，一起进步。&lt;/p&gt;
    
    </summary>
    
      <category term="微前端" scheme="//blog.liuxuan.site/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="微前端" scheme="//blog.liuxuan.site/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
      <category term="single-spa" scheme="//blog.liuxuan.site/tags/single-spa/"/>
    
  </entry>
  
  <entry>
    <title>带你五步学会Vue SSR</title>
    <link href="//blog.liuxuan.site/2018/10/10/javascript_vue_ssr/"/>
    <id>//blog.liuxuan.site/2018/10/10/javascript_vue_ssr/</id>
    <published>2018-10-10T12:36:00.000Z</published>
    <updated>2018-11-11T08:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/vuessr.png?imageView2/1/w/1000/h/400" alt="stack"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSR大家肯定都不陌生，通过服务端渲染，可以优化SEO抓取，提升首页加载速度等，我在学习SSR的时候，看过很多文章，有些对我有很大的启发作用，有些就只是照搬官网文档。通过几天的学习，我对SSR有了一些了解，也从头开始完整的配置出了SSR的开发环境，所以想通过这篇文章，总结一些经验，同时希望能够对学习SSR的朋友起到一点帮助。</p><p>我会通过五个步骤，一步步带你完成SSR的配置：</p><ol><li>纯浏览器渲染</li><li>服务端渲染，不包含Ajax初始化数据</li><li>服务端渲染，包含Ajax初始化数据</li><li>服务端渲染，使用serverBundle和clientManifest进行优化</li><li>一个完整的基于Vue + VueRouter + Vuex的SSR工程</li></ol><p>如果你现在对于我上面说的还不太了解，没有关系，跟着我一步步向下走，最终你也可以独立配置一个SSR开发项目，<strong>所有源码我会放到<a href="https://github.com/leocoder351/vue-ssr-demo" target="_blank" rel="noopener">github</a>上，大家可以作为参考</strong>。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-纯浏览器渲染"><a href="#1-纯浏览器渲染" class="headerlink" title="1. 纯浏览器渲染"></a>1. 纯浏览器渲染</h3><p>这个配置相信大家都会，就是基于weback + vue的一个常规开发配置，这里我会放一些关键代码，完整代码可以去<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/01" target="_blank" rel="noopener">github</a>查看。</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> node_modules</span></span><br><span class="line"><span class="ruby">- components  </span></span><br><span class="line"><span class="ruby">    - Bar.vue</span></span><br><span class="line"><span class="ruby">    - Foo.vue</span></span><br><span class="line"><span class="ruby">- App.vue</span></span><br><span class="line"><span class="ruby">- app.js</span></span><br><span class="line"><span class="ruby">- index.html</span></span><br><span class="line"><span class="ruby">- webpack.config.js</span></span><br><span class="line"><span class="ruby">- package.json</span></span><br><span class="line"><span class="ruby">- yarn.lock</span></span><br><span class="line"><span class="ruby">- postcss.config.js</span></span><br><span class="line"><span class="ruby">- .babelrc</span></span><br><span class="line"><span class="ruby">- .gitignore</span></span><br></pre></td></tr></table></figure><h5 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Foo</span>&gt;</span><span class="tag">&lt;/<span class="name">Foo</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Bar</span>&gt;</span><span class="tag">&lt;/<span class="name">Bar</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">import Foo from './components/Foo.vue';</span></span><br><span class="line"><span class="xml">import Bar from './components/Bar.vue';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default </span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  components: &#123;</span></span><br><span class="line"><span class="template-variable">    Foo, Bar</span></span><br><span class="line"><span class="template-variable">  &#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>纯浏览器渲染<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="components-Foo-vue"><a href="#components-Foo-vue" class="headerlink" title="components/Foo.vue"></a>components/Foo.vue</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Foo Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.foo</span> &#123;</span></span><br><span class="line"><span class="undefined">  background: yellowgreen;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="components-Bar-vue"><a href="#components-Bar-vue" class="headerlink" title="components/Bar.vue"></a>components/Bar.vue</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Bar Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.bar</span> &#123;</span></span><br><span class="line"><span class="undefined">  background: bisque;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">  entry: <span class="string">'./app.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'vue-style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">        <span class="comment">// 如果需要单独抽出CSS文件，用下面这个配置</span></span><br><span class="line">        <span class="comment">// use: ExtractTextPlugin.extract(&#123;</span></span><br><span class="line">        <span class="comment">//   fallback: 'vue-style-loader',</span></span><br><span class="line">        <span class="comment">//   use: [</span></span><br><span class="line">        <span class="comment">//     'css-loader',</span></span><br><span class="line">        <span class="comment">//     'postcss-loader'</span></span><br><span class="line">        <span class="comment">//   ]</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|jpeg|png|gif|svg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>    <span class="comment">// 10Kb</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 如果需要单独抽出CSS文件，用下面这个配置</span></span><br><span class="line">    <span class="comment">// new ExtractTextPlugin("styles.css")</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="postcss-config-js"><a href="#postcss-config-js" class="headerlink" title="postcss.config.js"></a>postcss.config.js</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    // 让其支持动态路由的写法 const Foo = () =&gt; import('../components/Foo.vue')</span><br><span class="line">    <span class="string">"dynamic-import-webpack"</span>    </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"01"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"yarn run dev"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.5.17"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.1.2"</span>,</span><br><span class="line">    <span class="attr">"@babel/preset-env"</span>: <span class="string">"^7.1.0"</span>,</span><br><span class="line">    <span class="attr">"babel-plugin-dynamic-import-webpack"</span>: <span class="string">"^1.1.0"</span>,</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^9.1.5"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.0.4"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"extract-text-webpack-plugin"</span>: <span class="string">"^4.0.0-beta.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^2.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"postcss"</span>: <span class="string">"^7.0.5"</span>,</span><br><span class="line">    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^1.1.1"</span>,</span><br><span class="line">    <span class="attr">"vue-loader"</span>: <span class="string">"^15.4.2"</span>,</span><br><span class="line">    <span class="attr">"vue-style-loader"</span>: <span class="string">"^4.1.2"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.5.17"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.20.2"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.1.2"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.1.9"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><h6 id="启动开发环境"><a href="#启动开发环境" class="headerlink" title="启动开发环境"></a>启动开发环境</h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="literal">start</span></span><br></pre></td></tr></table></figure><h6 id="构建生产环境"><a href="#构建生产环境" class="headerlink" title="构建生产环境"></a>构建生产环境</h6><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">run</span><span class="bash"> build</span></span><br></pre></td></tr></table></figure><p>最终效果截图：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20181010/browser_render.png" alt="纯浏览器渲染"></p><p>完整代码查看<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/01" target="_blank" rel="noopener">github</a></p><h3 id="2-服务端渲染，不包含Ajax初始化数据"><a href="#2-服务端渲染，不包含Ajax初始化数据" class="headerlink" title="2. 服务端渲染，不包含Ajax初始化数据"></a>2. 服务端渲染，不包含Ajax初始化数据</h3><p>服务端渲染SSR，类似于同构，最终要让一份代码既可以在服务端运行，也可以在客户端运行。如果说在SSR的过程中出现问题，还可以回滚到纯浏览器渲染，保证用户正常看到页面。</p><p>那么，顺着这个思路，肯定就会有两个webpack的入口文件，一个用于浏览器端渲染weboack.client.config.js，一个用于服务端渲染webpack.server.config.js，将它们的公有部分抽出来作为webpack.base.cofig.js，后续通过webpack-merge进行合并。同时，也要有一个server来提供http服务，我这里用的是koa。</p><p>我们来看一下新的目录结构：</p><h5 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> node_modules</span></span><br><span class="line"><span class="ruby">- config    /<span class="regexp">/ 新增</span></span></span><br><span class="line"><span class="ruby">    - webpack.base.config.js</span></span><br><span class="line"><span class="ruby">    - webpack.client.config.js</span></span><br><span class="line"><span class="ruby">    - webpack.server.config.js</span></span><br><span class="line"><span class="ruby">- src</span></span><br><span class="line"><span class="ruby">    - components  </span></span><br><span class="line"><span class="ruby">        - Bar.vue</span></span><br><span class="line"><span class="ruby">        - Foo.vue</span></span><br><span class="line"><span class="ruby">    - App.vue</span></span><br><span class="line"><span class="ruby">    - app.js</span></span><br><span class="line"><span class="ruby">    - entry-client.js   /<span class="regexp">/ 新增</span></span></span><br><span class="line"><span class="ruby">    - entry-server.js   /<span class="regexp">/ 新增</span></span></span><br><span class="line"><span class="ruby">    - index.html</span></span><br><span class="line"><span class="ruby">    - index.ssr.html    /<span class="regexp">/ 新增</span></span></span><br><span class="line"><span class="ruby">- package.json</span></span><br><span class="line"><span class="ruby">- yarn.lock</span></span><br><span class="line"><span class="ruby">- postcss.config.js</span></span><br><span class="line"><span class="ruby">- .babelrc</span></span><br><span class="line"><span class="ruby">- .gitignore</span></span><br></pre></td></tr></table></figure><p>在纯客户端应用程序(client-only app)中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染(cross-request state pollution)。</p><p>所以，我们要对app.js做修改，将其包装为一个工厂函数，每次调用都会生成一个全新的根组件。</p><p><strong>app.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; app &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器端，我们直接新建一个根组件，然后将其挂载就可以了。</p><p><strong>entry-client.js</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from './<span class="keyword">app</span>.js';</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">app</span> &#125; = createApp();</span><br><span class="line"></span><br><span class="line"><span class="keyword">app</span>.<span class="variable">$mount</span>('#<span class="keyword">app</span>');</span><br></pre></td></tr></table></figure><p>在服务器端，我们就要返回一个函数，该函数的作用是接收一个context参数，同时每次都返回一个新的根组件。这个context在这里我们还不会用到，后续的步骤会用到它。</p><p><strong>entry-server.js</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; from <span class="string">'./app.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app &#125; = createApp();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再来看一下index.ssr.html</p><p><strong>index.ssr.html</strong></p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>服务端渲染<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&lt;%=</span></span></span><span class="ruby"> htmlWebpackPlugin.options.files.js </span><span class="xml"><span class="tag"><span class="string">%&gt;"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><!--vue-ssr-outlet-->的作用是作为一个占位符，后续通过vue-server-renderer插件，将服务器解析出的组件html字符串插入到这里。<br><br><script type="text/javascript" src="<%= htmlWebpackPlugin.options.files.js %>"></script>是为了将webpack通过webpack.client.config.js打包出的文件放到这里（这里是为了简单演示，后续会有别的办法来做这个事情）。<br><br>因为服务端吐出来的就是一个html字符串，后续的Vue相关的响应式、事件响应等等，都需要浏览器端来接管，所以就需要将为浏览器端渲染打包的文件在这里引入。<br><br>用官方的词来说，叫<strong>客户端激活（client-side hydration）</strong>。<br><br>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。<br><br>在 entry-client.js 中，我们用下面这行挂载(mount)应用程序：<br><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 这里假定 App.vue template 根元素的 `id=<span class="string">"app"</span>`</span><br><span class="line">app.<span class="variable">$mount</span>(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p><p>如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="attribute">id</span>=<span class="string">"app"</span> <span class="attribute">data-server-rendered</span>=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure><p>Vue在浏览器端就依靠这个属性将服务器吐出来的html进行激活，我们一会自己构建一下就可以看到了。</p><p>接下来我们看一下webpack相关的配置：</p><p><strong>webpack.base.config.js</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'vue-style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|jpeg|png|gif|svg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>    <span class="comment">// 10Kb</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>webpack.client.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    client: path.resolve(__dirname, <span class="string">'../src/entry-client.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../src/index.html'</span>),</span><br><span class="line">      filename: <span class="string">'index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，这里的入口文件变成了entry-client.js，将其打包出的client.bundle.js插入到index.html中。</p><p><strong>webpack.server.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    server: path.resolve(__dirname, <span class="string">'../src/entry-server.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../src/index.ssr.html'</span>),</span><br><span class="line">      filename: <span class="string">'index.ssr.html'</span>,</span><br><span class="line">      files: &#123;</span><br><span class="line">        js: <span class="string">'client.bundle.js'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      excludeChunks: [<span class="string">'server'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里有几个点需要注意一下：</p><ol><li>入口文件是 entry-server.js</li><li>因为是打包服务器端依赖的代码，所以target要设为node，同时，output的libraryTarget要设为commonjs2</li></ol><p>这里关于HtmlWebpackPlugin配置的意思是，不要在index.ssr.html中引入打包出的server.bundle.js，要引为浏览器打包的client.bundle.js，原因前面说过了，是为了让Vue可以将服务器吐出来的html进行激活，从而接管后续响应。</p><p>那么打包出的server.bundle.js在哪用呢？接着往下看就知道啦~~</p><p><strong>package.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"01"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"yarn run dev"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="attr">"build:client"</span>: <span class="string">"webpack --config config/webpack.client.config.js"</span>,</span><br><span class="line">    <span class="attr">"build:server"</span>: <span class="string">"webpack --config config/webpack.server.config.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"koa"</span>: <span class="string">"^2.5.3"</span>,</span><br><span class="line">    <span class="attr">"koa-router"</span>: <span class="string">"^7.4.0"</span>,</span><br><span class="line">    <span class="attr">"koa-static"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.5.17"</span>,</span><br><span class="line">    <span class="attr">"vue-server-renderer"</span>: <span class="string">"^2.5.17"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.1.2"</span>,</span><br><span class="line">    <span class="attr">"@babel/preset-env"</span>: <span class="string">"^7.1.0"</span>,</span><br><span class="line">    <span class="attr">"autoprefixer"</span>: <span class="string">"^9.1.5"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.0.4"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="attr">"extract-text-webpack-plugin"</span>: <span class="string">"^4.0.0-beta.0"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^2.0.0"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^3.2.0"</span>,</span><br><span class="line">    <span class="attr">"postcss"</span>: <span class="string">"^7.0.5"</span>,</span><br><span class="line">    <span class="attr">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^0.23.0"</span>,</span><br><span class="line">    <span class="attr">"url-loader"</span>: <span class="string">"^1.1.1"</span>,</span><br><span class="line">    <span class="attr">"vue-loader"</span>: <span class="string">"^15.4.2"</span>,</span><br><span class="line">    <span class="attr">"vue-style-loader"</span>: <span class="string">"^4.1.2"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.5.17"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.20.2"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.1.2"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.1.9"</span>,</span><br><span class="line">    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.1.4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看server端关于http服务的代码：</p><p><strong>server/server.js</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> backendApp = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> frontendApp = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> backendRouter = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> frontendRouter = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bundle = fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/server.js'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createBundleRenderer(bundle, &#123;</span><br><span class="line">  template: fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/index.ssr.html'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端Server</span></span><br><span class="line">backendRouter.get(<span class="string">'/index'</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里用 renderToString 的 promise 返回的 html 有问题，没有样式</span></span><br><span class="line">  renderer.renderToString(<span class="function">(<span class="params">err, html</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">      ctx.status = <span class="number">500</span>;</span><br><span class="line">      ctx.body = <span class="string">'服务器内部错误'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(html);</span><br><span class="line">      ctx.status = <span class="number">200</span>;</span><br><span class="line">      ctx.body = html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">backendApp.use(serve(path.resolve(__dirname, <span class="string">'../dist'</span>)));</span><br><span class="line"></span><br><span class="line">backendApp</span><br><span class="line">  .use(backendRouter.routes())</span><br><span class="line">  .use(backendRouter.allowedMethods());</span><br><span class="line"></span><br><span class="line">backendApp.listen(<span class="number">3000</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器端渲染地址： http://localhost:3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端Server</span></span><br><span class="line">frontendRouter.get(<span class="string">'/index'</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> html = fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/index.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line">  ctx.type = <span class="string">'html'</span>;</span><br><span class="line">  ctx.status = <span class="number">200</span>;</span><br><span class="line">  ctx.body = html;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">frontendApp.use(serve(path.resolve(__dirname, <span class="string">'../dist'</span>)));</span><br><span class="line"></span><br><span class="line">frontendApp</span><br><span class="line">  .use(frontendRouter.routes())</span><br><span class="line">  .use(frontendRouter.allowedMethods());</span><br><span class="line"></span><br><span class="line">frontendApp.listen(<span class="number">3001</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'浏览器端渲染地址： http://localhost:3001'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里对两个端口进行监听，3000端口是服务端渲染，3001端口是直接输出index.html，然后会在浏览器端走Vue的那一套，主要是为了和服务端渲染做对比使用。</p><p>这里的关键代码是如何在服务端去输出html字符串。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const bundle</span> = fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/server.bundle.js'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="attribute">const renderer</span> = require(<span class="string">'vue-server-renderer'</span>).createBundleRenderer(bundle, &#123;</span><br><span class="line">  template: fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/index.ssr.html'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，server.bundle.js在这里被使用啦，因为它的入口是一个函数，接收context作为参数（非必传），输出一个根组件app。</p><p>这里我们用到了vue-server-renderer插件，它有两个方法可以做渲染，一个是createRenderer，另一个是createBundleRenderer。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>)</span><br><span class="line"><span class="keyword">const</span> renderer = createRenderer(&#123; <span class="comment">/* 选项 */</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>)</span><br><span class="line"><span class="keyword">const</span> renderer = createBundleRenderer(serverBundle, &#123; <span class="comment">/* 选项 */</span> &#125;)</span><br></pre></td></tr></table></figure><p>createRenderer无法接收为服务端打包出的server.bundle.js文件，所以这里只能用createBundleRenderer。</p><p>serverBundle 参数可以是以下之一：</p><ul><li>绝对路径，指向一个已经构建好的 bundle 文件（.js 或 .json）。必须以 / 开头才会被识别为文件路径。</li><li>由 webpack + vue-server-renderer/server-plugin 生成的 bundle 对象。</li><li>JavaScript 代码字符串（不推荐）。</li></ul><p>这里我们引入的是.js文件，后续会介绍如何使用.json文件以及有什么好处。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">renderer.renderToString((err, html) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      console.error(err)<span class="comment">;</span></span><br><span class="line">      ctx.status = <span class="number">500</span><span class="comment">;</span></span><br><span class="line">      ctx.<span class="keyword">body </span>= <span class="string">'服务器内部错误'</span><span class="comment">;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.log(html)<span class="comment">;</span></span><br><span class="line">      ctx.status = <span class="number">200</span><span class="comment">;</span></span><br><span class="line">      ctx.<span class="keyword">body </span>= html<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>使用createRenderer和createBundleRenderer返回的renderer函数包含两个方法renderToString和renderToStream，我们这里用的是renderToString成功后直接返回一个完整的字符串，renderToStream返回的是一个Node流。</p><p>renderToString支持Promise，但是我在使用Prmoise形式的时候样式会渲染不出来，暂时还不知道原因，如果大家知道的话可以给我留言啊。</p><p>配置基本就完成了，来看一下如何运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">run</span><span class="bash"> build:client       // 打包浏览器端需要bundle</span></span><br><span class="line"><span class="bash">yarn run build:server       // 打包SSR需要bundle</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">yarn start      // 其实就是 node server/server.js，提供http服务</span></span><br></pre></td></tr></table></figure><p>最终效果展示：</p><p>访问<a href="http://localhost:3000/index" target="_blank" rel="noopener">http://localhost:3000/index</a></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20181010/server_render.png" alt="SSR没有ajax数据"></p><p>我们看到了前面提过的data-server-rendered=”true”属性，同时会加载client.bundle.js文件，为了让Vue在浏览器端做后续接管。</p><p>访问<a href="http://localhost:3001/index还和第一步实现的效果一样，纯浏览器渲染，这里就不放截图了。" target="_blank" rel="noopener">http://localhost:3001/index还和第一步实现的效果一样，纯浏览器渲染，这里就不放截图了。</a></p><p>完整代码查看<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/02" target="_blank" rel="noopener">github</a></p><h3 id="3-服务端渲染，包含Ajax初始化数据"><a href="#3-服务端渲染，包含Ajax初始化数据" class="headerlink" title="3. 服务端渲染，包含Ajax初始化数据"></a>3. 服务端渲染，包含Ajax初始化数据</h3><p>如果SSR需要初始化一些异步数据，那么流程就会变得复杂一些。</p><p> 我们先提出几个问题：</p><ol><li>服务端拿异步数据的步骤在哪做？</li><li>如何确定哪些组件需要获取异步数据？</li><li><p>获取到异步数据之后要如何塞回到组件内？</p><p>带着问题我们向下走，希望看完这篇文章的时候上面的问题你都找到了答案。</p><p>服务器端渲染和浏览器端渲染组件经过的生命周期是有区别的，<strong>在服务器端，只会经历beforeCreate和created两个生命周期</strong>。因为SSR服务器直接吐出html字符串就好了，不会渲染DOM结构，所以不存在beforeMount和mounted的，也不会对其进行更新，所以也就不存在beforeUpdate和updated等。</p><p>我们先来想一下，在纯浏览器渲染的Vue项目中，我们是怎么获取异步数据并渲染到组件中的？一般是在created或者mounted生命周期里发起异步请求，然后在成功回调里执行this.data = xxx，Vue监听到数据发生改变，走后面的Dom Diff，打patch，做DOM更新。</p><p>那么服务端渲染可不可以也这么做呢？<strong>答案是不行的</strong>。</p></li><li><p>在mounted里肯定不行，因为SSR都没有mounted生命周期，所以在这里肯定不行。</p></li><li><p>在beforeCreate里发起异步请求是否可以呢，也是不行的。因为请求是异步的，可能还没有等接口返回，服务端就已经把html字符串拼接出来了。</p><p>所以，参考一下<a href="https://ssr.vuejs.org/guide/data.html" target="_blank" rel="noopener">官方文档</a>，我们可以得到以下思路：</p></li><li><p>在渲染前，要预先获取所有需要的异步数据，然后存到Vuex的store中。</p></li><li>在后端渲染时，通过Vuex将获取到的数据注入到相应组件中。</li><li>把store中的数据设置到window.<strong>INITIAL_STATE</strong>属性中。</li><li><p>在浏览器环境中，通过Vuex将window.<strong>INITIAL_STATE</strong>里面的数据注入到相应组件中。</p><p>正常情况下，通过这几个步骤，服务端吐出来的html字符串相应组件的数据都是最新的，所以第4步并不会引起DOM更新，但如果出了某些问题，吐出来的html字符串没有相应数据，Vue也可以在浏览器端通过Vuex注入数据，进行DOM更新。</p><p><strong>更新后的目录结构：</strong></p></li></ol><h5 id="目录结构-2"><a href="#目录结构-2" class="headerlink" title="目录结构"></a>目录结构</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> node_modules</span></span><br><span class="line"><span class="ruby">- config</span></span><br><span class="line"><span class="ruby">    - webpack.base.config.js</span></span><br><span class="line"><span class="ruby">    - webpack.client.config.js</span></span><br><span class="line"><span class="ruby">    - webpack.server.config.js</span></span><br><span class="line"><span class="ruby">- src</span></span><br><span class="line"><span class="ruby">    - components  </span></span><br><span class="line"><span class="ruby">        - Bar.vue</span></span><br><span class="line"><span class="ruby">        - Foo.vue</span></span><br><span class="line"><span class="ruby">    - store             /<span class="regexp">/ 新增</span></span></span><br><span class="line"><span class="ruby">        store.js</span></span><br><span class="line"><span class="ruby">    - App.vue</span></span><br><span class="line"><span class="ruby">    - app.js</span></span><br><span class="line"><span class="ruby">    - entry-client.js</span></span><br><span class="line"><span class="ruby">    - entry-server.js   </span></span><br><span class="line"><span class="ruby">    - index.html</span></span><br><span class="line"><span class="ruby">    - index.ssr.html</span></span><br><span class="line"><span class="ruby">- package.json</span></span><br><span class="line"><span class="ruby">- yarn.lock</span></span><br><span class="line"><span class="ruby">- postcss.config.js</span></span><br><span class="line"><span class="ruby">- .babelrc</span></span><br><span class="line"><span class="ruby">- .gitignore</span></span><br></pre></td></tr></table></figure><p>先来看一下store.js:</p><p><strong>store/store.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchBar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'bar 组件返回 ajax 数据'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      bar: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    mutations: &#123;</span><br><span class="line">      <span class="string">'SET_BAR'</span>(state, data) &#123;</span><br><span class="line">        state.bar = data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      fetchBar(&#123; commit &#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> fetchBar().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          commit(<span class="string">'SET_BAR'</span>, data);</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'window.__INITIAL_STATE__'</span>, <span class="built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">    store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span></span><br></pre></td></tr></table></figure><p>如果不太了解Vuex，可以去<a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">Vuex官网</a>先看一些基本概念。</p><p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"></p><p>这里fetchBar可以看成是一个异步请求，这里用setTimeout模拟。在成功回调中commit相应的mutation进行状态修改。</p><p>这里有一段关键代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'window.__INITIAL_STATE__'</span>, <span class="built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">    store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为store.js同样也会被打包到服务器运行的server.bundle.js中，所以运行环境不一定是浏览器，这里需要对window做判断，防止报错，同时如果有window.<strong>INITIAL_STATE</strong>属性，说明服务器已经把所有初始化需要的异步数据都获取完成了，要对store中的状态做一个替换，保证统一。</p><p><strong>components/Bar.vue</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">"onHandleClick"</span>&gt;</span>Bar Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>异步Ajax数据：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">  const fetchInitialData = (&#123; store &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="xml">    store.dispatch('fetchBar');</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  export default &#123;</span></span><br><span class="line"><span class="xml">    asyncData: fetchInitialData,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    methods: &#123;</span></span><br><span class="line"><span class="xml">      onHandleClick() &#123;</span></span><br><span class="line"><span class="xml">        alert('bar');</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    mounted() &#123;</span></span><br><span class="line"><span class="xml">      // 因为服务端渲染只有 beforeCreate 和 created 两个生命周期，不会走这里</span></span><br><span class="line"><span class="xml">      // 所以把调用 Ajax 初始化数据也写在这里，是为了供单独浏览器渲染使用</span></span><br><span class="line"><span class="xml">      let store = this.$store;</span></span><br><span class="line"><span class="xml">      fetchInitialData(&#123; store &#125;);</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    computed: &#123;</span></span><br><span class="line"><span class="xml">      msg() &#123;</span></span><br><span class="line"><span class="xml">        return this.$store.state.bar;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">.bar &#123;</span></span><br><span class="line"><span class="xml">  background: bisque;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里在Bar组件的默认导出对象中增加了一个方法asyncData，在该方法中会dispatch相应的action，进行异步数据获取。</p><p><strong>需要注意的是，我在mounted中也写了获取数据的代码，这是为什么呢？</strong> 因为想要做到同构，代码单独在浏览器端运行，也应该是没有问题的，又由于服务器没有mounted生命周期，所以我写在这里就可以解决单独在浏览器环境使用也可以发起同样的异步请求去初始化数据。</p><p><strong>components/Foo.vue</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">"onHandleClick"</span>&gt;</span>Foo Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    onHandleClick() &#123;</span></span><br><span class="line"><span class="actionscript">      alert(<span class="string">'foo'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.foo</span> &#123;</span></span><br><span class="line"><span class="undefined">  background: yellowgreen;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我对两个组件都添加了一个点击事件，为的是证明在服务器吐出首页html后，后续的步骤都会被浏览器端的Vue接管，可以正常执行后面的操作。</p><p><strong>app.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./store/store.js'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; app, store, App &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在建立根组件的时候，要把Vuex的store传进去，同时要返回，后续会用到。</p><p>最后来看一下entry-server.js，关键步骤在这里：</p><p><strong>entry-server.js</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; <span class="keyword">from</span> './app.js';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const &#123; app, store, App &#125; = createApp();</span><br><span class="line"></span><br><span class="line">    let components = App.components;</span><br><span class="line">    let asyncDataPromiseFns = [];</span><br><span class="line">  </span><br><span class="line">    Object.values(components).<span class="keyword">for</span>Each(component =&gt; &#123;</span><br><span class="line">      if (component.asyncData) &#123;</span><br><span class="line">        asyncDataPromiseFns.push(component.asyncData(&#123; store &#125;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    Promise.<span class="literal">all</span>(asyncDataPromiseFns).then((result) =&gt; &#123;</span><br><span class="line">      // 当使用 template 时，context.<span class="keyword">state</span> 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中</span><br><span class="line">      context.<span class="keyword">state</span> = store.<span class="keyword">state</span>;</span><br><span class="line">  </span><br><span class="line">      console.<span class="keyword">log</span>(<span class="number">222</span>);</span><br><span class="line">      console.<span class="keyword">log</span>(store.<span class="keyword">state</span>);</span><br><span class="line">      console.<span class="keyword">log</span>(context.<span class="keyword">state</span>);</span><br><span class="line">      console.<span class="keyword">log</span>(context);</span><br><span class="line">  </span><br><span class="line">      resolve(app);</span><br><span class="line">    &#125;, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过导出的App拿到了所有它下面的components，然后遍历，找出哪些component有asyncData方法，有的话调用并传入store，该方法会返回一个Promise，我们使用Promise.all等所有的异步方法都成功返回，才resolve(app)。</p><p>context.state = store.state作用是，当使用createBundleRenderer时，如果设置了template选项，那么会把context.state的值作为window.<strong>INITIAL_STATE</strong>自动插入到模板html中。</p><p><strong>这里需要大家多思考一下，弄清楚整个服务端渲染的逻辑。</strong></p><p>如何运行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">run</span><span class="bash"> build:client</span></span><br><span class="line"><span class="bash">yarn run build:server</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">yarn start</span></span><br></pre></td></tr></table></figure><p>最终效果截图：</p><p><strong>服务端渲染：打开<a href="http://localhost:3000/index" target="_blank" rel="noopener">http://localhost:3000/index</a></strong></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20181010/server_render_ajax.png" alt="server-remder-ajax"></p><p>可以看到window.<strong>INITIAL_STATE</strong>被自动插入了。</p><p>我们来对比一下SSR到底对加载性能有什么影响吧。</p><p><strong>服务端渲染时performance截图</strong>：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20181010/sercer_render_ajax_performance.png" alt="sercer_render_ajax_performance"></p><p><strong>纯浏览器端渲染时performance截图</strong>：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20181010/client_render_ajax_performance.png" alt="client_render_ajax_performance"></p><p>同样都是在fast 3G网络模式下，纯浏览器端渲染首屏加载花费时间<strong>2.9s</strong>，因为client.js加载就花费了<strong>2.27s</strong>，因为没有client.js就没有Vue，也就没有后面的东西了。</p><p>服务端渲染首屏时间花费<strong>0.8s</strong>，虽然client.js加载扔花费2.27s，但是首屏已经不需要它了，它是为了让Vue在浏览器端进行后续接管。</p><p>从这我们可以真正的看到，服务端渲染对于提升首屏的响应速度是很有作用的。</p><p>当然有的同学可能会问，在服务端渲染获取初始ajax数据时，我们还延时了1s，在这个时间用户也是看不到页面的。没错，接口的时间我们无法避免，就算是纯浏览器渲染，首页该调接口还是得调，如果接口响应慢，那么纯浏览器渲染看到完整页面的时间会更慢。</p><p>完整代码查看<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/03" target="_blank" rel="noopener">github</a></p><h2 id="4-使用serverBundle和clientManifest进行优化"><a href="#4-使用serverBundle和clientManifest进行优化" class="headerlink" title="4. 使用serverBundle和clientManifest进行优化"></a>4. 使用serverBundle和clientManifest进行优化</h2><p>前面我们创建服务端renderer的方法是：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const bundle</span> = fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/server.js'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="attribute">const renderer</span> = require(<span class="string">'vue-server-renderer'</span>).createBundleRenderer(bundle, &#123;</span><br><span class="line">  template: fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/index.ssr.html'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>serverBundle我们用的是打包出的server.bundle.js文件。这样做的话，在每次编辑过应用程序源代码之后，都必须停止并重启服务。这在开发过程中会影响开发效率。此外，Node.js 本身不支持 source map。</p><p>vue-server-renderer 提供一个名为 createBundleRenderer 的 API，用于处理此问题，通过使用 webpack 的自定义插件，server bundle 将生成为可传递到 bundle renderer 的特殊 JSON 文件。所创建的 bundle renderer，用法和普通 renderer 相同，但是 bundle renderer 提供以下优点：</p><ul><li>内置的 source map 支持（在 webpack 配置中使用 devtool: ‘source-map’）</li><li>在开发环境甚至部署过程中热重载（通过读取更新后的 bundle，然后重新创建 renderer 实例）</li><li>关键 CSS(critical CSS) 注入（在使用 *.vue 文件时）：自动内联在渲染过程中用到的组件所需的CSS。更多细节请查看 CSS 章节。</li><li>使用 clientManifest 进行资源注入：自动推断出最佳的预加载(preload)和预取(prefetch)指令，以及初始渲染所需的代码分割 chunk。</li></ul><p>preload和prefetch有不了解的话可以自行查一下它们的作用哈。</p><p>那么我们来修改webpack配置：</p><p><strong>webpack.client.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> VueSSRClientPlugin = <span class="built_in">require</span>(<span class="string">'vue-server-renderer/client-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    client: path.resolve(__dirname, <span class="string">'../src/entry-client.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueSSRClientPlugin(),   <span class="comment">// 新增</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../src/index.html'</span>),</span><br><span class="line">      filename: <span class="string">'index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>webpack.server.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> VueSSRServerPlugin = <span class="built_in">require</span>(<span class="string">'vue-server-renderer/server-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(base, &#123;</span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">   <span class="comment">// 对 bundle renderer 提供 source map 支持</span></span><br><span class="line">  devtool: <span class="string">'#source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    server: path.resolve(__dirname, <span class="string">'../src/entry-server.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],     <span class="comment">// 新增</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueSSRServerPlugin(),   <span class="comment">// 这个要放到第一个写，否则 CopyWebpackPlugin 不起作用，原因还没查清楚</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../src/index.ssr.html'</span>),</span><br><span class="line">      filename: <span class="string">'index.ssr.html'</span>,</span><br><span class="line">      files: &#123;</span><br><span class="line">        js: <span class="string">'client.bundle.js'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      excludeChunks: [<span class="string">'server'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为是服务端引用模块，所以不需要打包node_modules中的依赖，直接在代码中require引用就好，所以配置externals: [nodeExternals()]。</p><p>两个配置文件会分别生成vue-ssr-client-manifest.json和vue-ssr-server-bundle.json。作为createBundleRenderer的参数。</p><p>来看server.js</p><p><strong>server.js</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const serverBundle</span> = require(path.resolve(__dirname, <span class="string">'../dist/vue-ssr-server-bundle.json'</span>));</span><br><span class="line"><span class="attribute">const clientManifest</span> = require(path.resolve(__dirname, <span class="string">'../dist/vue-ssr-client-manifest.json'</span>));</span><br><span class="line"><span class="attribute">const template</span> = fs.readFileSync(path.resolve(__dirname, <span class="string">'../dist/index.ssr.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">const renderer</span> = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">  runInNewContext: false,</span><br><span class="line">  template: template,</span><br><span class="line">  clientManifest: clientManifest</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果和第三步就是一样的啦，就不截图了，完整代码查看<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/04" target="_blank" rel="noopener">github</a>。</p><h2 id="5-配置一个完整的基于Vue-VueRouter-Vuex的SSR"><a href="#5-配置一个完整的基于Vue-VueRouter-Vuex的SSR" class="headerlink" title="5. 配置一个完整的基于Vue + VueRouter + Vuex的SSR"></a>5. 配置一个完整的基于Vue + VueRouter + Vuex的SSR</h2><p>这里和第四步不一样的是引入了vue-router，更接近于实际开发项目。</p><p>在src下新增router目录。</p><p><strong>router/index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'../components/Bar.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/bar'</span>,</span><br><span class="line">      component: Bar</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Foo.vue'</span>)   <span class="comment">// 异步路由</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    routes</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createRouter;</span><br></pre></td></tr></table></figure><p>这里我们把Foo组件作为一个异步组件引入，做成按需加载。</p><p>在app.js中引入router，并导出：</p><p><strong>app.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./store/store.js'</span>;</span><br><span class="line"><span class="keyword">import</span> createRouter <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore();</span><br><span class="line">  <span class="keyword">const</span> router = createRouter();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; app, store, router, App &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App.vue引入路由组件：</p><p><strong>App.vue</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Goto Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Goto Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  beforeCreate() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'App.vue beforeCreate'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  created() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'App.vue created'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  beforeMount() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'App.vue beforeMount'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'App.vue mounted'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最重要的修改在entry-server.js中，</p><p><strong>entry-server.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, store, router, App &#125; = createApp();</span><br><span class="line"></span><br><span class="line">    router.push(context.url);</span><br><span class="line"></span><br><span class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(context.url)</span><br><span class="line">      <span class="built_in">console</span>.log(matchedComponents)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (component.asyncData) &#123;</span><br><span class="line">          <span class="keyword">return</span> component.asyncData(&#123; store &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态，自动嵌入到最终的 HTML 中</span></span><br><span class="line">        context.state = store.state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回根组件</span></span><br><span class="line">        resolve(app);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里前面提到的context就起了大作用，它将用户访问的url地址传进来，供vue-router使用。因为有异步组件，所以在router.onReady的成功回调中，去找该url路由所匹配到的组件，获取异步数据那一套还和前面的一样。</p><p>于是，我们就完成了一个基本完整的基于Vue + VueRouter + VuexSSR配置，完成代码查看<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/05" target="_blank" rel="noopener">github</a>。</p><p>最终效果演示：</p><p>访问<a href="http://localhost:3000/bar：" target="_blank" rel="noopener">http://localhost:3000/bar：</a></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20181010/ssr_router.png" alt="ssr-router"></p><p>完整代码查看<a href="https://github.com/leocoder351/vue-ssr-demo/tree/master/05" target="_blank" rel="noopener">github</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>上面我们通过五个步骤，完成了从纯浏览器渲染到完整服务端渲染的同构，代码既可以运行在浏览器端，也可以运行在服务器端。那么，回过头来我们在看一下是否有优化的空间，又或者有哪些扩展的思考。</p><h5 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h5><ul><li>我们目前是使用renderToString方法，完全生成html后，才会向客户端返回，如果使用renderToStream，应用bigpipe技术可以向浏览器持续不断的返回一个流，那么文件的加载浏览器可以尽早的显示一些东西出来。<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">stream</span> = renderer.renderToStream(context)</span><br></pre></td></tr></table></figure></li></ul><p>返回的值是 Node.js stream：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'data'</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  html += data.toString()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'end'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(html) <span class="comment">// 渲染完成</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'error'</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// handle error...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在流式渲染模式下，当 renderer 遍历虚拟 DOM 树(virtual DOM tree)时，会尽快发送数据。这意味着我们可以尽快获得”第一个 chunk”，并开始更快地将其发送给客户端。</p><p>然而，当第一个数据 chunk 被发出时，子组件甚至可能不被实例化，它们的生命周期钩子也不会被调用。这意味着，如果子组件需要在其生命周期钩子函数中，将数据附加到渲染上下文(render context)，当流(stream)启动时，这些数据将不可用。这是因为，大量上下文信息(context information)（如头信息(head information)或内联关键 CSS(inline critical CSS)）需要在应用程序标记(markup)之前出现，我们基本上必须等待流(stream)完成后，才能开始使用这些上下文数据。</p><p>因此，如果你依赖由组件生命周期钩子函数填充的上下文数据，则不建议使用流式传输模式。</p><ul><li>webpack优化</li></ul><p>webpack优化又是一个大的话题了，这里不展开讨论，感兴趣的同学可以自行查找一些资料，后续我也可能会专门写一篇文章来讲webpack优化。</p><h5 id="2-思考"><a href="#2-思考" class="headerlink" title="2. 思考"></a>2. 思考</h5><ul><li>是否必须使用vuex？</li></ul><p>答案是不用。Vuex只是为了帮助你实现一套数据存储、更新、获取的机制，入股你不用Vuex，那么你就必须自己想一套方案可以将异步获取到的数据存起来，并且在适当的时机将它注入到组件内，有一些文章提出了一些方案，我会放到参考文章里，大家可以阅读一下。</p><ul><li>是否使用SSR就一定好？</li></ul><p>这个也是不一定的，任何技术都有使用场景。SSR可以帮助你提升首页加载速度，优化搜索引擎SEO，但同时由于它需要在node中渲染整套Vue的模板，会占用服务器负载，同时只会执行beforeCreate和created两个生命周期，对于一些外部扩展库需要做一定处理才可以在SSR中运行等等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文通过五个步骤，从纯浏览器端渲染开始，到配置一个完整的基于Vue + vue-router + Vuex的SSR环境，介绍了很多新的概念，也许你看完一遍不太理解，那么结合着源码，去自己手敲几遍，然后再来看几遍文章，相信你一定可以掌握SSR。</p><p>最后，本文所有源代码都放在我的<a href="https://github.com/leocoder351/vue-ssr-demo" target="_blank" rel="noopener">github</a>上，如果对你有帮助的话，就来点一个赞吧~~</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">https://ssr.vuejs.org/zh/</a></li><li><a href="https://zhuanlan.zhihu.com/p/35871344" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35871344</a></li><li><a href="http://www.cnblogs.com/qingmingsang/articles/8719679.html" target="_blank" rel="noopener">http://www.cnblogs.com/qingmingsang/articles/8719679.html</a></li><li><a href="https://juejin.im/entry/590ca74b2f301e006c10465f" target="_blank" rel="noopener">https://juejin.im/entry/590ca74b2f301e006c10465f</a></li><li><a href="https://github.com/youngwind/blog/issues/112" target="_blank" rel="noopener">https://github.com/youngwind/blog/issues/112</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/vuessr.png?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SSR大家肯定都不陌生，通过服务端渲染，可以优化SEO抓取，提升首页加载速度等，我在学习SSR的时候，看过很多文章，有些对我有很大的启发作用，有些就只是照搬官网文档。通过几天的学习，我对SSR有了一些了解，也从头开始完整的配置出了SSR的开发环境，所以想通过这篇文章，总结一些经验，同时希望能够对学习SSR的朋友起到一点帮助。&lt;/p&gt;
&lt;p&gt;我会通过五个步骤，一步步带你完成SSR的配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯浏览器渲染&lt;/li&gt;
&lt;li&gt;服务端渲染，不包含Ajax初始化数据&lt;/li&gt;
&lt;li&gt;服务端渲染，包含Ajax初始化数据&lt;/li&gt;
&lt;li&gt;服务端渲染，使用serverBundle和clientManifest进行优化&lt;/li&gt;
&lt;li&gt;一个完整的基于Vue + VueRouter + Vuex的SSR工程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你现在对于我上面说的还不太了解，没有关系，跟着我一步步向下走，最终你也可以独立配置一个SSR开发项目，&lt;strong&gt;所有源码我会放到&lt;a href=&quot;https://github.com/leocoder351/vue-ssr-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;上，大家可以作为参考&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Vue" scheme="//blog.liuxuan.site/tags/Vue/"/>
    
      <category term="Vuex" scheme="//blog.liuxuan.site/tags/Vuex/"/>
    
      <category term="Vue Router" scheme="//blog.liuxuan.site/tags/Vue-Router/"/>
    
      <category term="Vue SSR" scheme="//blog.liuxuan.site/tags/Vue-SSR/"/>
    
  </entry>
  
  <entry>
    <title>从0到1实现Promise</title>
    <link href="//blog.liuxuan.site/2018/09/28/javascript_promise/"/>
    <id>//blog.liuxuan.site/2018/09/28/javascript_promise/</id>
    <published>2018-09-28T12:36:00.000Z</published>
    <updated>2018-11-11T08:13:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/promise.png?imageView2/1/w/1000/h/400" alt="stack"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Promise大家一定都不陌生了，JavaScript异步流程从最初的Callback，到Promise，到Generator，再到目前使用最多的Async/Await（如果对于这些不熟悉的可以参考我另一篇文章<a href="https://segmentfault.com/a/1190000015711829" target="_blank" rel="noopener">《JavaScript异步编程》</a>），这不仅仅是技术实现的发展，更是思想上对于如何控制异步的递进。Promise作为后续方案的基础，是重中之重，也是面试时候最常被问到的。</p><p>今天我们就一起从0到1实现一个基于A+规范的Promise，过程中也会对Promise的异常处理，以及是否可手动终止做一些讨论，最后会对我们实现的Promise做单元测试。完整的代码已经上传到github，想直接看代码的可以<a href="https://github.com/leocoder351/my-promise" target="_blank" rel="noopener">点这里</a>。</p><p>虽然已经有很多带你实现Promise类的文章了，但每个人理解的程度不一样，也许不同的文章可以带给你不同的思考呢，那我们就开始吧。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-基础框架"><a href="#1-基础框架" class="headerlink" title="1. 基础框架"></a>1. 基础框架</h3><p>new Promise()时接收一个executor函数作为参数，该函数会立即执行，函数中有两个参数，它们也是函数，分别是resolve和reject，函数同步执行一定要放在try…catch中，否则无法进行错误捕获。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure><p>resolve()接收Promise成功值value，reject接收Promise失败原因reason。</p><p><strong>test.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-添加状态机"><a href="#2-添加状态机" class="headerlink" title="2. 添加状态机"></a>2. 添加状态机</h3><p>目前实现存在的问题：</p><ol><li>Promise是一个状态机的机制，初始状态为 pending，成功状态为 fulfilled，失败状态为 rejected。只能从 pending -&gt; fulfilled，或者从 pending -&gt; rejected，并且状态一旦转变，就永远不会再变了。</li></ol><p>所以，我们需要为Promise添加一个状态流转的机制。</p><p><strong>MyPromise.js</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = 'pending';</span><br><span class="line">const FULFILLED = 'fulfilled';</span><br><span class="line">const REJECTED = 'rejected';</span><br><span class="line"></span><br><span class="line">function MyPromise(executor) &#123;</span><br><span class="line">  let <span class="literal">self</span> = this;</span><br><span class="line">  <span class="literal">self</span>.<span class="keyword">state</span> = PENDING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">state</span> = FULFILLED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line">    if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">state</span> = REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; catch (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = MyPromise;</span><br></pre></td></tr></table></figure><p><strong>test.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason'</span>, reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-添加then方法"><a href="#3-添加then方法" class="headerlink" title="3. 添加then方法"></a>3. 添加then方法</h3><p>Promise拥有一个then方法，接收两个函数 onFulfilled 和 onRejected，分别作为Promise成功和失败的回调。所以，在then方法中我们需要对状态state进行判断，如果是fulfilled，则执行onFulfilled(value)方法，如果是rejected，则执行onRejected(reason)方法。</p><p>由于成功值value和失败原因reason是由用户在executor中通过resolve(value) 和 reject(reason)传入的，所以我们需要有一个全局的value和reason供后续方法获取。</p><p><strong>MyPromise.js</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = 'pending';</span><br><span class="line">const FULFILLED = 'fulfilled';</span><br><span class="line">const REJECTED = 'rejected';</span><br><span class="line"></span><br><span class="line">function MyPromise(executor) &#123;</span><br><span class="line">  let <span class="literal">self</span> = this;</span><br><span class="line"></span><br><span class="line">  <span class="literal">self</span>.<span class="keyword">state</span> = PENDING;</span><br><span class="line">  <span class="literal">self</span>.value = null;</span><br><span class="line">  <span class="literal">self</span>.reason = null;</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">state</span> = FULFILLED;</span><br><span class="line">      <span class="literal">self</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line">    if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">state</span> = REJECTED;</span><br><span class="line">      <span class="literal">self</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; catch (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(<span class="keyword">on</span>Fuifilled, <span class="keyword">on</span>Rejected) &#123;</span><br><span class="line">  let <span class="literal">self</span> = this;</span><br><span class="line"></span><br><span class="line">  if (<span class="literal">self</span>.<span class="keyword">state</span> === FULFILLED) &#123;</span><br><span class="line">    <span class="keyword">on</span>Fuifilled(<span class="literal">self</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (<span class="literal">self</span>.<span class="keyword">state</span> === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">on</span>Rejected(<span class="literal">self</span>.reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = MyPromise;</span><br></pre></td></tr></table></figure><h3 id="4-实现异步调用resolve"><a href="#4-实现异步调用resolve" class="headerlink" title="4. 实现异步调用resolve"></a>4. 实现异步调用resolve</h3><p>目前实现存在的问题：</p><ol><li>同步调用resolve()没有问题，但如果是异步调用，比如放到setTimeout中，因为目前的代码在调用then()方法时，state仍是pending状态，当timer到时候调用resolve()把state修改为fulfilled状态，但是onFulfilled()函数已经没有时机调用了。</li></ol><p>针对上述问题，进行如下修改：</p><p><strong>MyPromise.js</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = 'pending';</span><br><span class="line">const FULFILLED = 'fulfilled';</span><br><span class="line">const REJECTED = 'rejected';</span><br><span class="line"></span><br><span class="line">function MyPromise(executor) &#123;</span><br><span class="line">  let <span class="literal">self</span> = this;</span><br><span class="line"></span><br><span class="line">  <span class="literal">self</span>.<span class="keyword">state</span> = PENDING;</span><br><span class="line">  <span class="literal">self</span>.value = null;</span><br><span class="line">  <span class="literal">self</span>.reason = null;</span><br><span class="line">  <span class="literal">self</span>.<span class="keyword">on</span>FulfilledCallbacks = [];</span><br><span class="line">  <span class="literal">self</span>.<span class="keyword">on</span>RejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  function resolve(value) &#123;</span><br><span class="line">    if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">state</span> = FULFILLED;</span><br><span class="line">      <span class="literal">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">on</span>FulfilledCallbacks.<span class="keyword">for</span>Each(function(fulfilledCallback) &#123;</span><br><span class="line">        fulfilledCallback();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(reason) &#123;</span><br><span class="line">    if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">state</span> = REJECTED;</span><br><span class="line">      <span class="literal">self</span>.reason = reason;</span><br><span class="line"></span><br><span class="line">      <span class="literal">self</span>.<span class="keyword">on</span>RejectedCallbacks.<span class="keyword">for</span>Each(function(rejectedCallback) &#123;</span><br><span class="line">        rejectedCallback();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; catch (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(<span class="keyword">on</span>Fuifilled, <span class="keyword">on</span>Rejected) &#123;</span><br><span class="line">  let <span class="literal">self</span> = this;</span><br><span class="line"></span><br><span class="line">  if (<span class="literal">self</span>.<span class="keyword">state</span> === PENDING) &#123;</span><br><span class="line">    <span class="literal">self</span>.<span class="keyword">on</span>FulfilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">on</span>Fuifilled(<span class="literal">self</span>.value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="literal">self</span>.<span class="keyword">on</span>RejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">on</span>Rejected(<span class="literal">self</span>.reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (<span class="literal">self</span>.<span class="keyword">state</span> === FULFILLED) &#123;</span><br><span class="line">    <span class="keyword">on</span>Fuifilled(<span class="literal">self</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (<span class="literal">self</span>.<span class="keyword">state</span> === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">on</span>Rejected(<span class="literal">self</span>.reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = MyPromise;</span><br></pre></td></tr></table></figure><p>我们添加了两个回调函数数组onFulfilledCallbacks和onRejectedCallbacks，用来存储then()方法中传入的成功和失败回调。然后，当用户调用resolve()或reject()的时候，修改state状态，并从相应的回调数组中依次取出回调函数执行。</p><p>同时，通过这种方式我们也实现了可以注册多个then()函数，并且在成功或者失败时按照注册顺序依次执行。</p><p><strong>test.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason1'</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason2'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-then返回的仍是Promise"><a href="#5-then返回的仍是Promise" class="headerlink" title="5. then返回的仍是Promise"></a>5. then返回的仍是Promise</h3><p>读过PromiseA+规范的同学肯定知道，then()方法返回的仍是一个Promise，并且返回Promise的resolve的值是上一个Promise的onFulfilled()函数或onRejected()函数的返回值。如果在上一个Promise的then()方法回调函数的执行过程中发生了错误，那么会将其捕获到，并作为返回的Promise的onRejected函数的参数传入。比如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">456</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果为：</p><blockquote><p>value1 123<br>value2 456</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  a.b = <span class="number">2</span>;    <span class="regexp">//</span> 这里存在语法错误</span><br><span class="line">  <span class="keyword">return</span> <span class="number">456</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason2'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果为：</p><blockquote><p>value1 123<br>reason2 ReferenceError: a is not defined</p></blockquote><p>可以看到，then()方法回调函数如果发生错误，会被捕获到，那么then()返回的Promise会自动变为onRejected，执行onRejected()回调函数。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">456</span>;</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason1'</span>, reason);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">456</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason2'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果为：</p><blockquote><p>reason1 123<br>value2 456</p></blockquote><p><strong>好啦，接下来我们就去实现then()方法依然返回一个Promise。</strong></p><p><strong>MyPromise.js</strong></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span><span class="params">(onFuifilled, onRejected)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">self</span> = this;</span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  promise2 = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">self</span>.onFulfilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFuifilled(<span class="keyword">self</span>.value);</span><br><span class="line">          <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">self</span>.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(<span class="keyword">self</span>.reason);</span><br><span class="line">          <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state === FULFILLED) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onFuifilled(<span class="keyword">self</span>.value);</span><br><span class="line">        <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state === REJECTED) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onRejected(<span class="keyword">self</span>.reason);</span><br><span class="line">        <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，我们新增了一个promise2作为then()方法的返回值。通过let x = onFuifilled(self.value) 或者 let x = onRejected(self.reason)拿到then()方法回调函数的返回值，然后调用self.resolvePromise(promise2, x, resolve, reject)，将新增的promise2、x、promise2的resolve和reject传入到resolvePromise()中。</p><p><strong>所以，下面我们重点看一下resolvePromise()方法。</strong></p><p><strong>MyPromise.js</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.resolvePromise = <span class="function"><span class="keyword">function</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;   <span class="comment">// called 防止多次调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Object]'</span> || <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">'[object Function]'</span>)) &#123;</span><br><span class="line">    <span class="comment">// x是对象或者函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 别人的Promise的then方法可能设置了getter等，使用called防止多次调用then方法</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 成功值y有可能还是promise或者是具有then方法等，再次resolvePromise，直到成功值为基本类型或者非thenable</span></span><br><span class="line">          self.resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x是普通值，直接resolve</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>resolvePromise()是用来解析then()回调函数中返回的仍是一个Promise，这个Promise有可能是我们自己的，有可能是别的库实现的，也有可能是一个具有then()方法的对象，所以这里靠resolvePromise()来实现统一处理。</p><p>下面是翻译自<a href="https://promisesaplus.com/" target="_blank" rel="noopener">PromiseA+规范</a>关于resolvePromise()的要求：</p><hr><p><strong>Promise 解决过程</strong></p><blockquote><p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 <a href="promise, x">[Resolve]</a>，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。</p></blockquote><p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p><p>运行 <a href="promise, x">[Resolve]</a> 需遵循以下步骤：</p><ul><li>x 与 promise 相等<br>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</li></ul><ul><li>x 为 Promise<br>如果 x 为 Promise ，则使 promise 接受 x 的状态:<ul><li>如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</li><li>如果 x 处于执行态，用相同的值执行 promise</li><li>如果 x 处于拒绝态，用相同的据因拒绝 promise</li></ul></li></ul><ul><li>x 为对象或函数<br>如果 x 为对象或者函数：<ul><li>把 x.then 赋值给 then</li><li>如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</li><li>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise:<ul><li>如果 resolvePromise 以值 y 为参数被调用，则运行 <a href="promise, y">[Resolve]</a></li><li>如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</li><li>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li><li>如果调用 then 方法抛出了异常 e：<ul><li>如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</li><li>否则以 e 为据因拒绝 promise</li></ul></li><li>如果 then 不是函数，以 x 为参数执行 promise</li></ul></li><li>如果 x 不为对象或者函数，以 x 为参数执行 promise</li></ul></li></ul><p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <a href="promise, thenable">[Resolve]</a> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise。</p><hr><p>参考上述规范，结合代码中的注释，相信大家可以理解resolvePromise()的作用了。</p><p>测试：</p><p><strong>test.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line">let promise = <span class="keyword">new</span> MyPromise(function(resolve, reject) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    resolve(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">456</span>);</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">789</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason1'</span>, reason);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason2'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>value1 123<br>value2 789</p></blockquote><h3 id="6-让then-方法的回调函数总是异步调用"><a href="#6-让then-方法的回调函数总是异步调用" class="headerlink" title="6. 让then()方法的回调函数总是异步调用"></a>6. 让then()方法的回调函数总是异步调用</h3><p>官方Promise实现的回调函数总是异步调用的：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'step-'</span>);</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'step--'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>start<br>step-<br>end<br>step–<br>value1 123  </p></blockquote><p>Promise属于微任务，这里我们为了方便用宏任务setTiemout来代替实现异步，具体关于宏任务、微任务以及Event Loop可以参考我的另一篇文章<a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noopener">带你彻底弄懂Event Loop</a>。</p><p><strong>MyPromise.js</strong></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span><span class="params">(onFuifilled, onRejected)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">self</span> = this;</span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  promise2 = <span class="keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">self</span>.onFulfilledCallbacks.push(() =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFuifilled(<span class="keyword">self</span>.value);</span><br><span class="line">            <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">self</span>.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">self</span>.reason);</span><br><span class="line">            <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state === FULFILLED) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onFuifilled(<span class="keyword">self</span>.value);</span><br><span class="line">          <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state === REJECTED) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onRejected(<span class="keyword">self</span>.reason);</span><br><span class="line">          <span class="keyword">self</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试：</p><p><strong>test.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">let promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'step-'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">123</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'step--'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value'</span>, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>start<br>step-<br>end<br>step–<br>value1 123  </p></blockquote><p><strong>经过以上步骤，一个最基本的Promise就已经实现完了，下面我们会实现一些不在PromiseA+规范的扩展方法。</strong></p><h3 id="7-实现catch-方法"><a href="#7-实现catch-方法" class="headerlink" title="7. 实现catch()方法"></a>7. 实现catch()方法</h3><p>then()方法的onFulfilled和onRejected回调函数都不是必传项，如果不传，那么我们就无法接收reject(reason)中的错误，这时我们可以通过链式调用catch()方法用来接收错误。举例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'has error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value'</span>, value);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>reason has error   </p></blockquote><p>不仅如此，catch()可以作为Promise链式调用的最后一步，前面Promise发生的错误会冒泡到最后一个catch()中，从而捕获异常。举例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'has error1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'has error2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>value 123<br>reason has error1</p></blockquote><p>那么catch()方法到底是如何实现的呢？</p><p>答案就是在Promise的实现中，onFulfilled和onRejected函数是有默认值的：</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFuifilled, onRejected</span>) </span>&#123;</span><br><span class="line">  onFuifilled = <span class="keyword">typeof</span> onFuifilled === <span class="string">'function'</span> ? onFuifilled : <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> value;&#125;;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，onRejected的默认值是把错误reason通过throw抛出去。由于我们对于同步代码的执行都是在try…catch中的，所以如果Promise发生了错误，如果没传onRejected，默认的函数会把错误reason抛出，然后会被promise2捕捉到，作为reject(reason)决议。</p><p>catch()实现就是调用this.then(null, onRejected)，由于promise2被reject，所以会执行onRejected回调，于是就捕捉到了第一个promise的错误。</p><p>总结来说，then()方法中不传onRejected回调，Promise内部会默认帮你写一个函数作为回调，作用就是throw抛出reject或者try…catch到的错误，然后错误reason会被promise2作为reject(reason)进行决议，于是会被下一个then()方法的onRejected回调函数调用，而catch只是写了一个特殊的then(null, onRejected)而已。</p><p>所以，我们在写Promise的链式调用的时候，在then()中可以不传onRejected回调，只需要在链式调用的最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。</p><p>举例1：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 注意，不会走这里，因为第一个promise是被reject的</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'has error1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'has error2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 注意，这个<span class="keyword">then</span>有onRejected回调</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason2'</span>, reason);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 错误在上一个<span class="keyword">then</span>就被捕获了，所以不会走到这里</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason3'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>reason2 123</p></blockquote><p>举例2：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">123</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'has error1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'has error2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 由于链条中的<span class="keyword">then</span>都没有onRejected回调，所以会一直被冒泡到最后的<span class="keyword">catch</span>这里</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason3'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>catch和then一样都是返回一个新的Promise。有的同学可能会有疑问，如果catch中的回调执行也发生错误该怎么办呢，这个我们后续在Promise异常处理中再做讨论。</p><p>打印结果：</p><blockquote><p>reason3 123</p></blockquote><h3 id="8-实现finally方法"><a href="#8-实现finally方法" class="headerlink" title="8. 实现finally方法"></a>8. 实现finally方法</h3><p>finally是某些库对Promise实现的一个扩展方法，无论是resolve还是reject，都会走finally方法。</p><p><strong>MyPromise.js</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">       fn();</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-实现done方法"><a href="#9-实现done方法" class="headerlink" title="9. 实现done方法"></a>9. 实现done方法</h3><p>done方法作为Promise链式调用的最后一步，用来向全局抛出没有被Promise内部捕获的错误，并且不再返回一个Promise。一般用来结束一个Promise链。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'done'</span>, reason);</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-实现Promise-all方法"><a href="#10-实现Promise-all方法" class="headerlink" title="10. 实现Promise.all方法"></a>10. 实现Promise.all方法</h3><p>Promise.all()接收一个包含多个Promise的数组，当所有Promise均为fulfilled状态时，返回一个结果数组，数组中结果的顺序和传入的Promise顺序一一对应。如果有一个Promise为rejected状态，则整个Promise.all为rejected。</p><p><strong>MyPromise.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.all = function(promiseArr) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    let result = [];</span><br><span class="line"></span><br><span class="line">    promiseArr.forEach(<span class="function"><span class="params">(promise, index)</span> =&gt;</span> &#123;</span><br><span class="line">      promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">        result[index] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.length === promiseArr.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>test.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">let MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line">let promise1 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaaa'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1111</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bbbb'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">2222</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let promise3 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cccc'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3333</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3333</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([promise1, promise2, promise3]).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all value'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all reason'</span>, reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>aaaa<br>bbbb<br>cccc<br>1111<br>2222<br>all reason 2222<br>3333</p></blockquote><h3 id="11-实现Promise-race方法"><a href="#11-实现Promise-race方法" class="headerlink" title="11. 实现Promise.race方法"></a>11. 实现Promise.race方法</h3><p>Promise.race()接收一个包含多个Promise的数组，当有一个Promise为fulfilled状态时，整个大的Promise为onfulfilled，并执行onFulfilled回调函数。如果有一个Promise为rejected状态，则整个Promise.race为rejected。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">      promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);   </span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>test.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">let MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line">let promise1 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaaa'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1111</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bbbb'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">2222</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let promise3 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'cccc'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3333</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3333</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([promise1, promise2, promise3]).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all value'</span>, value);</span><br><span class="line">&#125;, <span class="function"><span class="params">(reason)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all reason'</span>, reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>aaaa<br>bbbb<br>cccc<br>1111<br>all reason 1111<br>2222<br>3333</p></blockquote><h3 id="12-实现Promise-resolve方法"><a href="#12-实现Promise-resolve方法" class="headerlink" title="12. 实现Promise.resolve方法"></a>12. 实现Promise.resolve方法</h3><p>Promise.resolve用来生成一个fulfilled完成态的Promise，一般放在整个Promise链的开头，用来开始一个Promise链。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise;</span><br><span class="line"></span><br><span class="line">  promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.prototype.resolvePromise(promise, value, resolve, reject);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>test.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line">MyPromise.resolve(<span class="number">1111</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2222</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>value1 1111<br>value2 2222</p></blockquote><p>由于传入的value有可能是普通值，有可能是thenable，也有可能是另一个Promise，所以调用resolvePromise进行解析。</p><h3 id="12-实现Promise-reject方法"><a href="#12-实现Promise-reject方法" class="headerlink" title="12. 实现Promise.reject方法"></a>12. 实现Promise.reject方法</h3><p>Promise.reject用来生成一个rejected失败态的Promise。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>test.js</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let MyPromise = <span class="built_in">require</span>(<span class="string">'./MyPromise.js'</span>);</span><br><span class="line"></span><br><span class="line">MyPromise.reject(<span class="number">1111</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value1'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2222</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'value2'</span>, value);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(reason =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reason'</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果：</p><blockquote><p>reason 1111   </p></blockquote><h3 id="13-实现Promise-deferred方法"><a href="#13-实现Promise-deferred方法" class="headerlink" title="13. 实现Promise.deferred方法"></a>13. 实现Promise.deferred方法</h3><p>Promise.deferred可以用来延迟执行resolve和reject。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">    dfd.promies = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      dfd.resolve = resolve;</span><br><span class="line">      dfd.rfeject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，你就可以在外部通过调用dfd.resolve()和dfd.reject()来决议该Promise。</p><h3 id="13-如何停止一个Promise链"><a href="#13-如何停止一个Promise链" class="headerlink" title="13. 如何停止一个Promise链"></a>13. 如何停止一个Promise链</h3><p>假设这样一个场景，我们有一个很长的Promise链式调用，这些Promise是依次依赖的关系，如果链条中的某个Promise出错了，就不需要再向下执行了，默认情况下，我们是无法实现这个需求的，因为Promise无论是then还是catch都会返回一个Promise，都会继续向下执行then或catch。举例：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="title">resolve</span>, <span class="title">reject</span>) &#123;</span></span><br><span class="line">  <span class="built_in">resolve</span>(<span class="number">1111</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span>(<span class="title">value</span>) &#123;</span></span><br><span class="line"> <span class="comment"> // "ERROR!!!"</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>()</span><br><span class="line">  .<span class="keyword">then</span>()</span><br><span class="line">  .<span class="keyword">then</span>()</span><br><span class="line">  .<span class="keyword">catch</span>()</span><br><span class="line">  .<span class="keyword">then</span>()</span><br></pre></td></tr></table></figure><p>有没有办法让这个链式调用在ERROR!!!的后面就停掉，完全不去执行链式调用后面所有回调函数呢？</p><p>我们自己封装一个Promise.stop方法。</p><p><strong>MyPromise.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>stop中返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new MyPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> &#123;</span></span><br><span class="line">  resolve(<span class="number">1111</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></span><br><span class="line">  <span class="comment">// "ERROR!!!"</span></span><br><span class="line">  MyPromise.stop();</span><br><span class="line">&#125;).<span class="keyword">catch</span>()</span><br><span class="line">  .<span class="keyword">then</span>()</span><br><span class="line">  .<span class="keyword">then</span>()</span><br><span class="line">  .<span class="keyword">catch</span>()</span><br><span class="line">  .<span class="keyword">then</span>()</span><br></pre></td></tr></table></figure><p>但是这样会有一个缺点，就是链式调用后面的所有回调函数都无法被垃圾回收器回收。</p><h3 id="14-如何解决Promise链上返回的最后一个Promise出现错误"><a href="#14-如何解决Promise链上返回的最后一个Promise出现错误" class="headerlink" title="14. 如何解决Promise链上返回的最后一个Promise出现错误"></a>14. 如何解决Promise链上返回的最后一个Promise出现错误</h3><p>看如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  a.b = <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里a不存在，所以给a.b赋值是一个语法错误，onFulfilled回调函数是包在try…catch中执行的，错误会被catch到，但是由于后面没有then或catch了，这个错误无法被处理，就会被Promise吃掉，没有任何异常，这就是常说的<strong>Promise有可能会吃掉错误</strong>。</p><p>那么我们怎么处理这种情况呢？</p><p><strong>方法一</strong></p><p>就是我们前面已经实现过的done()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">42</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  a.b = <span class="number">2</span>;</span><br><span class="line">&#125;).done();</span><br></pre></td></tr></table></figure><p>done()方法相当于一个catch，但是却不再返回Promise了，注意done()方法中不能出现语法错误，否则又无法捕获了。</p><p><strong>方法二</strong></p><p>普通错误监听window的error事件可以实现捕获</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener('<span class="built_in">error</span>', <span class="built_in">error</span> =&gt; &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">error</span>); <span class="comment">// 不会触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise没有被onRejected()处理的错误需要监听unhandledrejection事件</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, <span class="keyword">error</span> =&gt; &#123;</span><br><span class="line">  console.<span class="keyword">log</span>(<span class="string">'unhandledrejection'</span>, <span class="keyword">error</span>); <span class="comment">// 可以触发，而且还可以直接拿到 promise 对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="14-单元测试"><a href="#14-单元测试" class="headerlink" title="14. 单元测试"></a>14. 单元测试</h3><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>相关单元测试以及完整代码可以到我的<a href="https://github.com/leocoder351/my-promise" target="_blank" rel="noopener">github</a>查看，如果对你有帮助的话，就来个star吧~</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180928/unittest.png" alt="单元测试"></p><p><img src="http://p54fus2hp.bkt.clouddn.com/promise-github.png" alt="github"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">PromiseA+规范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/promise.png?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Promise大家一定都不陌生了，JavaScript异步流程从最初的Callback，到Promise，到Generator，再到目前使用最多的Async/Await（如果对于这些不熟悉的可以参考我另一篇文章&lt;a href=&quot;https://segmentfault.com/a/1190000015711829&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript异步编程》&lt;/a&gt;），这不仅仅是技术实现的发展，更是思想上对于如何控制异步的递进。Promise作为后续方案的基础，是重中之重，也是面试时候最常被问到的。&lt;/p&gt;
&lt;p&gt;今天我们就一起从0到1实现一个基于A+规范的Promise，过程中也会对Promise的异常处理，以及是否可手动终止做一些讨论，最后会对我们实现的Promise做单元测试。完整的代码已经上传到github，想直接看代码的可以&lt;a href=&quot;https://github.com/leocoder351/my-promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然已经有很多带你实现Promise类的文章了，但每个人理解的程度不一样，也许不同的文章可以带给你不同的思考呢，那我们就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="Promise" scheme="//blog.liuxuan.site/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>带你彻底弄懂Event Loop</title>
    <link href="//blog.liuxuan.site/2018/09/05/javascript_eventloop/"/>
    <id>//blog.liuxuan.site/2018/09/05/javascript_eventloop/</id>
    <published>2018-09-05T12:36:00.000Z</published>
    <updated>2018-10-27T06:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/eventloop.png?imageView2/1/w/1000/h/400" alt="stack"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我在学习浏览器和NodeJS的Event Loop时看了大量的文章，那些文章都写的很好，但是往往是每篇文章有那么几个关键的点，很多篇文章凑在一起综合来看，才可以对这些概念有较为深入的理解。</p><p>于是，我在看了大量文章之后，想要写这么一篇博客，不采用官方的描述，结合自己的理解以及示例代码，用最通俗的语言表达出来。希望大家可以通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。如果在文中出现书写错误的地方，欢迎大家留言一起探讨。</p><p>（PS：说到Event Loop肯定会提到Promise，我根据Promise A+规范自己实现了一个简易Promise库，<a href="https://github.com/leocoder351/my-promise" target="_blank" rel="noopener">源码</a>放到Github上，大家有需要的可以当做参考，后续我也会也写一篇博客来讲Promise，如果对你有用，就请给个Star吧~）</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Event-Loop是什么"><a href="#Event-Loop是什么" class="headerlink" title="Event Loop是什么"></a>Event Loop是什么</h2><p><strong>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。</strong></p><ul><li>浏览器的Event Loop是在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">html5的规范</a>中明确定义。</li><li>NodeJS的Event Loop是基于libuv实现的。可以参考Node的<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">官方文档</a>以及libuv的<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方文档</a>。</li><li>libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。</li></ul><h2 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h2><p><strong>宏队列，macrotask，也叫tasks。</strong> 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node独有)</li><li>requestAnimationFrame (浏览器独有)</li><li>I/O</li><li>UI rendering (浏览器独有)</li></ul><p><strong>微队列，microtask，也叫jobs。</strong> 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：</p><ul><li>process.nextTick (Node独有)</li><li>Promise</li><li>Object.observe</li><li>MutationObserver</li></ul><p>（注：这里只针对浏览器和NodeJS）</p><h2 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h2><p>我们先来看一张图，再看完这篇文章后，请返回来再仔细看一下这张图，相信你会有更深的理解。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180904/browser_eventloop.png" alt="browser-eventloop"></p><p>这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：</p><ol><li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li><li>全局Script代码执行完毕后，调用栈Stack会清空；</li><li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li><li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。<strong>注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行</strong>；</li><li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li><li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li><li>执行完毕后，调用栈Stack为空；</li><li>重复第3-7个步骤；</li><li>重复第3-7个步骤；</li><li>……</li></ol><p><strong>可以看到，这就是浏览器的事件循环Event Loop</strong></p><p>这里归纳3个重点：</p><ol><li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；</li><li>微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；</li><li>图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。</li></ol><p>好了，概念性的东西就这么多，来看几个示例代码，测试一下你是否掌握了:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>这里结果会是什么呢？运用上面了解到的知识，先自己做一下试试看。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确答案</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>你答对了吗？</p><p>我们来分析一下整个流程：</p><hr><ul><li>执行全局Script代码</li></ul><hr><p><strong>Step 1</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Stack Queue: [console]</p><p>Macrotask Queue: []</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1</p></blockquote><p><strong>Step 2</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 这个回调函数叫做callback1，setTimeout属于macrotask，所以放到macrotask queue中</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Stack Queue: [setTimeout]</p><p>Macrotask Queue: [callback1]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1</p></blockquote><p><strong>Step 3</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 注意，这里是同步执行的，如果不太清楚，可以去看一下我开头自己实现的promise啦~~</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 这个回调函数叫做callback2，promise属于microtask，所以放到microtask queue中</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Stack Queue: [promise]</p><p>Macrotask Queue: [callback1]</p><p>Microtask Queue: [callback2]</p><blockquote><p>打印结果：<br>1<br>4</p></blockquote><p><strong>Step 5</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 这个回调函数叫做callback3，setTimeout属于macrotask，所以放到macrotask queue中</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Stack Queue: [setTimeout]</p><p>Macrotask Queue: [callback1, callback3]</p><p>Microtask Queue: [callback2]</p><blockquote><p>打印结果：<br>1<br>4</p></blockquote><p><strong>Step 6</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>Stack Queue: [console]</p><p>Macrotask Queue: [callback1, callback3]</p><p>Microtask Queue: [callback2]</p><blockquote><p>打印结果：<br>1<br>4<br>7</p></blockquote><hr><ul><li>好啦，全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。</li></ul><hr><p><strong>Step 7</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">data</span>)       // 这里<span class="keyword">data</span>是Promise的决议值<span class="number">5</span></span><br></pre></td></tr></table></figure><p>Stack Queue: [callback2]</p><p>Macrotask Queue: [callback1, callback3]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5</p></blockquote><hr><ul><li>这里microtask queue中只有一个任务，执行完后开始从宏任务队列macrotask queue中取位于队首的任务执行</li></ul><hr><p><strong>Step 8</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>Stack Queue: [callback1]</p><p>Macrotask Queue: [callback3]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2    </p></blockquote><p>但是，执行callback1的时候又遇到了另一个Promise，Promise异步执行完后在microtask queue中又注册了一个callback4回调函数</p><p><strong>Step 9</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 这个回调函数叫做callback4，promise属于microtask，所以放到microtask queue中</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Stack Queue: [promise]</p><p>Macrotask v: [callback3]</p><p>Microtask Queue: [callback4]</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2</p></blockquote><hr><ul><li>取出一个宏任务macrotask执行完毕，然后再去微任务队列microtask queue中依次取出执行</li></ul><hr><p><strong>Step 10</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Stack Queue: [callback4]</p><p>Macrotask Queue: [callback3]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2<br>3</p></blockquote><hr><ul><li>微任务队列全部执行完，再去宏任务队列中取第一个任务执行</li></ul><hr><p><strong>Step 11</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>Stack Queue: [callback3]</p><p>Macrotask Queue: []</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2<br>3<br>6</p></blockquote><hr><ul><li>以上，全部执行完后，Stack Queue为空，Macrotask Queue为空，Micro Queue为空</li></ul><hr><p>Stack Queue: []</p><p>Macrotask Queue: []</p><p>Microtask Queue: []</p><blockquote><p>最终打印结果：<br>1<br>4<br>7<br>5<br>2<br>3<br>6</p></blockquote><p>因为是第一个例子，所以这里分析的比较详细，大家仔细看一下，接下来我们再来一个例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  </span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  &#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>最终输出结果是什么呢？参考前面的例子，好好想一想……</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确答案</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>相信大家都答对了，这里的关键在前面已经提过：</p><p><strong>在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。</strong></p><p>注：当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的，拿NodeJS中的微任务process.nextTick()来说，它的上限是1000个，后面我们会讲到。</p><p>浏览器的Event Loop就说到这里，下面我们看一下NodeJS中的Event Loop，它更复杂一些，机制也不太一样。</p><h2 id="NodeJS中的Event-Loop"><a href="#NodeJS中的Event-Loop" class="headerlink" title="NodeJS中的Event Loop"></a>NodeJS中的Event Loop</h2><h3 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h3><p>先来看一张libuv的结构图：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180904/node_libuv.png" alt="node-libuv"></p><h3 id="NodeJS中的宏队列和微队列"><a href="#NodeJS中的宏队列和微队列" class="headerlink" title="NodeJS中的宏队列和微队列"></a>NodeJS中的宏队列和微队列</h3><p>NodeJS的Event Loop中，执行宏队列的回调任务有<strong>6个阶段</strong>，如下图：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180904/node_eventloop.png" alt="node-eventloop-6phase"></p><p>各个阶段执行的任务如下：</p><ul><li><strong>timers阶段</strong>：这个阶段执行setTimeout和setInterval预定的callback</li><li><strong>I/O callback阶段</strong>：执行除了close事件的callbacks、被timers设定的callbacks、setImmediate()设定的callbacks这些之外的callbacks</li><li><strong>idle, prepare阶段</strong>：仅node内部使用</li><li><strong>poll阶段：获取新的I/O事件</strong>，适当的条件下node将阻塞在这里</li><li><strong>check阶段</strong>：执行setImmediate()设定的callbacks</li><li><strong>close callbacks阶段</strong>：执行socket.on(‘close’, ….)这些callbacks</li></ul><p><strong>NodeJS中宏队列主要有4个</strong></p><p>由上面的介绍可以看到，回调事件主要位于4个macrotask queue中：</p><ol><li>Timers Queue</li><li>IO Callbacks Queue</li><li>Check Queue</li><li>Close Callbacks Queue</li></ol><p>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。</p><p><strong>NodeJS中微队列主要有2个</strong>：</p><ol><li>Next Tick Queue：是放置process.nextTick(callback)的回调任务的</li><li>Other Micro Queue：放置其他microtask，比如Promise等</li></ol><p>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。</p><p>具体可以通过下图加深一下理解：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180904/node_eventloop2.png" alt="node-eventloop"></p><p>大体解释一下NodeJS的Event Loop过程：</p><ol><li>执行全局Script的同步代码</li><li>执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务</li><li>开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2 </li><li>Timers Queue -&gt; 步骤2 -&gt; I/O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; Timers Queue …… </li><li>这就是Node的Event Loop</li></ol><p><strong>关于NodeJS的macrotask queue和microtask queue，我画了两张图，大家作为参考：</strong></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180904/node_microtask.png" alt="node-microtaskqueue"></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180904/node_macrotask.png" alt="node-macrotaskqueue"></p><p>好啦，概念理解了我们通过几个例子来实战一下：</p><p>第一个例子</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;          <span class="regexp">//</span> callback1</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;        <span class="regexp">//</span> callback2</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;      <span class="regexp">//</span> callback3</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="regexp">//</span> callback4</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">444</span>);  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;        <span class="regexp">//</span> callback5</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">555</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="regexp">//</span> callback6</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">666</span>);  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;          <span class="regexp">//</span> callback7              </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">777</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="regexp">//</span> callback8</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">888</span>);   </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="regexp">//</span> callback9</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">999</span>);  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>请运用前面学到的知识，仔细分析一下……</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确答案</span></span><br><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">999</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">777</span></span><br><span class="line"><span class="number">444</span></span><br><span class="line"><span class="number">888</span></span><br><span class="line"><span class="number">555</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">666</span></span><br><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure><hr><hr><blockquote><p><strong>更新 2018.9.20</strong> </p></blockquote><p>上面这段代码你执行的结果可能会有多种情况，原因解释如下。</p><ul><li><p>setTimeout(fn, 0)不是严格的0，一般是setTimeout(fn, 3)或什么，会有一定的延迟时间，当setTimeout(fn, 0)和setImmediate(fn)出现在同一段同步代码中时，就会存在两种情况。</p></li><li><p><strong>第1种情况</strong>：同步代码执行完了，Timer还没到期，setImmediate回调先注册到Check Queue中，开始执行微队列，然后是宏队列，先从Timers Queue中开始，发现没回调，往下走直到Check Queue中有回调，执行，然后timer到期（只要在执行完Timer Queue后到期效果就都一样），timer回调注册到Timers Queue中，下一轮循环执行到Timers Queue中才能执行那个timer 回调；<strong>所以，这种情况下，setImmediate(fn)回调先于setTimeout(fn, 0)回调执行</strong>。</p></li><li><p><strong>第2种情况</strong>：同步代码还没执行完，timer先到期，timer回调先注册到Timers Queue中，执行到setImmediate了，它的回调再注册到Check Queue中。 然后，同步代码执行完了，执行微队列，然后开始先执行Timers Queue，先执行Timer 回调，再到Check Queue，执行setImmediate回调；<strong>所以，这种情况下，setTimeout(fn, 0)回调先于setImmediate(fn)回调执行</strong>。</p></li><li><p>所以，在同步代码中同时调setTimeout(fn, 0)和setImmediate情况是不确定的，但是如果把他们放在一个IO的回调，比如readFile(‘xx’, function () {// ….})回调中，那么IO回调是在IO Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，IO Queue执行完到Check Queue，timer Queue得到下个周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行。</p></li></ul><p>综上，这个例子是不太好的，setTimeout(fn, 0)和setImmediate(fn)如果想要保证结果唯一，就放在一个IO Callback中吧，上面那段代码可以把所有它俩同步执行的代码都放在一个IO Callback中，结果就唯一了。</p><p>更新结束</p><hr><hr><p>你答对了吗？我们来一起分析一下：</p><ul><li>执行全局Script代码，先打印<strong>start</strong>，向下执行，将setTimeout的回调callback1注册到Timers Queue中，再向下执行，将setImmediate的回调callback5注册到Check Queue中，接着向下执行，将setTimeout的回调callback7注册到Timers Queue中，继续向下，将process.nextTick的回调callback9注册到微队列Next Tick Queue中,最后一步打印<strong>end</strong>。此时，各个队列的回调情况如下：</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: [callback1, callback7]</p><p>Check Queue: [callback5]</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: [callback9]</p><p>Other Microtask Queue: []</p><blockquote><p>打印结果<br>start<br>end    </p></blockquote><ul><li>全局Script执行完了，开始依次执行微任务Next Tick Queue中的全部回调任务。此时Next Tick Queue中只有一个callback9，将其取出放入调用栈中执行，打印<strong>999</strong>。</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: [callback1, callback7]</p><p>Check Queue: [callback5]</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: []</p><p>Other Microtask Queue: []</p><blockquote><p>打印结果<br>start<br>end<br>999</p></blockquote><ul><li>开始依次执行6个阶段各自宏队列中的所有任务，先执行第1个阶段Timers Queue中的所有任务，先取出callback1执行，打印<strong>111</strong>，callback1函数继续向下，依次把callback2放入Timers Queue中，把callback3放入Check Queue中，把callback4放入Next Tick Queue中，然后callback1执行完毕。再取出Timers Queue中此时排在首位的callback7执行，打印<strong>777</strong>，把callback8放入Next Tick Queue中，执行完毕。此时，各队列情况如下：</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: [callback2]</p><p>Check Queue: [callback5, callback3]</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: [callback4, callback8]</p><p>Other Microtask Queue: []</p><blockquote><p>打印结果<br>start<br>end<br>999<br>111<br>777    </p></blockquote><ul><li>6个阶段每阶段的宏任务队列执行完毕后，都会开始执行微任务，此时，先取出Next Tick Queue中的所有任务执行，callback4开始执行，打印<strong>444</strong>，然后callback8开始执行，打印<strong>888</strong>，Next Tick Queue执行完毕，开始执行Other Microtask Queue中的任务，因为里面为空，所以继续向下。</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: [callback2]</p><p>Check Queue: [callback5, callback3]</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: []</p><p>Other Microtask Queue: []</p><blockquote><p>打印结果<br>start<br>end<br>999<br>111<br>777<br>444<br>888    </p></blockquote><ul><li>第2个阶段IO Callback Queue队列为空，跳过，第3和第4个阶段一般是Node内部使用，跳过，进入第5个阶段Check Queue。取出callback5执行，打印<strong>555</strong>，把callback6放入Next Tick Queue中，执行callback3，打印<strong>333</strong>。</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: [callback2]</p><p>Check Queue: []</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: [callback6]</p><p>Other Microtask Queue: []</p><blockquote><p>打印结果<br>start<br>end<br>999<br>111<br>777<br>444<br>888<br>555<br>333    </p></blockquote><ul><li>执行微任务队列，先执行Next Tick Queue，取出callback6执行，打印<strong>666</strong>，执行完毕，因为Other Microtask Queue为空，跳过。</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: [callback2]</p><p>Check Queue: []</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: [callback6]</p><p>Other Microtask Queue: []</p><blockquote><p>打印结果<br>start<br>end<br>999<br>111<br>777<br>444<br>888<br>555<br>333    </p></blockquote><ul><li>执行第6个阶段Close Callback Queue中的任务，为空，跳过，好了，此时一个循环已经结束。进入下一个循环，执行第1个阶段Timers Queue中的所有任务，取出callback2执行，打印<strong>222</strong>，完毕。此时，所有队列包括宏任务队列和微任务队列都为空，不再打印任何东西。</li></ul><p><strong>宏队列</strong></p><p>Timers Queue: []</p><p>Check Queue: []</p><p>IO Callback Queue： []</p><p>Close Callback Queue: []</p><p><strong>微队列</strong></p><p>Next Tick Queue: [callback6]</p><p>Other Microtask Queue: []</p><blockquote><p>最终结果<br>start<br>end<br>999<br>111<br>777<br>444<br>888<br>555<br>333<br>666<br>222</p></blockquote><p>以上就是这道题目的详细分析，如果没有明白，一定要多看几次。</p><hr><p>下面引入Promise再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>大家仔细分析，相比于上一个例子，这里由于存在Promise，所以Other Microtask Queue中也会有回调任务的存在，执行到微任务阶段时，先执行Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务，然后才会进入下一个阶段的宏任务。明白了这一点，相信大家都可以分析出来，下面直接给出正确答案，如有疑问，欢迎留言和我讨论。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确答案</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="setTimeout-对比-setImmediate"><a href="#setTimeout-对比-setImmediate" class="headerlink" title="setTimeout 对比 setImmediate"></a>setTimeout 对比 setImmediate</h3><ul><li>setTimeout(fn, 0)在Timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行</li><li>setImmediate(fn)在Check阶段执行</li></ul><p>两者的执行顺序要根据当前的执行环境才能确定：</p><ul><li>如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机</li><li>如果两者都不在主模块调用，即在一个I/O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段</li></ul><h3 id="setImmediate-对比-process-nextTick"><a href="#setImmediate-对比-process-nextTick" class="headerlink" title="setImmediate 对比 process.nextTick"></a>setImmediate 对比 process.nextTick</h3><ul><li>setImmediate(fn)的回调任务会插入到宏队列Check Queue中</li><li>process.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中</li><li>process.nextTick(fn)调用深度有限制，上限是1000，而setImmedaite则没有</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>浏览器的Event Loop和NodeJS的Event Loop是不同的，实现机制也不一样，不要混为一谈。</li><li>浏览器可以理解成只有1个宏任务队列和1个微任务队列，先执行全局Script代码，执行完同步代码调用栈清空后，从微任务队列中依次取出所有的任务放入调用栈执行，微任务队列清空后，从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里和Node的区别，只取一个，然后继续执行微队列中的所有任务，再去宏队列取一个，以此构成事件循环。</li><li>NodeJS可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段。先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务队列Next Tick Queue中依次取出所有的任务放入调用栈中执行，再从微任务队列Other Microtask Queue中依次取出所有的任务放入调用栈中执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行（注意，这里和浏览器不一样，浏览器只取一个），每个宏任务阶段执行完毕后，开始执行微任务，再开始执行下一阶段宏任务，以此构成事件循环。</li><li>MacroTask包括： setTimeout、setInterval、 setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering</li><li>Microtask包括： process.nextTick(Node)、Promise、Object.observe、MutationObserver</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882" target="_blank" rel="noopener">不要混淆nodejs和浏览器中的event loop</a><br><a href="https://github.com/SunShinewyf/issue-blog/issues/34#issuecomment-371106502" target="_blank" rel="noopener">node中的Event模块</a><br><a href="https://jsblog.insiderattack.net/promises-next-ticks-and-immediates-nodejs-event-loop-part-3-9226cbe7a6aa" target="_blank" rel="noopener">Promises, process.nextTick And setImmediate</a><br><a href="https://segmentfault.com/a/1190000013660033" target="_blank" rel="noopener">浏览器和Node不同的事件循环</a><br><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a><br><a href="https://github.com/ccforward/cc/issues/47" target="_blank" rel="noopener">理解事件循环浅析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/eventloop.png?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我在学习浏览器和NodeJS的Event Loop时看了大量的文章，那些文章都写的很好，但是往往是每篇文章有那么几个关键的点，很多篇文章凑在一起综合来看，才可以对这些概念有较为深入的理解。&lt;/p&gt;
&lt;p&gt;于是，我在看了大量文章之后，想要写这么一篇博客，不采用官方的描述，结合自己的理解以及示例代码，用最通俗的语言表达出来。希望大家可以通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。如果在文中出现书写错误的地方，欢迎大家留言一起探讨。&lt;/p&gt;
&lt;p&gt;（PS：说到Event Loop肯定会提到Promise，我根据Promise A+规范自己实现了一个简易Promise库，&lt;a href=&quot;https://github.com/leocoder351/my-promise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;放到Github上，大家有需要的可以当做参考，后续我也会也写一篇博客来讲Promise，如果对你有用，就请给个Star吧~）&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="V8" scheme="//blog.liuxuan.site/tags/V8/"/>
    
      <category term="Node" scheme="//blog.liuxuan.site/tags/Node/"/>
    
      <category term="Event Loop" scheme="//blog.liuxuan.site/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现函数重载</title>
    <link href="//blog.liuxuan.site/2018/08/29/javascript_function_overload/"/>
    <id>//blog.liuxuan.site/2018/08/29/javascript_function_overload/</id>
    <published>2018-08-29T12:36:00.000Z</published>
    <updated>2018-10-27T06:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/overload.jpg?imageView2/1/w/1000/h/400" alt="stack"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>重载</strong>是指函数或者方法有相同的名称，但是参数个数或类型不相同的情形，这样的同名不同参的函数或者方法之间，互相称之为重载函数或方法。</p><p>我们知道，JavaScript函数可以随意传递任意数量、任意类型的参数，那么它有没有重载呢？</p><p>答案是有的，下面我们通过3种方法来实现JavaScript的函数重载。</p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="0-目标"><a href="#0-目标" class="headerlink" title="0. 目标"></a>0. 目标</h3><p>我们有一个people对象<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var people</span> = &#123;</span><br><span class="line">  values: [<span class="string">'Dean Edwards'</span>, <span class="string">'Sam Stephenson'</span>, <span class="string">'Alex Russell'</span>, <span class="string">'Dean Tom'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>想要实现一个find方法，不传参数的时候，输出所有名字，只传1个参数的时候，输出所有fristName和参数相同的名字，传2个参数的时候，输出所有firstName和lastName和2个参数分别相同的名字。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.find();                          <span class="regexp">//</span> [<span class="string">"Dean Edwards"</span>, <span class="string">"Sam Stephenson"</span>, <span class="string">"Alex Russell"</span>, <span class="string">"Dean Tom"</span>]</span><br><span class="line">people.find(<span class="string">'Dean'</span>);                    <span class="regexp">//</span> [<span class="string">"Dean Edwards"</span>, <span class="string">"Dean Tom"</span>]</span><br><span class="line">people.find(<span class="string">'Dean'</span>, <span class="string">'Edwards'</span>);            <span class="regexp">//</span> [<span class="string">"Dean Edwards"</span>]</span><br></pre></td></tr></table></figure><h3 id="1-利用arguments和switch实现重载"><a href="#1-利用arguments和switch实现重载" class="headerlink" title="1. 利用arguments和switch实现重载"></a>1. 利用arguments和switch实现重载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">people.find = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.values;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.values.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> firstName = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> value.indexOf(firstName) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.values.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> fullName = <span class="string">`<span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span> <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">return</span> value.indexOf(fullName) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(people.find());                 <span class="comment">// ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]</span></span><br><span class="line"><span class="built_in">console</span>.log(people.find(<span class="string">'Dean'</span>));           <span class="comment">// ["Dean Edwards", "Dean Tom"]</span></span><br><span class="line"><span class="built_in">console</span>.log(people.find(<span class="string">'Dean'</span>, <span class="string">'Edwards'</span>));   <span class="comment">// ["Dean Edwards"]</span></span><br></pre></td></tr></table></figure><p>这种方式大家肯定都能看懂，就不多说啦。</p><h3 id="2-利用arguments和闭包实现重载"><a href="#2-利用arguments和闭包实现重载" class="headerlink" title="2. 利用arguments和闭包实现重载"></a>2. 利用arguments和闭包实现重载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span> (<span class="params">object, name, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把前一次添加的方法存在一个临时变量old中</span></span><br><span class="line">  <span class="keyword">var</span> old = object[name];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写object[name]方法</span></span><br><span class="line">  object[name] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fn.length === <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      <span class="comment">// 如果调用object[name]方法时，如果实参和形参个数一致，则直接调用</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果实参形参不一致，判断old是否是函数，如果是，就调用old</span></span><br><span class="line">      <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMethod(people, <span class="string">'find'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.values;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addMethod(people, <span class="string">'find'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.values.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.indexOf(firstName) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addMethod(people, <span class="string">'find'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.values.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName = <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> value.indexOf(fullName) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(people.find());                     <span class="comment">// ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]</span></span><br><span class="line"><span class="built_in">console</span>.log(people.find(<span class="string">'Dean'</span>));               <span class="comment">// ["Dean Edwards", "Dean Tom"]</span></span><br><span class="line"><span class="built_in">console</span>.log(people.find(<span class="string">'Dean'</span>, <span class="string">'Edwards'</span>));    <span class="comment">// ["Dean Edwards"]</span></span><br></pre></td></tr></table></figure><p>这里addMethod(object, name, fn)方法是核心。我们着重分析一下为什么这里会有闭包，可以保存上一个注册的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span> (<span class="params">object, name, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// object, name, fn是传入的3个参数</span></span><br><span class="line">  <span class="keyword">var</span> old = object[name];</span><br><span class="line"></span><br><span class="line">  object[name] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里对old和fn进行了引用</span></span><br><span class="line">    <span class="keyword">if</span> (fn.length === <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object是另外一个引用对象，它的一个方法中引用了old和fn，所以对于addMethod来说，它的局部变量在addMethod函数执行完后，仍然被另外的变量所引用，导致它的<strong>执行环境无法销毁，所以产生了闭包</strong>。</p><p>因此，每次调用addMethod，都会有一个执行环境保存着当时的old和fn，所以在调用people.find()的时候可以找到当时注入的fn，实现函数重载。</p><h3 id="3-利用Proxy和arguments实现重载"><a href="#3-利用Proxy和arguments实现重载" class="headerlink" title="3. 利用Proxy和arguments实现重载"></a>3. 利用Proxy和arguments实现重载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(people, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'find'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values;</span><br><span class="line">      </span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> firstName = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">return</span> value.indexOf(firstName) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">      </span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.values.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> fullName = <span class="string">`<span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span> <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line">              <span class="keyword">return</span> value.indexOf(fullName) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target , key , receiver);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.find());                     <span class="comment">// ["Dean Edwards", "Sam Stephenson", "Alex Russell", "Dean Tom"]</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.find(<span class="string">'Dean'</span>));               <span class="comment">// ["Dean Edwards", "Dean Tom"]</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.find(<span class="string">'Dean'</span>, <span class="string">'Edwards'</span>));   <span class="comment">// ["Dean Edwards"]</span></span><br></pre></td></tr></table></figure><p>这样写其实感觉有点画蛇添足了，就当成是另外一种思路吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript可以实现函数重载，主要有两种思想：</p><ol><li>利用arguments类数组来判断接收参数的个数</li><li>利用闭包保存以前注册进来的同名函数</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/overload.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;是指函数或者方法有相同的名称，但是参数个数或类型不相同的情形，这样的同名不同参的函数或者方法之间，互相称之为重载函数或方法。&lt;/p&gt;
&lt;p&gt;我们知道，JavaScript函数可以随意传递任意数量、任意类型的参数，那么它有没有重载呢？&lt;/p&gt;
&lt;p&gt;答案是有的，下面我们通过3种方法来实现JavaScript的函数重载。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="继承" scheme="//blog.liuxuan.site/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="原型链" scheme="//blog.liuxuan.site/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="重载" scheme="//blog.liuxuan.site/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现继承</title>
    <link href="//blog.liuxuan.site/2018/08/28/javascript_extend/"/>
    <id>//blog.liuxuan.site/2018/08/28/javascript_extend/</id>
    <published>2018-08-28T12:36:00.000Z</published>
    <updated>2018-10-27T06:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/extend.png?imageView2/1/w/1000/h/400" alt="stack"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文不准备深入细节，主要是对《JavaScript高级程序设计中》介绍的JS如何实现继承做一个总结，毕竟好记性不如烂笔头。文末会附带一张神图，搞清楚这张图，原型链也就没有什么问题了。</p><a id="more"></a><h2 id="ES5实现继承的六种方式"><a href="#ES5实现继承的六种方式" class="headerlink" title="ES5实现继承的六种方式"></a>ES5实现继承的六种方式</h2><h3 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h3><p>基本思想：</p><p><strong>利用原型链让一个引用类型继承另一个引用类型的属性和方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 SubType</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance);</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());                            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);                         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);                       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                          <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>缺点：</p><p><strong>1. 来自原型对象的引用属性是所有实例共享的。</strong></p><p><strong>2. 创建子类实例时，无法向父类构造函数传参。</strong></p><p>举例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 来自原型对象的引用属性是所有实例共享的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);        <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);        <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为修改colors是修改的SubType.prototype.colors，所以所有的实例都会更新</span></span><br></pre></td></tr></table></figure></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">2</span>. 创建子类实例时，无法向父类构造函数传参</span><br><span class="line"></span><br><span class="line">// 调用父类是在 <span class="keyword">SubType</span>.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">// 新建子类实例调用 <span class="keyword">new</span> <span class="keyword">SubType</span>()</span><br><span class="line">// 所以无法再<span class="keyword">new</span> <span class="keyword">SubType</span>() 的时候给父类 SuperType() 传参</span><br></pre></td></tr></table></figure><h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h3><p>基本思想：</p><p><strong>在子类构造函数的内部通过call()以及apply()调用父类构造函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 SuperType</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SuperType，同时还传递了参数</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Tom'</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.name);               <span class="comment">// "Tom"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.getName());          <span class="comment">// "Tom"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.age);                <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);             <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Peter'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.name);               <span class="comment">// "Peter"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.getName());          <span class="comment">// "Peter"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.age);                <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);             <span class="comment">// ['red', 'blue', 'green']</span></span><br></pre></td></tr></table></figure><p>可以看到，借用构造函数实现继承，解决了原型链继承的两个问题，既可以在新建子类实例的时候给父类构造函数传递参数，也不会造成子类实例共享父类引用变量。</p><p>但是你注意到了吗，这里我们把父类方法也写在了SuperType()构造函数里面，可以像前面一样写在SuperType.prototype上吗？</p><p><strong>答案是不可以</strong>，必须写在SuperType()构造函数里面。因为这里是通过调用SuperType.call(this)来实现继承的，并没有通过new生成一个父类实例，所以如果写在prototype上，子类是无法拿到的。</p><p>缺点：</p><p><strong>1. 如果方法都在构造函数中定义，那么就无法复用函数。每次构建实例时都会在实例中保留方法函数，造成了内存的浪费，同时也无法实现同步更新，因为每个实例都是单独的方法函数。如果方法写在prototype上，就只会有一份，更新时候会做到同步更新。</strong></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180828/extend1.png" alt="extend1"></p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180828/extend2.png" alt="extend2"></p><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><p>基本思想：</p><p><strong>将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</strong></p><p>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类实例属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 子类实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Tom'</span>, <span class="number">20</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);                  <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line">instance1.sayName();                            <span class="comment">// "Tom"</span></span><br><span class="line">instance1.sayAge();                             <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Peter'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);                  <span class="comment">// ['red', 'blue', 'green']</span></span><br><span class="line">instance2.sayName();                            <span class="comment">// "Peter"</span></span><br><span class="line">instance2.sayAge();                             <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>缺点：</p><p><strong>1. 调用了两次父类构造函数，一次通过SuperType.call(this)调用，一次通过new SuperType()调用。</strong></p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h2><p>基本思想：</p><p><strong>不使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，同时还不必因此创建自定义类型。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 在object函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</span><br><span class="line">// 从本质上讲，object()对传入其中的对象执行了一次浅复制。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> <span class="params">(o)</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>);</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">'Linda'</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'Barbie'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(anotherPerson.friends);               // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>, <span class="string">'Barbie'</span>]</span><br><span class="line">console.<span class="built_in">log</span>(yetAnotherPerson.friends);            // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>, <span class="string">'Barbie'</span>]</span><br><span class="line">console.<span class="built_in">log</span>(person.friends);                      // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>, <span class="string">'Barbie'</span>]</span><br></pre></td></tr></table></figure><p>ECMAScript5中新增了一个方法Object.create(prototype, descripter)接收两个参数：</p><ul><li>prototype（必选），用作新对象的原型对象</li><li>descripter（可选），为新对象定义额外属性的对象</li></ul><p>在传入一个参数的情况下，Object.create()与前面写的object()方法的行为相同。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.<span class="built_in">create</span>(person);</span><br><span class="line">anotherPerson.name = <span class="string">'Greg'</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>);</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = Object.<span class="built_in">create</span>(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">'Linda'</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">'Barbie'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(anotherPerson.friends);               // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>, <span class="string">'Barbie'</span>]</span><br><span class="line">console.<span class="built_in">log</span>(yetAnotherPerson.friends);            // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>, <span class="string">'Barbie'</span>]</span><br><span class="line">console.<span class="built_in">log</span>(person.friends);                      // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>, <span class="string">'Barbie'</span>]</span><br></pre></td></tr></table></figure><p>缺点：</p><p><strong>1. 和原型链继承一样，所有子类实例共享父类的引用类型。</strong></p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>基本原理：</p><p><strong>寄生式继承是与原型式继承紧密相关的一种思路，创建一个仅用于封装继承过程的函数，该函数内部以某种形式来做增强对象，最后返回对象。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> <span class="params">(o)</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span> <span class="params">(o)</span></span> &#123;</span><br><span class="line">  var clone = object(o);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'Hi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>] </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();                              // <span class="string">"Hi"</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">'Rob'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(anotherPerson.friends);              // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>]</span><br><span class="line">var yerAnotherPerson = createAnother(person);</span><br><span class="line">console.<span class="built_in">log</span>(yerAnotherPerson.friends);              // [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>, <span class="string">'Van'</span>, <span class="string">'Rob'</span>]</span><br></pre></td></tr></table></figure><p>缺点：</p><p><strong>1. 和原型链式继承一样，所有子类实例共享父类引用类型。</strong></p><p><strong>2. 和借用构造函数继承一样，每次创建对象都会创建一次方法。</strong></p><h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h3><p>基本思想：</p><p><strong>将寄生式继承和组合继承相结合，解决了组合式继承中会调用两次父类构造函数的缺点。</strong></p><p>组合继承是JavaScript最常用的继承模式，它最大的问题就是无论在什么情况下，都会调用两次父类构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数内部。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//第二次调用 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>组合继承在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是 SuperType 的实例属性，只不过现在位于 SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。</p><p><strong>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。</strong></p><p>其背后的基本思路是：不必为了指定子类型的原型而调用父类的构造函数，我们需要的无非就是父类原型的一个副本而已。本质上，就是使用寄生式继承来继承父类的prototype，然后再将结果指定给子类的prototype。</p><p>寄生组合式继承的基本模型如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">function</span> inheritProto<span class="keyword">type</span>(<span class="type">SubType</span>, <span class="type">SuperType</span>) &#123;</span><br><span class="line">    var prototype = object(<span class="type">SuperType</span>.prototype);        // 创建对象</span><br><span class="line">    prototype.constructor = <span class="type">SubType</span>;    // 增强对象</span><br><span class="line">    <span class="type">SubType</span>.prototype = prototype;      // 指定对象</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个完整的寄生组合式继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">SubType, SuperType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(SuperType.prototype);        <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.constructor = SubType;    <span class="comment">// 增强对象</span></span><br><span class="line">  SubType.prototype = prototype;      <span class="comment">// 指定对象 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类实例属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类方法</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类方法</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Tom'</span>, <span class="number">20</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line">instance1.sayAge();                                   <span class="comment">// 20</span></span><br><span class="line">instance1.sayName();                                  <span class="comment">// "Tom"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);                        <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Peter'</span>, <span class="number">30</span>);</span><br><span class="line">instance2.sayAge();                                   <span class="comment">// 30</span></span><br><span class="line">instance2.sayName();                                  <span class="comment">// "Peter"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);                        <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><p>寄生组合式继承的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了再SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变。因此，还能够正常使用instanceof和isPrototypeOf()。</p><p><strong>开发人员普遍认为寄生组合式继承是引用类型最理想的继承方式。</strong></p><hr><h2 id="ES6实现继承"><a href="#ES6实现继承" class="headerlink" title="ES6实现继承"></a>ES6实现继承</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    <span class="comment">// 继承父类实例属性和prototype上的方法</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子类实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类方法</span></span><br><span class="line">  sayAge() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="type">SubType</span>(<span class="symbol">'To</span>m', <span class="number">20</span>);</span><br><span class="line">instance1.colors.push(<span class="symbol">'blac</span>k');</span><br><span class="line">instance1.sayAge();                                   <span class="comment">// 20</span></span><br><span class="line">instance1.sayName();                                  <span class="comment">// "Tom"</span></span><br><span class="line">console.log(instance1.colors);                        <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="type">SubType</span>(<span class="symbol">'Pete</span>r', <span class="number">30</span>);</span><br><span class="line">instance2.sayAge();                                   <span class="comment">// 30</span></span><br><span class="line">instance2.sayName();                                  <span class="comment">// "Peter"</span></span><br><span class="line">console.log(instance2.colors);                        <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><p>用ES6的语法来实现继承非常的简单，下面是把这段代码放到Babel里转码的结果图片：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180828/babel-es6-extend.png" alt="babel-es6-extend"></p><p>可以看到，底层其实也是用寄生组合式继承来实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ES5实现继承有6种方式：</p><ol><li>原型链继承</li><li>借用构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol><p>寄生组合式继承是大家公认的最好的实现引用类型继承的方法。</p><p>ES6新增class和extends语法，用来定义类和实现继承，底层也是采用了寄生组合式继承。</p><p>附图：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180829/JavaScript_prototype.png" alt="prototype"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/extend.png?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文不准备深入细节，主要是对《JavaScript高级程序设计中》介绍的JS如何实现继承做一个总结，毕竟好记性不如烂笔头。文末会附带一张神图，搞清楚这张图，原型链也就没有什么问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="继承" scheme="//blog.liuxuan.site/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="原型链" scheme="//blog.liuxuan.site/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="寄生组合式继承" scheme="//blog.liuxuan.site/tags/%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构04 - 链表</title>
    <link href="//blog.liuxuan.site/2018/08/03/javascript_data_structure_04_linked_list/"/>
    <id>//blog.liuxuan.site/2018/08/03/javascript_data_structure_04_linked_list/</id>
    <published>2018-08-03T12:36:00.000Z</published>
    <updated>2018-10-27T06:27:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/linked_list.gif?imageView2/1/w/1000/h/400" alt="stack"></p><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>前面我们学习了<a href="https://segmentfault.com/a/1190000015768412" target="_blank" rel="noopener">数组</a>这种数据结构。数组（或者也可以称为列表）是一种非常简单的存储数据序列的数据结构。在这一节，我们要学习如何实现和使用<strong>链表</strong>这种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩容。</p><p>要存储多个元素，数组（或列表）可能是最常用的数据结构，它提供了一个便利的<strong>[]</strong>语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数强类型语言中）数组的大小是固定的，需要预先分配，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。<br><strong>（注意：在JavaScript中数组的大小随时可变，不需要预先定义长度）</strong></p><p><strong>链表</strong>存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。</p><a id="more"></a><p>相对于传统的数组，链表的一个好处在于，添加或删除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的元素，而想要访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。</p><p><strong>火车</strong>可以当做生活中一个典型的链表的例子。一列火车是由一系列车厢组成的。每节车厢都相互连接。你很容易分离一节车厢，改变它的位置，添加或移除它。</p><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><p><strong>链表最常用的有三类</strong>：</p><ol><li>单向链表</li><li>双向链表</li><li>循环链表</li></ol><h2 id="二、链表的实现"><a href="#二、链表的实现" class="headerlink" title="二、链表的实现"></a>二、链表的实现</h2><h3 id="2-1-单向链表"><a href="#2-1-单向链表" class="headerlink" title="2.1 单向链表"></a>2.1 单向链表</h3><p>创建单向链表类：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SinglyLinkedList</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SinglyLinkedList</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span> <span class="params">(element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> <span class="params">(position, element)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> <span class="params">(position)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SinglyLinkedList需要一个辅助类Node。Node类表示要加入链表的项。它包含一个element属性，即要添加到链表的值，以及一个next属性，即指向链表中下一个节点项的指针。</p><p>链表里面有一些声明的辅助方法：</p><ul><li>append(element)：向链表尾部添加新项</li><li>insert(position, element)：向链表的特定位置插入一个新的项</li><li>removeAt(position)：从链表的特定位置移除一项</li><li>remove(element)：从链表中移除一项</li><li>indexOf(element)：返回元素在链表中的索引。如果链表中没有该元素则返回-1</li><li>isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0，返回false</li><li>size()：返回链表包含的元素个数，与数组的length属性类似</li><li>getHead()：返回链表的第一个元素</li><li>toString()：由于链表使用了Node类，就需要重写继承自JavaScript对象默认的toString()方法，让其只输出元素的值</li><li>print()：打印链表的所有元素</li></ul><p>下面我们来一一实现这些辅助方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向链表尾部添加一个新的项</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">  <span class="keyword">var</span> currentNode = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空链表</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 空链表</span></span><br><span class="line">    head = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 从head开始一直找到最后一个node</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode.next) &#123;</span><br><span class="line">      <span class="comment">// 后面还有node</span></span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.next = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  length++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向链表特定位置插入一个新的项</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> &amp;&amp; position &gt; length) &#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> currentNode = head;</span><br><span class="line">    <span class="keyword">var</span> previousNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      previousNode.next = node;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> &amp;&amp; position &gt;= length || length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentNode = head;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> previousNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      head = currentNode.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> &amp;&amp; position &gt;= length || length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentNode = head;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> previousNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      head = currentNode.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中移除指定项</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回元素在链表的索引，如果链表中没有该元素则返回-1</span></span><br><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentNode = head;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.element === element) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果链表中不包含任何元素，返回true，如果链表长度大于0，返回false</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表包含的元素个数，与数组的length属性类似</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表头部元素</span></span><br><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> head.element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于链表使用了Node类，就需要重写继承自JavaScript对象默认的toString()方法，让其只输出元素的值</span></span><br><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentNode = head;</span><br><span class="line">  <span class="keyword">var</span> string = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    string += <span class="string">','</span> + currentNode.element;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> string.slice(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>创建单向链表实例进行测试：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建单向链表实例</span></span><br><span class="line">var singlyLinked = <span class="keyword">new</span> SinglyLinkedList();</span><br><span class="line">console.<span class="built_in">log</span>(singlyLinked.removeAt(<span class="number">0</span>));              <span class="comment">// true</span></span><br><span class="line">console.<span class="built_in">log</span>(singlyLinked.isEmpty());              <span class="comment">// true</span></span><br><span class="line">singlyLinked.<span class="built_in">append</span>(<span class="string">'Tom'</span>);                       </span><br><span class="line">singlyLinked.<span class="built_in">append</span>(<span class="string">'Peter'</span>);</span><br><span class="line">singlyLinked.<span class="built_in">append</span>(<span class="string">'Paul'</span>);</span><br><span class="line">singlyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Tom,Peter,Paul"</span></span><br><span class="line">singlyLinked.insert(<span class="number">0</span>, <span class="string">'Susan'</span>);                  </span><br><span class="line">singlyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Susan,Tom,Peter,Paul"</span></span><br><span class="line">singlyLinked.insert(<span class="number">1</span>, <span class="string">'Jack'</span>);                   </span><br><span class="line">singlyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Susan,Jack,Tom,Peter,Paul"</span></span><br><span class="line">console.<span class="built_in">log</span>(singlyLinked.getHead());              <span class="comment">// "Susan"</span></span><br><span class="line">console.<span class="built_in">log</span>(singlyLinked.isEmpty());              <span class="comment">// false</span></span><br><span class="line">console.<span class="built_in">log</span>(singlyLinked.indexOf(<span class="string">'Peter'</span>));       <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(singlyLinked.indexOf(<span class="string">'Cris'</span>));        <span class="comment">// -1</span></span><br><span class="line">singlyLinked.remove(<span class="string">'Tom'</span>);                       </span><br><span class="line">singlyLinked.removeAt(<span class="number">2</span>);                         </span><br><span class="line">singlyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Susan,Jack,Paul"</span></span><br></pre></td></tr></table></figure></p><h3 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h3><p><strong>双向链表</strong>和普通链表的区别在于，在普通链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。</p><p>创建双向链表类：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建双向链表DoublyLinkedList类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span> <span class="params">(element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.prev = <span class="literal">null</span>;        <span class="comment">// 新增</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> tail = <span class="literal">null</span>;          <span class="comment">// 新增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，双向链表在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性。</p><p>双向链表提供了两种迭代列表的方法：从头到尾，或者从尾到头。我们可以访问一个特定节点的下一个或前一个元素。</p><p>在单向链表中，如果迭代链表时错过了要找的元素，就需要回到链表起点，重新开始迭代。在双向链表中，可以从任一节点，向前或向后迭代，这是双向链表的一个优点。</p><p>实现双向链表的辅助方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向链表尾部添加一个新的项</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">  <span class="keyword">var</span> currentNode = tail;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空链表</span></span><br><span class="line">  <span class="keyword">if</span> (currentNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 空链表</span></span><br><span class="line">    head = node;</span><br><span class="line">    tail = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    currentNode.next = node;</span><br><span class="line">    node.prev = currentNode;</span><br><span class="line">    tail = node; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  length++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向链表特定位置插入一个新的项</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span> (<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> &amp;&amp; position &gt; length) &#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> currentNode = head;</span><br><span class="line">    <span class="keyword">var</span> previousNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        tail = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = currentNode;</span><br><span class="line">        currentNode.prev = node;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.append(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      previousNode.next = node;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line"></span><br><span class="line">      node.prev = previousNode;</span><br><span class="line">      currentNode.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表的特定位置移除一项</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span> (<span class="params">position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> &amp;&amp; position &gt;= length || length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentNode = head;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> previousNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 移除第一项</span></span><br><span class="line">      <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = currentNode.next;</span><br><span class="line">        head.prev = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 移除最后一项</span></span><br><span class="line">      <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = tail;</span><br><span class="line">        tail = currentNode.prev;</span><br><span class="line">        tail.next = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNode.next = currentNode.next;</span><br><span class="line">      previousNode = currentNode.next.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中移除指定项</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回元素在链表的索引，如果链表中没有该元素则返回-1</span></span><br><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentNode = head;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode.element === element) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果链表中不包含任何元素，返回true，如果链表长度大于0，返回false</span></span><br><span class="line"><span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表包含的元素个数，与数组的length属性类似</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表头部元素</span></span><br><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> head.element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于链表使用了Node类，就需要重写继承自JavaScript对象默认的toString()方法，让其只输出元素的值</span></span><br><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentNode = head;</span><br><span class="line">  <span class="keyword">var</span> string = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">    </span><br><span class="line">    string += <span class="string">','</span> + currentNode.element;</span><br><span class="line">    currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> string.slice(<span class="number">1</span>);    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>创建双向链表实例进行测试：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建双向链表</span></span><br><span class="line">var doublyLinked = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line">console.<span class="built_in">log</span>(doublyLinked.isEmpty());              <span class="comment">// true</span></span><br><span class="line">doublyLinked.<span class="built_in">append</span>(<span class="string">'Tom'</span>);                       </span><br><span class="line">doublyLinked.<span class="built_in">append</span>(<span class="string">'Peter'</span>);</span><br><span class="line">doublyLinked.<span class="built_in">append</span>(<span class="string">'Paul'</span>);</span><br><span class="line">doublyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Tom,Peter,Paul"</span></span><br><span class="line">doublyLinked.insert(<span class="number">0</span>, <span class="string">'Susan'</span>);                  </span><br><span class="line">doublyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Susan,Tom,Peter,Paul"</span></span><br><span class="line">doublyLinked.insert(<span class="number">1</span>, <span class="string">'Jack'</span>);                   </span><br><span class="line">doublyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Susan,Jack,Tom,Peter,Paul"</span></span><br><span class="line">console.<span class="built_in">log</span>(doublyLinked.getHead());              <span class="comment">// "Susan"</span></span><br><span class="line">console.<span class="built_in">log</span>(doublyLinked.isEmpty());              <span class="comment">// false</span></span><br><span class="line">console.<span class="built_in">log</span>(doublyLinked.indexOf(<span class="string">'Peter'</span>));       <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(doublyLinked.indexOf(<span class="string">'Cris'</span>));        <span class="comment">// -1</span></span><br><span class="line">doublyLinked.remove(<span class="string">'Tom'</span>);                       </span><br><span class="line">doublyLinked.removeAt(<span class="number">2</span>);                         </span><br><span class="line">doublyLinked.<span class="built_in">print</span>();                             <span class="comment">// "Susan,Jack,Paul"</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h3><p>循环链表可以像单向链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和普通链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（next）不是引用null，而是指向第一个元素（head）。这里就不进行代码实现了，大家可以结合上面的单向链表和双向链表自己实现一个循环链表。</p><h2 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h2><p>本文会同步到我的<a href="https://blog.liuxuan.site" target="_blank" rel="noopener">个人博客</a>，完整代码可以到我的<a href="https://github.com/leocoder351/data-structure" target="_blank" rel="noopener">github仓库查看</a>，如果对你有帮助的话欢迎点一个Star~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/linked_list.gif?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;h3 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 概念&quot;&gt;&lt;/a&gt;1.1 概念&lt;/h3&gt;&lt;p&gt;前面我们学习了&lt;a href=&quot;https://segmentfault.com/a/1190000015768412&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数组&lt;/a&gt;这种数据结构。数组（或者也可以称为列表）是一种非常简单的存储数据序列的数据结构。在这一节，我们要学习如何实现和使用&lt;strong&gt;链表&lt;/strong&gt;这种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩容。&lt;/p&gt;
&lt;p&gt;要存储多个元素，数组（或列表）可能是最常用的数据结构，它提供了一个便利的&lt;strong&gt;[]&lt;/strong&gt;语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数强类型语言中）数组的大小是固定的，需要预先分配，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。&lt;br&gt;&lt;strong&gt;（注意：在JavaScript中数组的大小随时可变，不需要预先定义长度）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="数据结构" scheme="//blog.liuxuan.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="//blog.liuxuan.site/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="//blog.liuxuan.site/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构03 - 队列</title>
    <link href="//blog.liuxuan.site/2018/07/26/javascript_data_structure_03_queue/"/>
    <id>//blog.liuxuan.site/2018/07/26/javascript_data_structure_03_queue/</id>
    <published>2018-07-26T12:36:00.000Z</published>
    <updated>2018-10-27T06:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20181027/queue.png?imageView2/1/w/1000/h/400" alt="stack"></p><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>前面我们学习了<a href="https://segmentfault.com/a/1190000015768412" target="_blank" rel="noopener">栈的实现</a>，队列和栈非常类似，但是使用了不同的原则，而非后进先出。</p><p><strong>队列</strong>是遵循FIFO（First In First Out，先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><p>在计算机科学中，一个最常见的例子就是<strong>打印队列</strong>。比如说我们要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。</p><a id="more"></a><h2 id="二、队列的实现"><a href="#二、队列的实现" class="headerlink" title="二、队列的实现"></a>二、队列的实现</h2><h3 id="2-1-普通队列"><a href="#2-1-普通队列" class="headerlink" title="2.1 普通队列"></a>2.1 普通队列</h3><p>创建普通队列类：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue类</span></span><br><span class="line">function Queue () &#123;</span><br><span class="line">  <span class="keyword">this</span>.items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.enqueue = enqueue;</span><br><span class="line">  <span class="keyword">this</span>.dequeue = dequeue;</span><br><span class="line">  <span class="keyword">this</span>.front = front;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = isEmpty;</span><br><span class="line">  <span class="keyword">this</span>.size = size;</span><br><span class="line">  <span class="keyword">this</span>.clear = clear;</span><br><span class="line">  <span class="keyword">this</span>.print = print;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>队列里面有一些声明的辅助方法：</p><ul><li>enqueue(element)：向队列尾部添加新项</li><li>dequeue()：移除队列的第一项（即排在队列最前面的项），并返回被移除的元素</li><li>front()：返回队列中第一个元素，队列不做任何变动，和Stack的peek()方法类似</li><li>isEmpty()：如果队列中不包含任何元素，返回true，否则返回false</li><li>size()：返回队列包含的元素个数，与数组的length属性类似</li><li>print()：打印队列中的元素</li><li>clear()：清空整个队列</li></ul><p>下面我们来一一实现这些辅助方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向队列尾部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.items.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除队列的第一个元素，并返回被移除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items.shift();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回队列的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">size</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.items = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列里的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建普通队列实例进行测试：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Queue实例</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">queue</span> = <span class="literal">new</span> <span class="built_in">Queue</span>();</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">queue</span>.isEmpty());     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">queue</span>.enqueue(<span class="string">"John"</span>);            <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">queue</span>.enqueue(<span class="string">"Jack"</span>);            <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">queue</span>.enqueue(<span class="string">"Camila"</span>);          <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">queue</span>.print();                    <span class="comment">// "John,Jack,Camila"</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">queue</span>.size());        <span class="comment">// 3</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">queue</span>.isEmpty());     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">queue</span>.dequeue();                  <span class="comment">// "John"</span></span><br><span class="line"><span class="built_in">queue</span>.dequeue();                  <span class="comment">// "Jack"</span></span><br><span class="line"><span class="built_in">queue</span>.print();                    <span class="comment">// "Camila"</span></span><br><span class="line"><span class="built_in">queue</span>.clear();                    <span class="comment">// undefined</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">queue</span>.size());        <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p><h3 id="2-2-优先队列"><a href="#2-2-优先队列" class="headerlink" title="2.2 优先队列"></a>2.2 优先队列</h3><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><p>普通队列的添加和移除只依赖于先后顺序，先来的先添加，后来的后添加，然后按照先后顺序依次从队列移除。</p><p>但是，还有一种队列叫<strong>优先队列</strong>，元素的添加和移除是依赖优先级的。</p><p>一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。再比如火车，老年人、孕妇和带小孩的乘客是享有优先检票权的。</p><h3 id="2-2-2-分类"><a href="#2-2-2-分类" class="headerlink" title="2.2.2 分类"></a>2.2.2 分类</h3><p><strong>优先队列</strong>分为两类：</p><ol><li><strong>最小优先队列</strong></li><li><strong>最大优先队列</strong></li></ol><p><strong>最小优先队列</strong>是把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。比如有四个元素：”John”, “Jack”, “Camila”, “Tom”，他们的优先级值分别为4，3，2，1。</p><p>那么<strong>最小优先队列排序</strong>应该为：<strong>“Tom”，”Camila”，”Jack”，”John”</strong>。</p><p><strong>最大优先队列</strong>正好相反，把优先级值最大的元素放置在队列的最前面，以上面的为例，最大优先队列排序应该为：<strong>“John”, “Jack”, “Camila”, “Tom”</strong>。</p><h3 id="2-2-2-实现"><a href="#2-2-2-实现" class="headerlink" title="2.2.2 实现"></a>2.2.2 实现</h3><p>实现一个优先队列，有两种选项：</p><ol><li>设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</li><li>设置优先级，和普通队列一样正常按顺序添加，然后根据优先级移除</li></ol><p>这里最小优先队列和最大优先队列我都采用第一种方式实现，大家可以尝试一下第二种。</p><p>所以我只重写enqueue()方法和print()方法，其他方法和上面的普通队列完全相同。完整代码见<a href="https://github.com/leocoder351/data-structure" target="_blank" rel="noopener">我的github</a>。</p><p><strong>实现最小优先队列</strong>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义最小优先队列</span></span><br><span class="line">function MinPriorityQueue () &#123;</span><br><span class="line">  <span class="keyword">this</span>.items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.enqueue = enqueue;</span><br><span class="line">  <span class="keyword">this</span>.dequeue = dequeue;</span><br><span class="line">  <span class="keyword">this</span>.front = front;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = isEmpty;</span><br><span class="line">  <span class="keyword">this</span>.size = size;</span><br><span class="line">  <span class="keyword">this</span>.clear = clear;</span><br><span class="line">  <span class="keyword">this</span>.print = print;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实现最小优先队列enqueue()方法和print()方法</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先队列添加元素，要根据优先级判断在队列中的插入顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queueElement = &#123;</span><br><span class="line">    element: element,</span><br><span class="line">    priority: priority</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(queueElement);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> added = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (queueElement.priority &lt; <span class="keyword">this</span>.items[i].priority) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, queueElement);</span><br><span class="line">        added = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">      <span class="keyword">this</span>.items.push(queueElement);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列里的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> strArr = [];</span><br><span class="line"></span><br><span class="line">  strArr = <span class="keyword">this</span>.items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item.element&#125;</span>-&gt;<span class="subst">$&#123;item.priority&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(strArr.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最小优先队列测试：<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建最小优先队列minPriorityQueue实例</span></span><br><span class="line"><span class="keyword">var</span> minPriorityQueue = <span class="function"><span class="keyword">new</span> <span class="title">MinPriorityQueue</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(minPriorityQueue.isEmpty());     <span class="comment">// true</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">John</span>", <span class="number">1</span>);         <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">Jack</span>", <span class="number">3</span>);         <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">Camila</span>", <span class="number">2</span>);       <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">Tom</span>", <span class="number">3</span>);          <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">print</span>();                    <span class="comment">// "John-&gt;1,Camila-&gt;2,Jack-&gt;3,Tom-&gt;3"</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(minPriorityQueue.size());        <span class="comment">// 4</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(minPriorityQueue.isEmpty());     <span class="comment">// false</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">dequeue</span>();                  <span class="comment">// &#123;element: "John", priority: 1&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">dequeue</span>();                  <span class="comment">// &#123;element: "Camila", priority: 2&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">print</span>();                    <span class="comment">// "Jack-&gt;3,Tom-&gt;3"</span></span></span><br><span class="line"><span class="function"><span class="title">minPriorityQueue</span>.<span class="title">clear</span>();                    <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(minPriorityQueue.size());        <span class="comment">// 0</span></span></span><br></pre></td></tr></table></figure></p><p><strong>实现最大优先队列</strong><br><br>最大优先队列只要将优先级的判断改为大于号”&gt;”就可以了：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大优先队列MaxPriorityQueue类</span></span><br><span class="line">function MaxPriorityQueue () &#123;</span><br><span class="line">  <span class="keyword">this</span>.items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.enqueue = enqueue;</span><br><span class="line">  <span class="keyword">this</span>.dequeue = dequeue;</span><br><span class="line">  <span class="keyword">this</span>.front = front;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = isEmpty;</span><br><span class="line">  <span class="keyword">this</span>.size = size;</span><br><span class="line">  <span class="keyword">this</span>.clear = clear;</span><br><span class="line">  <span class="keyword">this</span>.print = print;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列添加元素，要根据优先级判断在队列中的插入顺序</span></span><br><span class="line">function enqueue (element, priority) &#123;</span><br><span class="line">  <span class="keyword">var</span> queueElement = &#123;</span><br><span class="line">    element: element,</span><br><span class="line">    priority: priority</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(queueElement);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> added = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.items.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 注意，只需要将这里改为大于号就可以了</span></span><br><span class="line">      <span class="keyword">if</span> (queueElement.priority &gt; <span class="keyword">this</span>.items[i].priority) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, queueElement);</span><br><span class="line">        added = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">      <span class="keyword">this</span>.items.push(queueElement);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最大优先队列测试：<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建最大优先队列maxPriorityQueue实例</span></span><br><span class="line"><span class="keyword">var</span> maxPriorityQueue = <span class="function"><span class="keyword">new</span> <span class="title">MaxPriorityQueue</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(maxPriorityQueue.isEmpty());     <span class="comment">// true</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">John</span>", <span class="number">1</span>);         <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">Jack</span>", <span class="number">3</span>);         <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">Camila</span>", <span class="number">2</span>);       <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">enqueue</span>("<span class="type">Tom</span>", <span class="number">3</span>);          <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">print</span>();                    <span class="comment">// "Jack-&gt;3,Tom-&gt;3,Camila-&gt;2,John-&gt;1"</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(maxPriorityQueue.size());        <span class="comment">// 4</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(maxPriorityQueue.isEmpty());     <span class="comment">// false</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">dequeue</span>();                  <span class="comment">// &#123;element: "Jack", priority: 3&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">dequeue</span>();                  <span class="comment">// &#123;element: "Tom", priority: 3&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">print</span>();                    <span class="comment">// "Camila-&gt;2,John-&gt;1"</span></span></span><br><span class="line"><span class="function"><span class="title">maxPriorityQueue</span>.<span class="title">clear</span>();                    <span class="comment">// undefined</span></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(maxPriorityQueue.size());        <span class="comment">// 0</span></span></span><br></pre></td></tr></table></figure></p><h2 id="2-3-循环队列"><a href="#2-3-循环队列" class="headerlink" title="2.3 循环队列"></a>2.3 循环队列</h2><p>还有一种队列实现叫做<strong>循环队列</strong>。</p><p>循环队列的一个例子就是<strong>击鼓传花游戏（Hot Potato）</strong>。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。</p><p>下面我们在普通队列的基础上，实现一个模拟的击鼓传花游戏：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现击鼓传花</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span> (<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">    queue.enqueue(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环num次，队首出来去到队尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.enqueue(queue.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环num次过后，移除当前队首的元素</span></span><br><span class="line">    eliminated = queue.dequeue();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;eliminated&#125;</span>在击鼓传花中被淘汰！`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后只剩一个元素</span></span><br><span class="line">  <span class="keyword">return</span> queue.dequeue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> nameList = [<span class="string">"John"</span>, <span class="string">"Jack"</span>, <span class="string">"Camila"</span>, <span class="string">"Ingrid"</span>, <span class="string">"Carl"</span>];</span><br><span class="line"><span class="keyword">var</span> winner = hotPotato(nameList, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`最后的胜利者是：<span class="subst">$&#123;winner&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></p><p>执行结果为：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// John在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// Ingrid在击鼓传花中被淘汰！ </span></span><br><span class="line"><span class="comment">// Jack在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// Camila在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// 最后的胜利者是：Carl</span></span><br></pre></td></tr></table></figure></p><h2 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h2><p>本文会同步到我的<a href="https://blog.liuxuan.site" target="_blank" rel="noopener">个人博客</a>，完整代码可以到我的<a href="https://github.com/leocoder351/data-structure" target="_blank" rel="noopener">github仓库查看</a>，如果对你有帮助的话欢迎点一个Star~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20181027/queue.png?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;p&gt;前面我们学习了&lt;a href=&quot;https://segmentfault.com/a/1190000015768412&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;栈的实现&lt;/a&gt;，队列和栈非常类似，但是使用了不同的原则，而非后进先出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列&lt;/strong&gt;是遵循FIFO（First In First Out，先进先出）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。&lt;/p&gt;
&lt;p&gt;在计算机科学中，一个最常见的例子就是&lt;strong&gt;打印队列&lt;/strong&gt;。比如说我们要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="数据结构" scheme="//blog.liuxuan.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="//blog.liuxuan.site/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="//blog.liuxuan.site/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构02 - 栈</title>
    <link href="//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/"/>
    <id>//blog.liuxuan.site/2018/07/25/javascript_data_structure_02_stack/</id>
    <published>2018-07-25T14:36:00.000Z</published>
    <updated>2018-07-25T15:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180725/stack.jpg?imageView2/1/w/1000/h/400" alt="stack"></p><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>通过前面一节<a href="https://blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/" target="_blank" rel="noopener">《JavaScript数据结构01 - 数组》</a>我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。</p><p>有两种数据结构类似于数组，但在添加和删除元素时更为可控。</p><p>它们就是<strong>栈和队列</strong>。</p><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h3><p><strong>栈</strong>是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作<strong>栈顶</strong>，另一端就叫<strong>栈底</strong>。</p><p>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><p>栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。</p><a id="more"></a><h2 id="二、栈的实现"><a href="#二、栈的实现" class="headerlink" title="二、栈的实现"></a>二、栈的实现</h2><h3 id="2-1-创建一个类来表示栈"><a href="#2-1-创建一个类来表示栈" class="headerlink" title="2.1 创建一个类来表示栈"></a>2.1 创建一个类来表示栈</h3><p>这里我还是用构造函数的形式来书写，大家有兴趣可以用ES6的Class来重写一遍。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stack类</span></span><br><span class="line">function Stack () &#123;</span><br><span class="line">  <span class="keyword">this</span>.items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.push = push;</span><br><span class="line">  <span class="keyword">this</span>.pop = pop;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">peek</span> = <span class="built_in">peek</span>;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = isEmpty;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">clear</span> = <span class="built_in">clear</span>;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">  <span class="keyword">this</span>.<span class="built_in">print</span> = <span class="built_in">print</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈里面有一些声明的方法：</p><ul><li>push(element)：添加一个（或几个）新元素到栈顶</li><li>pop()：移除栈顶的元素，同时返回被移除的元素</li><li>peek()：返回栈顶的元素，不对栈做任何修改</li><li>isEmpty()：如果栈里没有任何元素就返回true，否则返回false</li><li>clear()：移除栈里的所有元素</li><li>size()：返回栈里的元素个数</li></ul><h3 id="2-2-实现栈中的辅助方法"><a href="#2-2-实现栈中的辅助方法" class="headerlink" title="2.2 实现栈中的辅助方法"></a>2.2 实现栈中的辅助方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新元素到栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.items.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除栈顶元素，同时返回被移除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空栈</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.items = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">size</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印栈里的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-创建实例进行测试"><a href="#2-3-创建实例进行测试" class="headerlink" title="2.3 创建实例进行测试"></a>2.3 创建实例进行测试</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Stack实例</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">stack</span> = new <span class="keyword">Stack</span>();</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.isEmpty());     <span class="comment">// true</span></span><br><span class="line"><span class="keyword">stack</span>.push(5);                    <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">stack</span>.push(8);                    <span class="comment">// undefined</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.peek());        <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">stack</span>.push(11);                   <span class="comment">// undefined</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.size());        <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.isEmpty());     <span class="comment">// false</span></span><br><span class="line"><span class="keyword">stack</span>.push(15);                   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">stack</span>.pop();                      <span class="comment">// 15</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.size());        <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">stack</span>.<span class="keyword">print</span>();                    <span class="comment">// 5,8,11</span></span><br><span class="line"><span class="keyword">stack</span>.<span class="keyword">clear</span>();                    <span class="comment">// undefined</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.size());        <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h2><p>本文会同步到我的<a href="https://blog.liuxuan.site" target="_blank" rel="noopener">个人博客</a>，完整代码可以到我的<a href="https://github.com/leocoder351/data-structure" target="_blank" rel="noopener">github仓库查看</a>，如果对你有帮助的话欢迎点一个Star~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180725/stack.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;h3 id=&quot;1-1-背景&quot;&gt;&lt;a href=&quot;#1-1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.1 背景&quot;&gt;&lt;/a&gt;1.1 背景&lt;/h3&gt;&lt;p&gt;通过前面一节&lt;a href=&quot;https://blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《JavaScript数据结构01 - 数组》&lt;/a&gt;我们知道，可以在数组的任意位置上删除或添加元素。然而，有时候我们还需要一种在添加或删除元素时有更多控制的数据结构。&lt;/p&gt;
&lt;p&gt;有两种数据结构类似于数组，但在添加和删除元素时更为可控。&lt;/p&gt;
&lt;p&gt;它们就是&lt;strong&gt;栈和队列&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-2-概念&quot;&gt;&lt;a href=&quot;#1-2-概念&quot; class=&quot;headerlink&quot; title=&quot;1.2 概念&quot;&gt;&lt;/a&gt;1.2 概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;是一种遵循后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作&lt;strong&gt;栈顶&lt;/strong&gt;，另一端就叫&lt;strong&gt;栈底&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在栈里，新元素都靠近栈顶，旧元素都接近栈底。&lt;/p&gt;
&lt;p&gt;栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="数据结构" scheme="//blog.liuxuan.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="//blog.liuxuan.site/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="//blog.liuxuan.site/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构01 - 数组</title>
    <link href="//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/"/>
    <id>//blog.liuxuan.site/2018/07/25/javascript_data_structure_01_array/</id>
    <published>2018-07-25T08:36:00.000Z</published>
    <updated>2018-07-25T15:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180725/array.jpg?imageView2/1/w/1000/h/400" alt="array"></p><h2 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h2><h4 id="1-1-使用Array构造函数"><a href="#1-1-使用Array构造函数" class="headerlink" title="1.1 使用Array构造函数"></a>1.1 使用Array构造函数</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="type">Array</span>(); <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="type">Array</span>(<span class="number">10</span>);   <span class="comment">// 创建一个包含20项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="type">Array</span>(<span class="string">'liu'</span>, <span class="string">'wang'</span>, <span class="string">'li'</span>);  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure><h4 id="1-2-使用数组字面量表示法"><a href="#1-2-使用数组字面量表示法" class="headerlink" title="1.2 使用数组字面量表示法"></a>1.2 使用数组字面量表示法</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [];  <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">10</span>];    <span class="comment">// 创建一个包含1项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">'liu'</span>, <span class="string">'wang'</span>, <span class="string">'li'</span>];   <span class="comment">// 创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、常用数组方法"><a href="#二、常用数组方法" class="headerlink" title="二、常用数组方法"></a>二、常用数组方法</h2><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>join</td><td>把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔</td></tr><tr><td>pop</td><td>删除并返回数组的最后一个元素</td></tr><tr><td>push</td><td>向数组的末尾添加一个或更多元素，并返回新的长度</td></tr><tr><td>shift</td><td>删除并返回数组的第一个元素</td></tr><tr><td>unshift</td><td>向数组的开头添加一个或更多元素，并返回新的长度</td></tr><tr><td>slice</td><td>从某个已有的数组返回指定的元素</td></tr><tr><td>indexOf</td><td>返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</td></tr><tr><td>lastIndexOf</td><td>返回在数组中搜索到的与给定参数相等的元素的索引里的最大的值，没有找到则返回-1</td></tr><tr><td>sort</td><td>对数组的元素进行排序</td></tr><tr><td>splice</td><td>删除元素，并向数组添加新元素</td></tr><tr><td>toString</td><td>把数组转换为字符串，并返回结果</td></tr><tr><td>toLocaleString</td><td>把数组转换为本地字符串，并返回结果</td></tr><tr><td>valueOf</td><td>返回数组对象的原始值</td></tr><tr><td>forEach</td><td>对数组中的每一项运行指定函数，这个方法没有返回值</td></tr><tr><td>concat</td><td>连接2个或更多数组，并返回结果</td></tr><tr><td>every</td><td>对数组中的每一项运行指定函数，如果该函数对每一项都返回true，则返回true</td></tr><tr><td>some</td><td>对数组中的每一项运行指定函数，如果任一项返回true，则返回true</td></tr><tr><td>filter</td><td>对数组中的每一项运行指定函数，返回该函数会返回true的项组成的数组</td></tr><tr><td>reverse</td><td>颠倒数组中元素的顺序</td></tr><tr><td>map</td><td>对数组中的每一项运行指定函数，返回每次函数调用的结果组成的数组</td></tr><tr><td>reduce</td><td>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值</td></tr><tr><td>reduceRight</td><td>接收一个函数作为累加器，数组中的每个值（从右到左）开始缩减，最终计算为一个值</td></tr></tbody></table><p><strong>PS：原始值是指固定而简单的值，存放在栈中的简单数据段，它们的值直接存储在变量访问的位置。</strong></p><p>JavaScript中有五种原始类型，也叫基本类型： <br><br><strong>Number、String、Boolean、Undefined、Null</strong></p><h2 id="三、演示实例"><a href="#三、演示实例" class="headerlink" title="三、演示实例"></a>三、演示实例</h2><h4 id="3-1-join"><a href="#3-1-join" class="headerlink" title="3.1 join"></a>3.1 join</h4><p><strong>定义和用法</strong> <br></p><p>join()方法用于把数组中的所有元素放入一个字符串。<br><br>元素是通过指定的分隔符进行分隔的。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.join(separator)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>seperator</td><td>可选。指定要使用的分隔符，如果省略该参数，则使用逗号作为分隔符</td></tr></tbody></table><p><strong>返回值</strong> <br></p><p>返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = arr.join();</span><br><span class="line"><span class="keyword">var</span> str2 = arr.join(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">var</span> str3 = arr.join(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">var</span> str4 = arr.join(<span class="string">'-'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1);  <span class="comment">// "Geroge,John,Thomas"</span></span><br><span class="line"><span class="built_in">console</span>.log(str2);  <span class="comment">// "GerogeJohnThomas"</span></span><br><span class="line"><span class="built_in">console</span>.log(str3);  <span class="comment">// "Geroge John Thomas"</span></span><br><span class="line"><span class="built_in">console</span>.log(str4);  <span class="comment">// "Geroge-John-Thomas"</span></span><br></pre></td></tr></table></figure><h4 id="3-2-pop"><a href="#3-2-pop" class="headerlink" title="3.2 pop"></a>3.2 pop</h4><p><strong>定义和用法</strong> <br></p><p>pop()方法用于删除并返回数组的最后一个元素。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.pop()</p></blockquote><p><strong>返回值</strong> <br></p><p>arrayObject 的最后一个元素。<br></p><p><strong>说明</strong> <br></p><p>pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr = <span class="built_in">new</span> Array(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(arr);           // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">pop</span>());     // <span class="string">"Thomas"</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);           // [<span class="string">"Geroge"</span>, <span class="string">"Thomas"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-3-push"><a href="#3-3-push" class="headerlink" title="3.3 push"></a>3.3 push</h4><p><strong>定义和用法</strong> <br></p><p>push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.push(newElement1, newElement2, …, newElementX)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>newElement1</td><td>必需。要添加到数组末尾的第一个元素</td></tr><tr><td>newElement2</td><td>可选。要添加到数组末尾的第二个元素</td></tr><tr><td>newElementX</td><td>可选。可添加多个元素</td></tr></tbody></table><p><strong>返回值</strong> <br></p><p>把指定的值添加到数组后的新长度。<br></p><p><strong>说明</strong> <br></p><p>push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr = <span class="built_in">new</span> Array(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(arr);                           // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">push</span>(<span class="string">"James"</span>));             // <span class="number">4</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);                           // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">push</span>(<span class="string">"Peter"</span>, <span class="string">"Sara"</span>));     // <span class="number">6</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);                           // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Peter"</span>, <span class="string">"Sara"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-4-shift"><a href="#3-4-shift" class="headerlink" title="3.4 shift"></a>3.4 shift</h4><p><strong>定义和用法</strong> <br></p><p>shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.shift()</p></blockquote><p><strong>返回值</strong> <br></p><p>数组原来的第一个元素的值。<br></p><p><strong>说明</strong> <br></p><p>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr = <span class="built_in">new</span> Array(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(arr);           // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.shift());   // <span class="string">"Geroge"</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);           // [<span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-5-unshift"><a href="#3-5-unshift" class="headerlink" title="3.5 unshift"></a>3.5 unshift</h4><p><strong>定义和用法</strong> <br></p><p>unshift()方法可向数组的开头添加一个或多个元素，并返回新的长度。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.unshift(newElement1, newElement2, …, newElementX)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>newElement1</td><td>必需。要添加到数组开头的第一个元素</td></tr><tr><td>newElement2</td><td>可选。要添加到数组开头的第二个元素</td></tr><tr><td>newElementX</td><td>可选。可添加多个元素</td></tr></tbody></table><p><strong>返回值</strong> <br></p><p>arrayObject 的新长度。<br></p><p><strong>说明</strong> <br></p><p>unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。</p><p>请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr = <span class="built_in">new</span> Array(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(arr);                               // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.unshift(<span class="string">"James"</span>));              // <span class="number">4</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);                               // [<span class="string">"James"</span>, <span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.unshift(<span class="string">"Peter"</span>, <span class="string">"Sara"</span>));      // <span class="number">6</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);                               // [<span class="string">"Peter"</span>, <span class="string">"Sara"</span>, <span class="string">"James"</span>, <span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-6-slice"><a href="#3-6-slice" class="headerlink" title="3.6 slice"></a>3.6 slice</h4><p><strong>定义和用法</strong> <br></p><p>slice()方法可从已有的数组中返回选定的元素。slice()方法不改变原数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.slice(start, end)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>必需。规定从何处开始选取。<br>如果是负数，那么它规定从数组尾部开始算起的位置。<br>也就是说，-1指最后一个元素，-2指倒数第二个元素，以此类推。</td></tr><tr><td>end</td><td>可选。规定从何处结束选取。<br>该参数是数组片断结束处的数组下标。<br>如果没有指定该参数，那么切分的数组包含从start到数组结束的所有元素。<br>如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td></tr></tbody></table><p><strong>返回值</strong> <br></p><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。<br></p><p><strong>说明</strong> <br></p><p>请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr = new <span class="symbol">Array</span>(<span class="number">6</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span>;</span><br><span class="line"></span><br><span class="line">console.log(arr);                   // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]</span><br><span class="line">console.log(arr.slice(<span class="number">0</span>));          // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]</span><br><span class="line">console.log(arr.slice(<span class="number">1</span>));          // [<span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]</span><br><span class="line">console.log(arr.slice(<span class="number">1</span>, <span class="number">3</span>));       // [<span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.log(arr.slice(<span class="number">1</span>, <span class="number">-2</span>));      // [<span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>]</span><br><span class="line">console.log(arr.slice(<span class="number">-1</span>, <span class="number">-2</span>));     // []</span><br><span class="line">console.log(arr.slice(<span class="number">-2</span>, <span class="number">-1</span>));     // [<span class="string">"Adrew"</span>]</span><br><span class="line">console.log(arr);                   // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-7-indexOf"><a href="#3-7-indexOf" class="headerlink" title="3.7 indexOf"></a>3.7 indexOf</h4><p><strong>定义和用法</strong> <br></p><p>indexOf()方法可返回某个指定的值在数组中首次出现的位置。从左往右找，找不到返回-1。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.indexOf(searchValue, fromIndex)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>searchValue</td><td>必需。规定需检索的值。</td></tr><tr><td>fromIndex</td><td>可选的整数参数，开始查找的位置。<br>如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。<br>如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，<br>即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 <br>注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，<br>查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，<br>则整个数组都将会被查询。其默认值为0</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'Thomas'</span>));             <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'Thomas'</span>, <span class="number">2</span>));          <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'Thomas'</span>, <span class="number">3</span>));          <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'Thomas'</span>, <span class="number">-4</span>));         <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'Thomas'</span>, <span class="number">-3</span>));         <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'Peter'</span>));              <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h4 id="3-8-lastIndexOf"><a href="#3-8-lastIndexOf" class="headerlink" title="3.8 lastIndexOf"></a>3.8 lastIndexOf</h4><p><strong>定义和用法</strong> <br></p><p>lastIndexOf()方法可返回某个指定的值在数组中首次出现的位置。从右往左找，找不到返回-1。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.indexOf(searchValue, fromIndex)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>searchValue</td><td>必需。规定需检索的值。</td></tr><tr><td>fromIndex</td><td>可选的整数参数，从此位置开始逆向查找。<br>默认为数组的长度减 1，即整个数组都被查找。<br>如果该值大于或等于数组的长度，则整个数组会被查找。<br>如果为负值，将其视为从数组末尾向前的偏移。<br>即使该值为负，数组仍然会被从后向前查找。<br>如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Thomas'</span>));             <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Thomas'</span>, <span class="number">2</span>));          <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Thomas'</span>, <span class="number">3</span>));          <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Thomas'</span>, <span class="number">1</span>));          <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Thomas'</span>, <span class="number">-4</span>));         <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Thomas'</span>, <span class="number">-3</span>));         <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'Peter'</span>));              <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h4 id="3-9-sort"><a href="#3-9-sort" class="headerlink" title="3.9 sort"></a>3.9 sort</h4><p><strong>定义和用法</strong> <br></p><p>sort()方法用于对数组的元素进行排序。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.sort(sortby)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>sortby</td><td>可选。规定排序顺序。必须是函数。</td></tr></tbody></table><p><strong>返回值</strong> <br></p><p>对数组的引用。请注意，数组在原数组上进行排序，不生成副本。<br></p><p><strong>说明</strong> <br></p><p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说的更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以方便比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b，其返回值如下：</p><ul><li>若a小于b，在排序后的数组中a应该出现在b之前，则返回一个小于0的值。</li><li>若a等于b，则返回0。</li><li>若a大于b，则返回一个大于0的值。</li></ul><p>即顺序 return a - b; 倒序 return b - a;</p><p>a在b前返回负数，a在b后返回正数</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = new <span class="symbol">Array</span>(<span class="number">6</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"10"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span>;</span><br><span class="line"></span><br><span class="line">console.log(arr);           // [<span class="string">"10"</span>, <span class="string">"5"</span>, <span class="string">"40"</span>, <span class="string">"25"</span>, <span class="string">"1000"</span>, <span class="string">"1"</span>]</span><br><span class="line">console.log(arr.sort());    // [<span class="string">"1"</span>, <span class="string">"10"</span>, <span class="string">"1000"</span>, <span class="string">"25"</span>, <span class="string">"40"</span>, <span class="string">"5"</span>]</span><br><span class="line">console.log(arr);           // [<span class="string">"1"</span>, <span class="string">"10"</span>, <span class="string">"1000"</span>, <span class="string">"25"</span>, <span class="string">"40"</span>, <span class="string">"5"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(<span class="number">6</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"10"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"5"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"40"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"25"</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"1000"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderNumber</span> <span class="params">(a, b)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">descOrderNumber</span> <span class="params">(a, b)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(arr);                           // [<span class="string">"10"</span>, <span class="string">"5"</span>, <span class="string">"40"</span>, <span class="string">"25"</span>, <span class="string">"1000"</span>, <span class="string">"1"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">sort</span>(orderNumber));         // [<span class="string">"1"</span>, <span class="string">"5"</span>, <span class="string">"10"</span>, <span class="string">"25"</span>, <span class="string">"40"</span>, <span class="string">"1000"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">sort</span>(descOrderNumber));     // [<span class="string">"1000"</span>, <span class="string">"40"</span>, <span class="string">"25"</span>, <span class="string">"10"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr);                           // [<span class="string">"1000"</span>, <span class="string">"40"</span>, <span class="string">"25"</span>, <span class="string">"10"</span>, <span class="string">"5"</span>, <span class="string">"1"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-10-splice"><a href="#3-10-splice" class="headerlink" title="3.10 splice"></a>3.10 splice</h4><p><strong>定义和用法</strong> <br></p><p>splice()方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.splice(index, howmany, item1, ……, itemX)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</td></tr><tr><td>howmany</td><td>必需。要删除的项目数量。如果设置为0，则不会删除项目。</td></tr><tr><td>item1,……,itemX</td><td>可选。向数组添加的新项目。</td></tr></tbody></table><p><strong>返回值</strong> <br></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Array</td><td>包含被删除项目的新数组，如果有的话。</td></tr></tbody></table><p><strong>说明</strong> <br></p><p>splice()方法可删除从index处开始的0个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从arrayObject中删除了元素，则返回的是含有被删除的元素的数组。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = new <span class="symbol">Array</span>(<span class="number">6</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"James"</span>;</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">"Adrew"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"Martin"</span>;</span><br><span class="line"></span><br><span class="line">console.log(arr);                                   // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]  </span><br><span class="line">console.log(arr.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'Peter'</span>, <span class="string">'Sara'</span>));     // [<span class="string">"John"</span>]</span><br><span class="line">console.log(arr);                                   // [<span class="string">"Geroge"</span>, <span class="string">"Peter"</span>, <span class="string">"Sara"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]</span><br><span class="line">console.log(arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'Ella'</span>));              // []</span><br><span class="line">console.log(arr);                                   // [<span class="string">"Geroge"</span>, <span class="string">"Ella"</span>, <span class="string">"Peter"</span>, <span class="string">"Sara"</span>, <span class="string">"Thomas"</span>, <span class="string">"James"</span>, <span class="string">"Adrew"</span>, <span class="string">"Martin"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-11-toString"><a href="#3-11-toString" class="headerlink" title="3.11 toString"></a>3.11 toString</h4><p><strong>定义和用法</strong> <br></p><p>toString()方法可把数组转换为字符串，并返回结果。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.toString()</p></blockquote><p><strong>返回值</strong> <br></p><p>arrayObject的字符串表示。返回值与没有参数的join()方法返回的字符串相同。</p><p><strong>说明</strong> <br></p><p>当数组用于字符串环境时，JavaScript会调用这一方法将数组自动转换成字符串。但是在某些情况下，需要显式地调用该方法。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(<span class="number">4</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">console.log(arr.toString());    <span class="comment">// "Geroge,John,Thomas,20"</span></span><br></pre></td></tr></table></figure><h4 id="3-12-toLocaleString"><a href="#3-12-toLocaleString" class="headerlink" title="3.12 toLocaleString"></a>3.12 toLocaleString</h4><p><strong>定义和用法</strong> <br></p><p>toLocaleString()方法可把数组转换为本地字符串，并返回结果。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.toLocaleString()</p></blockquote><p><strong>返回值</strong> <br></p><p>arrayObject的本地字符串表示。</p><p><strong>说明</strong> <br></p><p>首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(<span class="number">4</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">console.log(arr.toLocaleString());    <span class="comment">// "Geroge,John,Thomas,20"</span></span><br></pre></td></tr></table></figure><h4 id="3-13-valueOf"><a href="#3-13-valueOf" class="headerlink" title="3.13 valueOf"></a>3.13 valueOf</h4><p><strong>定义和用法</strong> <br></p><p>valueOf()方法返回Array对象的原始值。该原始值由Array对象派生的所有对象继承。valueOf(）方法通常由JavaScript在后台自动调用，并不显式地出现在代码中。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.valueOf()</p></blockquote><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = new <span class="symbol">Array</span>(<span class="number">4</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">console.log(arr.valueOf());    // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure><h4 id="3-14-forEach"><a href="#3-14-forEach" class="headerlink" title="3.14 forEach"></a>3.14 forEach</h4><p><strong>定义和用法</strong> <br></p><p>forEach()方法用于调用数组的每个元素，并将元素传递给回调函数。forEach()对于空数组是不会执行回调函数的。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.forEach(function (value, index, arr) {}, thisValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function(currentValue, index, arr)</td><td>必需。数组中每个元素需要调用的函数。<br>currentValue: 必需。当前元素。<br>index: 可选。当前元素的索引值。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>thisValue</td><td>可选。传递给函数的值一般用’this’值。<br>如果这个参数为空，严格模式下把’undefined’会传递给’this’值，普通模式下传入’window’。</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"Geroge"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(value, index, arr)</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(value);     // <span class="string">"Geroge"</span> <span class="string">"John"</span> <span class="string">"Thomas"</span></span><br><span class="line">    console.<span class="built_in">log</span>(index);     // <span class="number">0</span>        <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">    console.<span class="built_in">log</span>(arr);       // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">    console.<span class="built_in">log</span>(this);      // window</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(value, index, arr)</span></span> &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(value);     // <span class="string">"Geroge"</span> <span class="string">"John"</span> <span class="string">"Thomas"</span></span><br><span class="line">    console.<span class="built_in">log</span>(index);     // <span class="number">0</span>        <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">    console.<span class="built_in">log</span>(arr);       // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">    console.<span class="built_in">log</span>(this);      // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">&#125;, arr);</span><br></pre></td></tr></table></figure><h4 id="3-15-concat"><a href="#3-15-concat" class="headerlink" title="3.15 concat"></a>3.15 concat</h4><p><strong>定义和用法</strong> <br></p><p>concat()方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.concat(arrayX,arrayX,……,arrayX)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>arrayX</td><td>必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。</td></tr></tbody></table><p><strong>返回值</strong> <br></p><p>返回一个新的数组。该数组是通过把所有arrayX参数添加到arrayObject中生成的。如果要进行concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">console.log(a.concat(<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>));  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="3-16-every"><a href="#3-16-every" class="headerlink" title="3.16 every"></a>3.16 every</h4><p><strong>定义和用法</strong> <br></p><p>every()方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。<br>every()方法使用指定函数检测数组中的所有元素：</p><ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回false，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回true。</li></ul><p>注意：every()不会对空数组进行检测。<br>注意：every()不会改变原始数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.every(function (currentValue, index, arr) {}, thisValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function (currentValue, index, arr)</td><td>必需。函数，数组中的每个元素都会执行这个函数。<br>currentValue: 必需。当前元素。<br>index: 可选。当前元素的索引值。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>thisValue</td><td>可选。对象作为该执行回调时使用，传递给函数。<br></td></tr></tbody></table><p><strong>说明</strong> <br></p><p>有一个返回false，则整个every()返回值为false，并且不会执行后续其他项的回调函数。<br>空数组的every()直接返回true。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">result</span> = ages.every(<span class="function"><span class="keyword">function</span> <span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return value &gt; 25;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">result</span>);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ages = [];</span><br><span class="line"><span class="keyword">result</span> = ages.every(<span class="function"><span class="keyword">function</span> <span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return value &gt; 25;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">result</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="3-17-some"><a href="#3-17-some" class="headerlink" title="3.17 some"></a>3.17 some</h4><p><strong>定义和用法</strong> <br></p><p>some()方法用于检测数组所有元素是否满足指定条件（通过函数提供）。<br>every()方法会依次执行数组的每个元素：</p><ul><li>如果有一个元素满足条件，则表达式返回true，剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回false。</li></ul><p>注意：some()不会对空数组进行检测。<br>注意：some()不会改变原始数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.some(function (currentValue, index, arr) {}, thisValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function (currentValue, index, arr)</td><td>必需。函数，数组中的每个元素都会执行这个函数。<br>currentValue: 必需。当前元素。<br>index: 可选。当前元素的索引值。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>thisValue</td><td>可选。对象作为该执行回调时使用，传递给函数。<br></td></tr></tbody></table><p><strong>说明</strong> <br></p><p>有一个返回true，则整个some()返回值为true，并且不会执行后续其他项的回调函数。<br>空数组的some()直接返回false。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">result</span> = ages.some(<span class="function"><span class="keyword">function</span> <span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return value &gt; 25;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">result</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">ages = [];</span><br><span class="line"><span class="keyword">result</span> = ages.some(<span class="function"><span class="keyword">function</span> <span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return value &gt; 25;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">result</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-18-filter"><a href="#3-18-filter" class="headerlink" title="3.18 filter"></a>3.18 filter</h4><p><strong>定义和用法</strong> <br></p><p>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><p>注意：filter()不会对空数组进行检测。<br>注意：filter()不会改变原始数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.filter(function (currentValue, index, arr) {}, thisValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function (currentValue, index, arr)</td><td>必需。函数，数组中的每个元素都会执行这个函数。<br>currentValue: 必需。当前元素。<br>index: 可选。当前元素的索引值。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>thisValue</td><td>可选。对象作为该执行回调时使用，传递给函数。<br></td></tr></tbody></table><p><strong>说明</strong> <br></p><p>将所有返回true的数组项取出来组成一个新的数组。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">result</span> = ages.filter(<span class="function"><span class="keyword">function</span> <span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return value &gt; 25;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">result</span>);    <span class="comment">// [32, 40]</span></span><br><span class="line">console.log(ages);      <span class="comment">// [10, 20, 24, 32, 40]</span></span><br><span class="line"></span><br><span class="line">ages = [];</span><br><span class="line"><span class="keyword">result</span> = ages.filter(<span class="function"><span class="keyword">function</span> <span class="params">(value, <span class="keyword">index</span>, arr)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return value &gt; 25;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">result</span>);    <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="3-19-reverse"><a href="#3-19-reverse" class="headerlink" title="3.19 reverse"></a>3.19 reverse</h4><p><strong>定义和用法</strong> <br></p><p>reverse()方法用于颠倒数组中元素的顺序。会改变原数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.reverse()</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr = <span class="built_in">new</span> Array(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(arr);               // [<span class="string">"Geroge"</span>, <span class="string">"John"</span>, <span class="string">"Thomas"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="built_in">reverse</span>());     // [<span class="string">"Thomas"</span>, <span class="string">"John"</span>, <span class="string">"Geroge"</span>]</span><br><span class="line">console.<span class="built_in">log</span>(arr);               // [<span class="string">"Thomas"</span>, <span class="string">"John"</span>, <span class="string">"Geroge"</span>]</span><br></pre></td></tr></table></figure><h4 id="3-20-map"><a href="#3-20-map" class="headerlink" title="3.20 map"></a>3.20 map</h4><p><strong>定义和用法</strong> <br></p><p>map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map()方法按照原始数组元素顺序依次处理元素。</p><p>注意：map()不会对空数组进行检测。<br>注意：map()不会改变原始数组。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.map(function (currentValue, index, arr) {}, thisValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function (currentValue, index, arr)</td><td>必需。函数，数组中的每个元素都会执行这个函数。<br>currentValue: 必需。当前元素。<br>index: 可选。当前元素的索引值。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>thisValue</td><td>可选。对象作为该执行回调时使用，传递给函数。<br></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">65</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = numbers.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers);   <span class="comment">// [65, 20, 11, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);       <span class="comment">// [130, 40, 22, 10]</span></span><br></pre></td></tr></table></figure><h4 id="3-21-reduce"><a href="#3-21-reduce" class="headerlink" title="3.21 reduce"></a>3.21 reduce</h4><p><strong>定义和用法</strong> <br></p><p>reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p>注意：reduce()对于空数组是不会执行回调函数的。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.reduce(function (total, currentValue, currentIndex, arr) {}, initialValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function (total, currentValue, currentIndex, arr)</td><td>必需。函数，数组中的每个元素都会执行这个函数。<br>total: 必需。初始值，或者计算结束后的返回值。<br>currentValue: 必需。当前元素。<br>currentIndex: 可选。当前元素的索引。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>initialValue</td><td>可选。传递给函数的初始值。<br></td></tr></tbody></table><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [15, 2, 1, 7];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">total</span> = numbers.reduce(function (<span class="keyword">total</span>, currentValue) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">total</span>);             <span class="comment">// 15 17 18 25</span></span><br><span class="line">    console.<span class="built_in">log</span>(currentValue);      <span class="comment">// 2  1  7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">total</span> + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">total</span>);                 <span class="comment">// 25</span></span><br><span class="line">console.<span class="built_in">log</span>(numbers);               <span class="comment">// [15, 2, 1, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">total</span> = numbers.reduce(function (<span class="keyword">total</span>, currentValue) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">total</span>);             <span class="comment">// 20 35 37 38 45</span></span><br><span class="line">    console.<span class="built_in">log</span>(currentValue);      <span class="comment">// 15 2  1  7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">total</span> + currentValue;</span><br><span class="line">&#125;, 20);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">total</span>);                 <span class="comment">// 45</span></span><br><span class="line">console.<span class="built_in">log</span>(numbers);               <span class="comment">// [15, 2, 1, 7]</span></span><br></pre></td></tr></table></figure><h4 id="3-22-reduceRight"><a href="#3-22-reduceRight" class="headerlink" title="3.22 reduceRight"></a>3.22 reduceRight</h4><p><strong>定义和用法</strong> <br></p><p>reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</p><p>注意：reduceRight()对于空数组是不会执行回调函数的。</p><p><strong>语法</strong> <br></p><blockquote><p>arrayObject.reduceRight(function (total, currentValue, currentIndex, arr) {}, initialValue)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function (total, currentValue, currentIndex, arr)</td><td>必需。函数，数组中的每个元素都会执行这个函数。<br>total: 必需。初始值，或者计算结束后的返回值。<br>currentValue: 必需。当前元素。<br>currentIndex: 可选。当前元素的索引。<br>arr: 可选。当前元素所属的数组对象。</td></tr><tr><td>initialValue</td><td>可选。传递给函数的初始值。<br></td></tr></tbody></table><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [15, 2, 1, 7];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">total</span> = numbers.reduceRight(function (<span class="keyword">total</span>, currentValue) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">total</span>);             <span class="comment">// 7 8 10 25</span></span><br><span class="line">    console.<span class="built_in">log</span>(currentValue);      <span class="comment">// 1 2 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">total</span> + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">total</span>);                 <span class="comment">// 25</span></span><br><span class="line">console.<span class="built_in">log</span>(numbers);               <span class="comment">// [15, 2, 1, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">total</span> = numbers.reduceRight(function (<span class="keyword">total</span>, currentValue) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">total</span>);             <span class="comment">// 20 27 28 30 45</span></span><br><span class="line">    console.<span class="built_in">log</span>(currentValue);      <span class="comment">// 7  1  2  15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">total</span> + currentValue;</span><br><span class="line">&#125;, 20);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">total</span>);                 <span class="comment">// 45</span></span><br><span class="line">console.<span class="built_in">log</span>(numbers);               <span class="comment">// [15, 2, 1, 7]</span></span><br></pre></td></tr></table></figure><h2 id="三、结束"><a href="#三、结束" class="headerlink" title="三、结束"></a>三、结束</h2><p>本文会同步到我的<a href="https://blog.liuxuan.site" target="_blank" rel="noopener">个人博客</a>，完整代码可以到我的<a href="https://github.com/leocoder351/data-structure" target="_blank" rel="noopener">github仓库查看</a>，如果对你有帮助的话欢迎点一个Star~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180725/array.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;array&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、创建数组&quot;&gt;&lt;a href=&quot;#一、创建数组&quot; class=&quot;headerlink&quot; title=&quot;一、创建数组&quot;&gt;&lt;/a&gt;一、创建数组&lt;/h2&gt;&lt;h4 id=&quot;1-1-使用Array构造函数&quot;&gt;&lt;a href=&quot;#1-1-使用Array构造函数&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用Array构造函数&quot;&gt;&lt;/a&gt;1.1 使用Array构造函数&lt;/h4&gt;&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;// 创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;// 创建一个包含20项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;liu&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;wang&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;li&#39;&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// 创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;1-2-使用数组字面量表示法&quot;&gt;&lt;a href=&quot;#1-2-使用数组字面量表示法&quot; class=&quot;headerlink&quot; title=&quot;1.2 使用数组字面量表示法&quot;&gt;&lt;/a&gt;1.2 使用数组字面量表示法&lt;/h4&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr1 = [];  &lt;span class=&quot;comment&quot;&gt;// 创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr2 = [&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];    &lt;span class=&quot;comment&quot;&gt;// 创建一个包含1项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr3 = [&lt;span class=&quot;string&quot;&gt;&#39;liu&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;wang&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;li&#39;&lt;/span&gt;];   &lt;span class=&quot;comment&quot;&gt;// 创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="数据结构" scheme="//blog.liuxuan.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="//blog.liuxuan.site/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="//blog.liuxuan.site/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/"/>
    <id>//blog.liuxuan.site/2018/07/20/javascript_asynchronous_programming/</id>
    <published>2018-07-20T12:36:00.000Z</published>
    <updated>2018-07-25T15:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180720/async_logo.jpeg?imageView2/1/w/1000/h/400" alt="JavaScript异步编程"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从我们一开始学习JavaScript的时候就听到过一段话：<strong>JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型</strong>。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。</p><p>但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。</p><p>本文也会同步到我的<a href="http://blog.liuxuan.site" target="_blank" rel="noopener">个人网站</a>。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Step1-回调函数"><a href="#Step1-回调函数" class="headerlink" title="Step1 - 回调函数"></a>Step1 - 回调函数</h2><p>回调函数大家肯定都不陌生，从我们写一段最简单的定时器开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time out'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>定时器里面的匿名函数就是一个回调函数，因为在JS中函数是一等公民，所以它可以像其他变量一样作为参数进行传递。这样看来，通过回调函数来处理异步挺好的，写着也顺手，为什么要用别的方法呢？</p><p>我们来看这样一个需求：</p><p><img src="http://image.liuxuan.site/blog/20180720/wxlogin.png" alt="http-1"></p><p>上面是微信小程序的登录时序图，我们的需求和它类似但又有些差别，想要获取一段业务数据，整个过程分为3步：</p><ol><li>调用秘钥接口，获取key</li><li>携带key调用登录接口，获取token和userId</li><li>携带token和userId调用业务接口，获取数据</li></ol><p>可能上述步骤和实际业务中的有些出入，但是却可以用来说明问题，请大家谅解。</p><p><strong>我们写一段代码来实现上述需求：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">let key, token, userId;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">    url: <span class="string">'http://localhost:3000/apiKey'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;</span><br><span class="line">        key = data;</span><br><span class="line">        </span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/getToken'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                key: key</span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;</span><br><span class="line">                token = data.token;</span><br><span class="line">                userId = data.userId;</span><br><span class="line">                </span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">                    url: <span class="string">'http://localhost:3000/getData'</span>,</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        token: token,</span><br><span class="line">                        userId: userId</span><br><span class="line">                    &#125;,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;</span><br><span class="line">                        console.<span class="built_in">log</span>(<span class="string">'业务数据：'</span>, data);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">                        console.<span class="built_in">log</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，整段代码充满了回调嵌套，代码不仅在纵向扩展，横向也在扩展。我相信，对于任何人来说，调试起来都会很困难，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以查看流程，而最终的结果藏在整段代码的中间位置。真实的JavaScript程序代码可能要混乱的多，使得这种追踪难度会成倍增加。这就是我们常说的<strong>回调地狱（Callback Hell）</strong>。</p><p>为什么会出现这种现象？</p><p><strong>如果某个业务，依赖于上层业务的数据，上层业务又依赖于更上一层的数据，我们还采用回调的方式来处理异步的话，就会出现回调地狱</strong>。</p><p>大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码的难度很大，很容易产生Bug。</p><p>这里我们引出了回调函数解决异步的<strong>第1个问题：回调地狱</strong>。</p><p>回调函数还会存在别的问题吗？<br>让我们再深入思考一下回调的概念：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> <span class="params">(<span class="rest_arg">...) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="rest_arg">        // C</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure></p><p>A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。</p><p>但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。</p><p>这种情况称为<strong>控制反转</strong>，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。</p><p>既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：</p><ol><li>调用回调过早</li><li>调用回调过晚</li><li>调用回调次数太多或者太少</li><li>未能把所需的参数成功传给你的回调函数</li><li>吞掉可能出现的错误或异常</li><li>……</li></ol><p>这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。</p><p>这里，我们引出了回调函数处理异步的<strong>第二个问题：控制反转</strong>。</p><p>综上，回调函数处理异步流程存在2个问题：</p><p><strong>1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</strong><br><strong>2. 缺乏可信任性： 控制反转导致的一系列信任问题</strong></p><p>那么如何来解决这两个问题，先驱者们开始了探索之路……</p><h2 id="Step2-Promise"><a href="#Step2-Promise" class="headerlink" title="Step2 - Promise"></a>Step2 - Promise</h2><p><strong>开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转</strong>。</p><p>至于Promise是什么，大家肯定都有所了解，这里是<a href="https://promisesaplus.com/" target="_blank" rel="noopener">PromiseA+规范</a>，ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，<strong>它是一种规范，是一套处理JavaScript异步的机制</strong>。</p><p>我们把上面那个多层回调嵌套的例子用Promise的方式重构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> getKeyPromise = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/apiKey'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">let</span> key = data;</span><br><span class="line">               resolve(key);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getTokenPromise = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/getToken'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                key: key</span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getDataPromise = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> token = data.token;</span><br><span class="line">    <span class="keyword">let</span> userId = data.userId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/getData'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                token: token,</span><br><span class="line">                userId: userId</span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getKeyPromise()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTokenPromise(key);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDataPromise(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'业务数据：'</span>, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，Promise在一定程度上其实改善了回调函数的书写方式，最明显的一点就是去除了横向扩展，无论有再多的业务依赖，通过多个then(…)来获取数据，让代码只在纵向进行扩展；另外一点就是逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。</p><p>所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。</p><p>这里我想主要讨论的是，<strong>Promise是如何解决控制反转带来的信任缺失问题。</strong></p><p>首先明确一点，Promise可以保证以下情况，引用自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">JavaScript | MDN</a>：</p><blockquote><ol><li>在JavaScript事件队列的当前运行完成之前，回调函数永远不会被调用</li><li>通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用</li><li>通过多次调用 .then，可以添加多个回调函数，它们会按照插入顺序并且独立运行 </li></ol></blockquote><p>下面我们针对前面提过的回调函数处理异步导致的一系列信任问题来讨论，如果是用Promise来处理，是否还会存在这些问题，当然前提是实现的Promise完全遵循<strong><a href="https://promisesaplus.com/" target="_blank" rel="noopener">PromiseA+规范</a></strong>。</p><h3 id="调用过早"><a href="#调用过早" class="headerlink" title="调用过早"></a>调用过早</h3><p>当使用回调函数的时候，我们无法保证或者不知道第三方对于回调函数的调用是何种形式的，如果它在某种情况下是立即完成以同步的方式来调用，那可能就会导致我们代码中的逻辑错误。</p><p>但是，根据<a href="https://promisesaplus.com/" target="_blank" rel="noopener">PromiseA+规范</a>，Promise就不必担心这种问题，因为即使是立即完成的Promise（类似于new Promise(function (resolve, reject) {resolve(2);})），也无法被同步观察到。</p><p>也就是说，对一个Promise调用then(…)的时候，即使这个Promise已经决议，提供给then(…)的回调也总会在JavaScript事件队列的当前运行完成后，再被调用，即异步调用。</p><h3 id="调用过晚"><a href="#调用过晚" class="headerlink" title="调用过晚"></a>调用过晚</h3><p>当Promise创建对象调用resolve(…)或reject(…)时，这个Promise通过then(…)注册的回调函数就会在下一个异步时间点上被触发。</p><p>并且，这个Promise上的多个通过then(…)注册的回调都会在下一个异步时间点上被依次调用，这些回调中的任意一个都无法影响或延误对其他回调的调用。</p><p>举例如下：<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    p.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">'C'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'A'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(funtion () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'B'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 A B C</span></span><br></pre></td></tr></table></figure></p><p>通过这个例子可以看到，C无法打断或抢占B，所以Promise没有调用过晚的现象，只要你注册了then(…)，就肯定会按顺序依次调用，因为这就是Promise的运作方式。</p><h3 id="回调未调用"><a href="#回调未调用" class="headerlink" title="回调未调用"></a>回调未调用</h3><p>没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议（如果它决议了的话）。如果你对一个Promise注册了一个成功回调和拒绝回调，那么Promise在决议的时候总会调用其中一个。</p><p>当然，如果你的回调函数本身包含JavaScript错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>(data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    foo.bar();       // 这里没有定义foo，所以这里会报<span class="keyword">Type</span> <span class="type">Error, </span>foo <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&#125;, <span class="keyword">function</span> <span class="title"></span>(err) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="调用次数太多或者太少"><a href="#调用次数太多或者太少" class="headerlink" title="调用次数太多或者太少"></a>调用次数太多或者太少</h3><p>根据<a href="https://promisesaplus.com/" target="_blank" rel="noopener">PromiseA+规范</a>，回调被调用的正确次数应该是1次。“太少”就是不调用，前面已经解释过了。</p><p>“太多”的情况很容易解释，Promise的定义方式使得它只能被决议一次。如果处于多种原因，Promise创建代码试图调用多次resolve(…)或reject(…)，或者试图两者都调用，那么这个Promise将只会接受第一次决议，并默默忽略任何后续调用。</p><p>由于Promise只能被决议一次，所以任何通过then(…)注册的回调就只会被调用一次。</p><h3 id="未能传递参数值"><a href="#未能传递参数值" class="headerlink" title="未能传递参数值"></a>未能传递参数值</h3><p>如果你没有把任何值传递给resolve(…)或reject(…)，那么这个值就是<strong>undefined</strong>。但不管这个值是什么，它都会被传给所有注册在then(…)中的回调函数。</p><p>如果使用多个参数调用resolve(…)或reject(…)，那么第一个参数之后的所有参数都会被忽略。如果要传递多个值，你就必须把它们封装在单个值中进行传递，比如一个数组或对象。</p><h3 id="吞掉可能出现的错误或异常"><a href="#吞掉可能出现的错误或异常" class="headerlink" title="吞掉可能出现的错误或异常"></a>吞掉可能出现的错误或异常</h3><p>如果在Promise的创建过程中或在查看其决议结果的过程中的任何时间点上，出现了一个JavaScript异常错误，比如一个TypeError或ReferenceError，这个异常都会被捕捉，并且会使这个Promise被拒绝。</p><p>举例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    foo.bar();    <span class="comment">// foo未定义</span></span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);    <span class="comment">// 永远也不会到达这里</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);    <span class="comment">// err将会是一个TypeError异常对象来自foo.bar()这一行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>foo.bar()中发生的JavaScript异常导致了Promise的拒绝，你可以捕捉并对其作出响应。</p><h3 id="不是所有的thenable都可以信任"><a href="#不是所有的thenable都可以信任" class="headerlink" title="不是所有的thenable都可以信任"></a>不是所有的thenable都可以信任</h3><p>到目前为止，我们讨论了使用Promise可以避免上述多种由控制反转导致的信任问题。但是，你肯定也注意到了，Promise并没有完全摆脱回调，它只是改变了传递回调的位置。我们并不是把回调传递给foo(…)让第三方去执行，而是从foo(…)得到某个东西（Promise对象），然后把回调传递给这个东西。</p><p>但是，为什么这就比单纯使用回调更值得信任呢？如何能够确定返回的这个东西实际上就是一个可信任的Promise呢？</p><p>Promise对于这个问题已经有了解决方案，ES6实现的Promise的解决方案就是<strong>Promise.resolve(…)</strong>。</p><p>如果向Promise.resolve(…)传递一个非Promise，非thenable得立即值，就会得到一个用这个值填充的Promise。</p><p>举例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里p1和p2的效果是一样的</span></span><br></pre></td></tr></table></figure></p><p>而如果向Promise.resolve(…)传递一个真正的Promise，就只会返回同一个Promise。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(p1);</span><br><span class="line"></span><br><span class="line">p1 === p2;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>更重要的是，如果向Promise.resolve(…)传递了一个非Promise的thenable值，前者就会试图展开这个值，而且展开过程中会持续到提取出一个具体的非类Promise的最终值。</p><p>举例如下：<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var p = &#123;</span><br><span class="line">    <span class="keyword">then</span>: <span class="function"><span class="keyword">function</span> <span class="params">(cb, errCb)</span> &#123;</span></span><br><span class="line">        cb(<span class="number">2</span>);</span><br><span class="line">        errCb(<span class="string">'haha'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这可以工作，因为函数是一等公民，可以当做参数进行传递</span></span><br><span class="line">p.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(data);    <span class="comment">// 2</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(err);    <span class="comment">// haha</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个p是一个thenable，但不是一个真正的Promise，其行为和Promise并不完全一致，它同时触发了成功回调和拒绝回调，它是不可信任的。</p><p>尽管如此，我们还是都可以把这样的p传给Promise.resolve(…)，然后就会得到期望中的规范化后的安全结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(p)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);    <span class="comment">// 2</span></span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);    <span class="comment">// 永远不会到达这里</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>因为前面讨论过，一个Promise只接受一次决议，如果多次调用resolve(…)或reject(…)，后面的会被自动忽略。</p><p>Promise.resolve(…)可以接受任何thenable，将其解封为它的非thenable值。从Promise.resolve(…)得到的是一个真正的Promise，是一个可以信任的值。如果你传入的已经是真正的Promise，那么你得到的就是它本身，所以通过Promise.resolve(…)过滤来获得可信任性完全没有坏处。</p><p><strong>综上，我们明确了，使用Promise处理异步可以解决回调函数控制反转带来的一系列信任问题</strong>。<br><strong>很好，我们又向前迈了一步</strong>。</p><h2 id="Step3-生成器Gererator"><a href="#Step3-生成器Gererator" class="headerlink" title="Step3 - 生成器Gererator"></a>Step3 - 生成器Gererator</h2><p>在Step1中，我们确定了用回调表达异步流程的两个关键问题：</p><ol><li>基于回调的异步不符合大脑对任务步骤的规范方式</li><li>由于控制反转，回调并不是可信任的</li></ol><p>在Step2中，我们详细介绍了Promise是如何把回调的控制反转又反转过来，恢复了可信任性。</p><p>现在，我们把注意力转移到一种顺序、看似同步的异步流程控制表达风格，这就是<strong>ES6中的生成器（Gererator）</strong>。</p><h3 id="可迭代协议和迭代器协议"><a href="#可迭代协议和迭代器协议" class="headerlink" title="可迭代协议和迭代器协议"></a>可迭代协议和迭代器协议</h3><p>了解Generator之前，必须先了解ES6新增的两个协议：<strong>可迭代协议</strong>和<strong>迭代器协议</strong>。</p><h4 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h4><p><strong>可迭代协议</strong>运行JavaScript对象去定义或定制它们的迭代行为，例如（定义）在一个for…of结构中什么值可以被循环（得到）。以下内置类型都是内置的可迭代对象并且有默认的迭代行为：</p><ol><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的Arguments对象</li><li>NodeList对象</li></ol><p><strong>注意，Object不符合可迭代协议</strong>。</p><p>为了变成可迭代对象，一个对象必须实现@@iterator方法，意思是这个对象（或者它原型链prototype chain上的某个对象）必须有一个名字是Symbol.iterator的属性：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>[Symbol.iterator]</td><td>返回一个对象的无参函数，被返回对象符合迭代器协议</td></tr></tbody></table><p>当一个对象需要被迭代的时候（比如开始用于一个for…of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。</p><h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4><p><strong>迭代器协议</strong>定义了一种标准的方式来产生一个有限或无限序列的值。<br>当一个对象被认为是一个迭代器时，它实现了一个next()的方法并且拥有以下含义：<br>| 属性 | 值 |<br>|——|—|<br>| next | 返回一个对象的无参函数，被返回对象拥有两个属性：<br> <strong>1. done（boolean）</strong><br> - 如果迭代器已经经过了被迭代序列时为true。这时value可能描述了该迭代器的返回值 <br> - 如果迭代器可以产生序列中的下一个值，则为false。这等效于连同done属性也不指定。 <br> <strong>2. value</strong> - 迭代器返回的任何JavaScript值。done为true时可以忽略。 |</p><p>使用可迭代协议和迭代器协议的例子：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 可迭代协议使用<span class="keyword">for</span>...of访问</span><br><span class="line">typeof str[Symbol.iterator];    <span class="regexp">//</span> <span class="string">'function'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var s of str) &#123;</span><br><span class="line">    console.log(s);    <span class="regexp">//</span> 分别打印 <span class="string">'h'</span>、<span class="string">'e'</span>、<span class="string">'l'</span>、<span class="string">'l'</span>、<span class="string">'o'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 迭代器协议<span class="keyword">next</span>方法</span><br><span class="line">var iterator = str[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.<span class="keyword">next</span>();    <span class="regexp">//</span> &#123;value: <span class="string">"h"</span>, done: false&#125;</span><br><span class="line">iterator.<span class="keyword">next</span>();    <span class="regexp">//</span> &#123;value: <span class="string">"e"</span>, done: false&#125;</span><br><span class="line">iterator.<span class="keyword">next</span>();    <span class="regexp">//</span> &#123;value: <span class="string">"l"</span>, done: false&#125;</span><br><span class="line">iterator.<span class="keyword">next</span>();    <span class="regexp">//</span> &#123;value: <span class="string">"l"</span>, done: false&#125;</span><br><span class="line">iterator.<span class="keyword">next</span>();    <span class="regexp">//</span> &#123;value: <span class="string">"o"</span>, done: false&#125;</span><br><span class="line">iterator.<span class="keyword">next</span>();    <span class="regexp">//</span> &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></p><p>我们自己实现一个对象，让其符合<strong>可迭代协议</strong>和<strong>迭代器协议</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> something = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextVal;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 可迭代协议，供for...of消费</span></span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代器协议，实现next()方法</span></span><br><span class="line">        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextVal === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                nextVal = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextVal = (<span class="number">3</span> * nextVal) + <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: nextVal, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">something.next().value;    <span class="comment">// 1</span></span><br><span class="line">something.next().value;    <span class="comment">// 9</span></span><br><span class="line">something.next().value;    <span class="comment">// 33</span></span><br><span class="line">something.next().value;    <span class="comment">// 105</span></span><br></pre></td></tr></table></figure></p><h3 id="用Generator实现异步"><a href="#用Generator实现异步" class="headerlink" title="用Generator实现异步"></a>用Generator实现异步</h3><p>如果我们用Generator改写上面回调嵌套的例子会是什么样的呢？见代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">        url: <span class="string">'http://localhost:3000/apiKey'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;</span><br><span class="line">            key = data;</span><br><span class="line">            it.<span class="built_in">next</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getToken</span> <span class="params">(key)</span></span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">        url: <span class="string">'http://localhost:3000/getToken'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            key: key</span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span></span> &#123;</span><br><span class="line">            loginData = data;</span><br><span class="line">            it.<span class="built_in">next</span>(loginData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> <span class="params">(loginData)</span></span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">        url: <span class="string">'http://localhost:3000/getData'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            token: loginData.token,</span><br><span class="line">            userId: loginData.userId</span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> <span class="params">(busiData)</span></span> &#123;</span><br><span class="line">            it.<span class="built_in">next</span>(busiData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    let key = <span class="built_in">yield</span> getKey();</span><br><span class="line">    let LoginData = <span class="built_in">yield</span> getToken(key);</span><br><span class="line">    let busiData = <span class="built_in">yield</span> getData(loginData);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'业务数据：'</span>, busiData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成迭代器实例</span><br><span class="line">var it = main();</span><br><span class="line"></span><br><span class="line">// 运行第一步</span><br><span class="line">it.<span class="built_in">next</span>();</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'不影响主线程执行'</span>);</span><br></pre></td></tr></table></figure></p><p>我们注意*main()生成器内部的代码，不看yield关键字的话，是完全符合大脑思维习惯的同步书写形式，把异步的流程封装到外面，在成功的回调函数里面调用it.next()，将传回的数据放到任务队列里进行排队，当JavaScript主线程空闲的时候会从任务队列里依次取出回调任务执行。</p><p>如果我们一直占用JavaScript主线程的话，是没有时间去执行任务队列中的任务：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 运行第一步</span><br><span class="line">it.<span class="keyword">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 持续占用JavaScript主线程</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;;    <span class="regexp">//</span> 这里是拿不到异步数据的，因为没有机会去任务队列里取任务执行</span><br></pre></td></tr></table></figure></p><p>综上，生成器Generator解决了回调函数处理异步流程的<strong>第一个问题：不符合大脑顺序、线性的思维方式。</strong>。</p><h2 id="Step4-Async-Await"><a href="#Step4-Async-Await" class="headerlink" title="Step4 - Async/Await"></a>Step4 - Async/Await</h2><p>上面我们介绍了Promise和Generator，把这两者结合起来，就是Async/Await。</p><p>Generator的缺点是还需要我们手动控制next()执行，使用Async/Await的时候，只要await后面跟着一个Promise，它会自动等到Promise决议以后的返回值，resolve(…)或者reject(…)都可以。</p><p>我们把最开始的例子用Async/Await的方式改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getKeyPromise = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/apiKey'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">let</span> key = data;</span><br><span class="line">               resolve(key);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getTokenPromise = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/getToken'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                key: key</span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getDataPromise = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> token = data.token;</span><br><span class="line">    <span class="keyword">let</span> userId = data.userId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:3000/getData'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                token: token,</span><br><span class="line">                userId: userId</span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">await</span> getKeyPromise();</span><br><span class="line">    <span class="keyword">let</span> loginData = <span class="keyword">await</span> getTokenPromise(key);</span><br><span class="line">    <span class="keyword">let</span> busiData = <span class="keyword">await</span> getDataPromise(loginData);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'业务数据：'</span>, busiData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'不影响主线程执行'</span>);</span><br></pre></td></tr></table></figure><p>可以看到，使用Async/Await，完全就是同步的书写方式，逻辑和数据依赖都非常清楚，只需要把异步的东西用Promise封装出去，然后使用await调用就可以了，也不需要像Generator一样需要手动控制next()执行。</p><p><strong>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步流程存在的两个问题，可能是现在最好的JavaScript处理异步的方式了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过四个阶段来讲述JavaScript异步编程的发展历程：</p><ol><li><strong>第一个阶段 - 回调函数</strong>，但会导致两个问题:<ul><li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li><li>缺乏可信任性： 控制反转导致的一系列信任问题 </li></ul></li><li><strong>第二个阶段 - Promise</strong>，Promise是基于PromiseA+规范的实现，它很好的解决了控制反转导致的信任问题，将代码执行的主动权重新拿了回来。</li><li><strong>第三个阶段 - 生成器函数Generator</strong>，使用Generator，可以让我们用同步的方式来书写代码，解决了顺序性的问题，但是需要手动去控制next(…)，将回调成功返回的数据送回JavaScript主流程中。</li><li><strong>第四个阶段 - Async/Await</strong>，Async/Await结合了Promise和Generator，在await后面跟一个Promise，它会自动等待Promise的决议值，解决了Generator需要手动控制next(…)执行的问题，真正实现了<strong>用同步的方式书写异步代码</strong>。</li></ol><p>我们可以看到，每项技术的突破都是为了解决现有技术存在的一些问题，它是循序渐进的，我们在学习的过程中，要真正去理解这项技术解决了哪些痛点，它为什么会存在，这样会有益于我们构建体系化的知识，同时也会更好的去理解这门技术。</p><p><strong>最后，希望大家可以通过这篇文章对JavaScript异步编程有一个更宏观的体系化的了解，我们一起进步</strong>。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180720/async_logo.jpeg?imageView2/1/w/1000/h/400&quot; alt=&quot;JavaScript异步编程&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从我们一开始学习JavaScript的时候就听到过一段话：&lt;strong&gt;JS是单线程的，天生异步，适合IO密集型，不适合CPU密集型&lt;/strong&gt;。但是，多数JavaScript开发者从来没有认真思考过自己程序中的异步到底是怎么出现的，以及为什么会出现，也没有探索过处理异步的其他方法。到目前为止，还有很多人坚持认为回调函数就完全够用了。&lt;/p&gt;
&lt;p&gt;但是，随着JavaScript面临的需求越来越多，它可以运行在浏览器、服务器、甚至是嵌入式设备上，为了满足这些需求，JavaScript的规模和复杂性也在持续增长，使用回调函数来管理异步也越来越让人痛苦，这一切，都需要更强大、更合理的异步方法，通过这篇文章，我想对目前已有JavaScript异步的处理方式做一个总结，同时试着去解释为什么会出现这些技术，让大家对JavaScript异步编程有一个更宏观的理解，让知识变得更体系化一些。&lt;/p&gt;
&lt;p&gt;本文也会同步到我的&lt;a href=&quot;http://blog.liuxuan.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人网站&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="异步编程" scheme="//blog.liuxuan.site/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="异步编程" scheme="//blog.liuxuan.site/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Promise" scheme="//blog.liuxuan.site/tags/Promise/"/>
    
      <category term="Generator" scheme="//blog.liuxuan.site/tags/Generator/"/>
    
      <category term="Async/Await" scheme="//blog.liuxuan.site/tags/Async-Await/"/>
    
  </entry>
  
  <entry>
    <title>看图学HTTPS</title>
    <link href="//blog.liuxuan.site/2018/05/21/learn_https_through_photos/"/>
    <id>//blog.liuxuan.site/2018/05/21/learn_https_through_photos/</id>
    <published>2018-05-21T13:36:00.000Z</published>
    <updated>2018-05-21T13:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180521/https-logo.jpg?imageView2/1/w/1000/h/400" alt="https"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。</p><p>我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。</p><p>本文也会同步到我的<a href="http://blog.liuxuan.site" target="_blank" rel="noopener">个人网站</a>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="HTTP是什么样的？"><a href="#HTTP是什么样的？" class="headerlink" title="HTTP是什么样的？"></a>HTTP是什么样的？</h2><p>HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-1.png" alt="http-1"></p><p>客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。</p><a id="more"></a><h2 id="加个密呢？"><a href="#加个密呢？" class="headerlink" title="加个密呢？"></a>加个密呢？</h2><p>因为上图中数据是明文传输的，我们能想到最简单的提高安全性的方法就是在传输前对数据进行加密，如下图：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-2.png" alt="http-2"></p><p>这种加密方式叫做：<strong>对称加密</strong>。<br>加密和解密用同一个秘钥的加密方式叫做对称加密。</p><p>好了，我们对数据进行加密了，问题解决了吗？</p><h2 id="多个客户端怎么办？"><a href="#多个客户端怎么办？" class="headerlink" title="多个客户端怎么办？"></a>多个客户端怎么办？</h2><p>这是一个客户端，但是在WWW上，是成千上万的客户端，情况会怎样呢？</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-3.png" alt="http-3"></p><p>为所有的客户端都应用同一个秘钥A，这种方式很显然是不合理的，破解了一个用户，所有的用户信息都会被盗取。</p><p>想一想，是不是还有别的办法呢？</p><p>相信大家都可以想到，如果对每一个客户端都用不同的秘钥进行传输是不是就解决这个问题了：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-4.png" alt="http-4"></p><h2 id="对称加密秘钥如何传输？"><a href="#对称加密秘钥如何传输？" class="headerlink" title="对称加密秘钥如何传输？"></a>对称加密秘钥如何传输？</h2><p>我们对每个客户端应用不同的对称加密秘钥，那么这个秘钥客户端或者服务端是如何知道的呢，只能是在一端生成一个秘钥，然后通过HTTP传输给另一端：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-5.png" alt="http-5"></p><p>那么这个传输秘钥的过程，又如何保证加密？如果被中间人拦截，秘钥也会被获取。也许你会说，对秘钥再进行加密，那又如何保证对秘钥加密的过程，是加密的呢？</p><p>好像我们走入了 <strong>while(1)</strong>，出不来了。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>在对称加密的路上走不通了，我们换个思路，还有一种加密方式叫非对称加密，比如RSA。<br>非对称加密会有一对秘钥：<strong>公钥</strong>和<strong>私钥</strong>。<br>公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开（当然是指和秘钥是一对的公钥）。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-6.png" alt="http-6"></p><p>私钥只保存在服务器端，公钥可以发送给所有的客户端。</p><p>在传输公钥的过程中，肯定也会有被中间人获取的风险，但在目前的情况下，至少可以保证客户端通过公钥加密的内容，中间人是无法破解的，因为私钥只保存在服务器端，只有私钥可以破解公钥加密的内容。</p><p>现在我们还存在一个问题，如果公钥被中间人拿到篡改呢：</p><p><strong>MITM</strong>：Man-in-the-MiddleAttack</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-7.png" alt="http-7"></p><p>客户端拿到的公钥是假的，如何解决这个问题？</p><h2 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h2><p>公钥被掉包，是因为客户端无法分辨传回公钥的到底是中间人，还是服务器，这也是密码学中的身份验证问题。</p><p>在HTTPS中，使用 <strong>证书 + 数字签名</strong> 来解决这个问题。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-9.png" alt="http-9"></p><p>这里假设加密方式是MD5，将网站的信息加密后通过第三方机构的私钥再次进行加密，生成数字签名。</p><p><strong>数字证书 = 网站信息 + 数字签名</strong></p><p>假如中间人拦截后把服务器的公钥替换为自己的公钥，因为数字签名的存在，会导致客户端验证签名不匹配，这样就防止了中间人替换公钥的问题。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-10.png" alt="http-10"></p><p>浏览器安装后会内置一些权威第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等，验证签名的时候直接就从本地拿到相应第三方机构的公钥，对私钥加密后的数字签名进行解密得到真正的签名，然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</p><h2 id="为什么要有签名？"><a href="#为什么要有签名？" class="headerlink" title="为什么要有签名？"></a>为什么要有签名？</h2><p>大家可以想一下，为什么要有数字签名这个东西呢？</p><p>第三方认证机构是一个开放的平台，我们可以去申请，中间人也可以去申请呀：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-11.png" alt="http-11"></p><p>如果没有签名，只对网站信息进行第三方机构私钥加密的话，会存在下面的问题：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-12.png" alt="http-12"></p><p>因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>在安全的拿到服务器的公钥之后，客户端会随机生成一个对称秘钥，使用服务器公钥加密，传输给服务端，此后，相关的 <strong>Application Data</strong> 就通过这个随机生成的对称秘钥进行加密/解密，服务器也通过该对称秘钥进行解密/加密：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-13.png" alt="http-13"></p><h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><p>HTTPS = HTTP + TLS/SSL</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-15.png" alt="http-15"></p><p>HTTPS中具体的内容还有很多，可以通过下图做一个参考：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-14.gif" alt="http-14"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTTPS</a><br><a href="https://www.instantssl.com/https-tutorials/what-is-https.html" target="_blank" rel="noopener">https://www.instantssl.com/https-tutorials/what-is-https.html</a><br><a href="https://tasaid.com/blog/20161003001126.html" target="_blank" rel="noopener">https://tasaid.com/blog/20161003001126.html</a><br><a href="https://www.west.cn/faq/list.asp?unid=1346" target="_blank" rel="noopener">https://www.west.cn/faq/list.asp?unid=1346</a><br><a href="https://www.cnblogs.com/zhangshitong/p/6478721.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangshitong/p/6478721.html</a><br><a href="https://www.wired.com/2016/04/hacker-lexicon-what-is-https-encryption/" target="_blank" rel="noopener">https://www.wired.com/2016/04/hacker-lexicon-what-is-https-encryption/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180521/https-logo.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;https&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前说到HTTPS，在我的概念中就是更安全，需要服务器配置证书，但是到底什么是HTTPS，为什么会更安全，整套流程又是如何实现的，在脑子里没有具体的概念。所以，我花了几天的时间，通过参考一些文章，学习了HTTPS整套机制的实现，想要通过一篇文章把我学习到的东西总结出来，让更多之前不清楚HTTPS到底是什么的同学有一个入门的理解。&lt;/p&gt;
&lt;p&gt;我看过的很多文章都是通过大量的文字和协议图来解释，但往往会让人感觉有点枯燥，这篇文章我会通过一幅幅流程图，形象的说明从HTTP到HTTPS的演变过程，让大家可以更容易理解一些。当然，这个只是入门级，如果想要学习更深入的HTTPS的知识，还是要深入到一个个协议里面，看一些大部头，才可以达到完全理解的效果。&lt;/p&gt;
&lt;p&gt;本文也会同步到我的&lt;a href=&quot;http://blog.liuxuan.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人网站&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;h2 id=&quot;HTTP是什么样的？&quot;&gt;&lt;a href=&quot;#HTTP是什么样的？&quot; class=&quot;headerlink&quot; title=&quot;HTTP是什么样的？&quot;&gt;&lt;/a&gt;HTTP是什么样的？&lt;/h2&gt;&lt;p&gt;HTTP是属于应用层的协议，它是基于TCP/IP的，所以它只是规定一些要传输的内容，以及头部信息，然后通过TCP协议进行传输，依靠IP协议进行寻址，通过一幅最简单的图来描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p54fus2hp.bkt.clouddn.com/blog/20180521/https-1.png&quot; alt=&quot;http-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;客户端发出请求，服务端进行响应，就是这么简单。在整个过程中，没有任何加密的东西，所以它是不安全的，中间人可以进行拦截，获取传输和响应的数据，造成数据泄露。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="//blog.liuxuan.site/categories/HTTP/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="HTTPS" scheme="//blog.liuxuan.site/tags/HTTPS/"/>
    
      <category term="SSL/TLS" scheme="//blog.liuxuan.site/tags/SSL-TLS/"/>
    
      <category term="非对称加密" scheme="//blog.liuxuan.site/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="对称加密" scheme="//blog.liuxuan.site/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>聊聊V8引擎的垃圾回收</title>
    <link href="//blog.liuxuan.site/2018/04/14/v8_garbage_collection/"/>
    <id>//blog.liuxuan.site/2018/04/14/v8_garbage_collection/</id>
    <published>2018-04-14T08:36:00.000Z</published>
    <updated>2018-04-21T15:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180414/garbage_collection.jpeg?imageView2/1/w/1000/h/400" alt="label-statement"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。</p><p>在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~</p><p>希望这篇文章能帮到你，同时本文也会收录到我自己的<a href="http://blog.liuxuan.site" target="_blank" rel="noopener">个人网站</a>。</p><h3 id="为什么要有垃圾回收"><a href="#为什么要有垃圾回收" class="headerlink" title="为什么要有垃圾回收"></a>为什么要有垃圾回收</h3><p>在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过<strong>malloc</strong>函数去手动分配，在用完之后，还要时刻记得用<strong>free</strong>函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。</p><p>但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。</p><p>不需要我们去手动管理内存了，所以自然要有<strong>垃圾回收</strong>，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。</p><p>垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。</p><a id="more"></a><h3 id="内存结构分配"><a href="#内存结构分配" class="headerlink" title="内存结构分配"></a>内存结构分配</h3><p>由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在64位系统下大约为1.4GB，在32位系统下大约为700MB。</p><p>在NodeJS环境中，我们可以通过<strong>process.memoryUsage()</strong>来查看内存分配。</p><p><img src="http://image.liuxuan.site/blog/20180413/node_heap.png?imageView2/1/w/800" alt="node环境v8内存"></p><p><strong>process.memoryUsage</strong>返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，含义如下：</p><p><img src="http://image.liuxuan.site/blog/20180413/node_memory.png?imageView2/1/w/800" alt="node环境v8内存"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rss</span>（resident set size）：所有内存占用，包括指令区和堆栈</span><br><span class="line"></span><br><span class="line"><span class="symbol">heapTotal</span>：<span class="built_in">V8</span>引擎可以分配的最大堆内存，包含下面的 heapUsed</span><br><span class="line"></span><br><span class="line"><span class="symbol">heapUsed</span>：<span class="built_in">V8</span>引擎已经分配使用的堆内存</span><br><span class="line"></span><br><span class="line"><span class="symbol">external</span>： <span class="built_in">V8</span>管理C++对象绑定到JavaScript对象上的内存</span><br></pre></td></tr></table></figure><p>以上所有内存单位均为字节（Byte）。</p><p>如果说想要扩大Node可用的内存空间，可以使用<strong>Buffer</strong>等堆外内存内存，这里不详细说明了，大家有兴趣可以去看一些资料。</p><p>下面是Node的整体架构图，有助于大家理解上面的内容：</p><p><img src="http://image.liuxuan.site/blog/20180413/node_architecture.jpeg?imageView2/1/w/800" alt="node环境v8内存"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span> <span class="title">Standard</span> Library: 是我们每天都在用的标准库，如Http, Buffer 模块</span><br><span class="line"></span><br><span class="line"><span class="keyword">Node</span> Bindings:<span class="title"> 是沟通JS</span> 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务</span><br><span class="line"></span><br><span class="line">第三层是支撑 <span class="keyword">Node</span>.<span class="title">js</span> 运行的关键，由 C/C++ 实现：</span><br><span class="line"><span class="number">1</span>. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 <span class="keyword">Node</span>.<span class="title">js</span> 的发动机</span><br><span class="line"><span class="number">2</span>. Libuv 是专门为<span class="keyword">Node</span>.<span class="title">js</span>开发的一个封装库，提供跨平台的异步I/O能力</span><br><span class="line"><span class="number">3</span>. C-ares：提供了异步处理 DNS 相关的能力</span><br><span class="line"><span class="number">4</span>. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力</span><br></pre></td></tr></table></figure><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h4 id="1-如何判断是否可以回收"><a href="#1-如何判断是否可以回收" class="headerlink" title="1. 如何判断是否可以回收"></a>1. 如何判断是否可以回收</h4><h5 id="1-1-标记清除"><a href="#1-1-标记清除" class="headerlink" title="1.1 标记清除"></a>1.1 标记清除</h5><p>当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。如何标记变量并不重要，关键在于采取什么策略。</p><ul><li>（1）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</li><li>（2）然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记</li><li>（3）此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。</li><li>（4）最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li></ul><p>目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180413/gc_object.png?imageView2/1/w/800" alt="标记清除"></p><p><strong>活动对象</strong>就是上面的root，如果不清楚活动对象的可以先查一下资料，当一个对象和其关联对象不再通过引用关系被当前root引用了，这个对象就会被垃圾回收。</p><h5 id="1-2-引用计数"><a href="#1-2-引用计数" class="headerlink" title="1.2 引用计数"></a>1.2 引用计数</h5><p>引用计数的垃圾收集策略不太常见。含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。</p><p>如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。</p><p>当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><p>这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><p>Netscape Navigator 3.0是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：<strong>循环引用</strong>。</p><p>循环引用是指对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用，看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    </span><br><span class="line">    objA.otherObj = objB;</span><br><span class="line">    objB.anotherObj = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子中，objA和objB通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2。</p><p>在采用标记清除策略的实现中，由于函数执行后，这两个对象都离开了作用域，因此这种相互引用不是问题。</p><p>但在采用引用次数策略的实现中，当函数执行完毕后，objA和objB还将继续存在，因为它们的引用次数永远不会是0。</p><p>加入这个函数被重复多次调用，就会导致大量内存无法回收。为此，Netscape在Navigator 4.0中也放弃了引用计数方式，转而采用标记清除来实现其垃圾回收机制。</p><p>还要注意的是，我们大部分人时刻都在写着循环引用的代码，看下面这个例子，相信大家都这样写过：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'#el'</span>);</span><br><span class="line">el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'element was clicked'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们为一个元素的点击事件绑定了一个匿名函数，我们通过<strong>event</strong>参数是可以拿到相应元素<strong>el</strong>的信息的。</p><p>大家想想，这是不是就是一个循环引用呢？<br><strong>el</strong>有一个属性<strong>onclick</strong>引用了一个函数（其实也是个对象），函数里面的参数又引用了<strong>el</strong>，这样<strong>el</strong>的引用次数一直是2，即使当前这个页面关闭了，也无法进行垃圾回收。</p><p>如果这样的写法很多很多，就会造成内存泄露。我们可以通过在页面卸载时清除事件引用，这样就可以被回收了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'#el'</span>);</span><br><span class="line">el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'element was clicked'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面卸载时将绑定的事件清空</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    el.onclick = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h3><p>自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。</p><p>所以，V8采用了一种代回收的策略，将内存分为两个生代：<strong>新生代（new generation）</strong>和<strong>老生代（old generation）</strong>。</p><p>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升，后面我会详细说明。</p><h3 id="分代内存"><a href="#分代内存" class="headerlink" title="分代内存"></a>分代内存</h3><p>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</p><p>新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="1-分配方式"><a href="#1-分配方式" class="headerlink" title="1. 分配方式"></a>1. 分配方式</h4><p>新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。</p><h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h4><p>新生代采用<strong>Scavenge</strong>垃圾回收算法，在算法实现时主要采用<strong>Cheney</strong>算法。</p><p>Cheney算法将内存一分为二，叫做semispace，一块处于使用状态，一块处于闲置状态。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180413/new_old_generation.png?imageView2/1/w/800" alt="新老生代"></p><p>处于使用状态的semispace称为<strong>From空间</strong>，处于闲置状态的semispace称为<strong>To空间</strong>。</p><p>我画了一套详细的流程图，接下来我会结合流程图来详细说明Cheney算法是怎么工作的。<br>垃圾回收在下面我统称为 <strong>GC（Garbage Collection）</strong>。</p><p><strong>step1</strong>. 在From空间中分配了3个对象A、B、C</p><p><img src="http://image.liuxuan.site/cheney_step1.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step2</strong>. GC进来判断对象B没有其他引用，可以回收，对象A和C依然为活跃对象</p><p><img src="http://image.liuxuan.site/cheney_step2.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step3</strong>. 将活跃对象A、C从From空间复制到To空间</p><p><img src="http://image.liuxuan.site/cheney_step3.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step4</strong>. 清空From空间的全部内存</p><p><img src="http://image.liuxuan.site/cheney_step4.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step5</strong>. 交换From空间和To空间</p><p><img src="http://image.liuxuan.site/cheney_step5.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step6</strong>. 在From空间中又新增了2个对象D、E</p><p><img src="http://image.liuxuan.site/cheney_step6.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step7</strong>. 下一轮GC进来发现对象D没有引用了，做标记</p><p><img src="http://image.liuxuan.site/cheney_step7.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step8</strong>. 将活跃对象A、C、E从From空间复制到To空间</p><p><img src="http://image.liuxuan.site/cheney_step8.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step9</strong>. 清空From空间全部内存</p><p><img src="http://image.liuxuan.site/cheney_step9.png?imageView2/1/w/800" alt="cheney-step1"></p><p><strong>step10</strong>. 继续交换From空间和To空间，开始下一轮</p><p><img src="http://image.liuxuan.site/cheney_step10.png?imageView2/1/w/800" alt="cheney-step1"></p><p>通过上面的流程图，我们可以很清楚的看到，进行From和To交换，就是为了让活跃对象始终保持在一块semispace中，另一块semispace始终保持空闲的状态。</p><p>Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。Scavenge的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。</p><p>由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p><h4 id="3-晋升"><a href="#3-晋升" class="headerlink" title="3. 晋升"></a>3. 晋升</h4><p>当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。</p><p><strong>对象从新生代移动到老生代的过程叫作晋升</strong>。</p><p>对象晋升的条件主要有两个：</p><ol><li><p>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。<strong>总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中</strong>。</p></li><li><p>当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p></li></ol><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题：</p><ol><li>由于存活对象较多，复制存活对象的效率会很低。</li><li>采用Scavenge算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。</li></ol><p>所以，V8在老生代中主要采用了<strong>Mark-Sweep</strong>和<strong>Mark-Sweep</strong>相结合的方式进行垃圾回收。</p><h4 id="2-Mark-Sweep"><a href="#2-Mark-Sweep" class="headerlink" title="2. Mark-Sweep"></a>2. Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。</p><p>与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p><p>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p><p>我们还是通过流程图来看一下：</p><p><strong>step1</strong>. 老生代中有对象A、B、C、D、E、F</p><p><img src="http://image.liuxuan.site/blog/20180414/mark_sweep_step1?imageView2/1/w/800" alt="mark-sweep-step1"></p><p><strong>step2</strong>. GC进入标记阶段，将A、C、E标记为存活对象</p><p><img src="http://image.liuxuan.site/blog/20180414/mark_sweep_step2?imageView2/1/w/801" alt="mark-sweep-step1"></p><p><strong>step3</strong>. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间</p><p><img src="http://image.liuxuan.site/blog/20180414/mark_sweep_step3?imageView2/1/w/801" alt="mark-sweep-step1"></p><p>可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。</p><p>如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><h4 id="2-Mark-Compact"><a href="#2-Mark-Compact" class="headerlink" title="2. Mark-Compact"></a>2. Mark-Compact</h4><p>为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。</p><p><strong>Mark-Compact是标记整理的意思，</strong>是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示：</p><p><strong>step1</strong>. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样）</p><p><img src="http://image.liuxuan.site/blog/20180414/mark_sweep_step1?imageView2/1/w/801" alt="mark-sweep-step1"></p><p><strong>step2</strong>. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样）<br><img src="http://image.liuxuan.site/blog/20180414/mark_sweep_step2?imageView2/1/w/801" alt="mark-sweep-step1"></p><p><strong>step3</strong>. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180414/mark_compact_step3?imageView2/1/w/850" alt="mark-sweep-step1"></p><p><strong>step4</strong>. GC进入清除阶段，将边界另一侧的内存一次性全部回收</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180414/mark_compact_step4?imageView2/1/w/850" alt="mark-sweep-step1"></p><h4 id="3-两者结合"><a href="#3-两者结合" class="headerlink" title="3. 两者结合"></a>3. 两者结合</h4><p>在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。</p><p>由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>V8的垃圾回收机制分为新生代和老生代。</p><p>新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。</p><p>老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。</p><p>以上就是本文的全部内容，书写过程中参考了很多中外文章，参考书籍包括朴大大的《深入浅出NodeJS》以及《JavaScript高级程序设计》等。我们这里并没有对具体的算法实现进行探讨，感兴趣的朋友可以继续深入研究一下。</p><p>最后，谢谢大家能够读到这里，如果文中有任何不明确或错误的地方，欢迎给我留言~~</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8" target="_blank" rel="noopener">https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8</a><br><a href="http://alinode.aliyun.com/blog/14" target="_blank" rel="noopener">http://alinode.aliyun.com/blog/14</a><br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a><br><a href="https://segmentfault.com/a/1190000000440270" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000440270</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180414/garbage_collection.jpeg?imageView2/1/w/1000/h/400&quot; alt=&quot;label-statement&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。&lt;/p&gt;
&lt;p&gt;在写这篇文章之前，我也在网上看了很多博客，包括一些英文原版的内容，于是想通过这篇文章来做一个归纳整理，文中加入了我自己的思考，以及纯手工制作流程图~~&lt;/p&gt;
&lt;p&gt;希望这篇文章能帮到你，同时本文也会收录到我自己的&lt;a href=&quot;http://blog.liuxuan.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人网站&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么要有垃圾回收&quot;&gt;&lt;a href=&quot;#为什么要有垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;为什么要有垃圾回收&quot;&gt;&lt;/a&gt;为什么要有垃圾回收&lt;/h3&gt;&lt;p&gt;在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过&lt;strong&gt;malloc&lt;/strong&gt;函数去手动分配，在用完之后，还要时刻记得用&lt;strong&gt;free&lt;/strong&gt;函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。&lt;/p&gt;
&lt;p&gt;但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。&lt;/p&gt;
&lt;p&gt;不需要我们去手动管理内存了，所以自然要有&lt;strong&gt;垃圾回收&lt;/strong&gt;，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。&lt;/p&gt;
&lt;p&gt;垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="V8" scheme="//blog.liuxuan.site/tags/V8/"/>
    
      <category term="垃圾回收" scheme="//blog.liuxuan.site/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="Scavenge" scheme="//blog.liuxuan.site/tags/Scavenge/"/>
    
      <category term="Mark-Sweep" scheme="//blog.liuxuan.site/tags/Mark-Sweep/"/>
    
  </entry>
  
  <entry>
    <title>尾调用和尾递归</title>
    <link href="//blog.liuxuan.site/2018/04/10/tail_call/"/>
    <id>//blog.liuxuan.site/2018/04/10/tail_call/</id>
    <published>2018-04-10T13:36:00.000Z</published>
    <updated>2018-04-21T15:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180410/tail_call.jpg?imageView2/1/w/1000/h/400" alt="label-statement"></p><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。</p><p>注意这里函数的调用方式是无所谓的，以下方式均可：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数调用:     <span class="function"><span class="keyword">func</span><span class="params">(···)</span></span></span><br><span class="line">方法调用:     obj.method(···)</span><br><span class="line"><span class="built_in">call</span>调用:     <span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">(···)</span></span></span><br><span class="line">apply调用:    <span class="function"><span class="keyword">func</span>.<span class="title">apply</span><span class="params">(···)</span></span></span><br></pre></td></tr></table></figure></p><p>并且只有下列表达式会包含尾调用：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">条件操作符:      ? :</span></span><br><span class="line"><span class="section">逻辑或:         ||</span></span><br><span class="line"><span class="section">逻辑与:         &amp;&amp;</span></span><br><span class="line"><span class="section">逗号:           ,</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>依次举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">x</span> =&gt;</span> x ? f() : g();</span><br><span class="line"></span><br><span class="line"><span class="comment">// f() 和 g() 都在尾部。</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> f() || g();</span><br><span class="line"></span><br><span class="line"><span class="comment">// g()有可能是尾调用，f()不是</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为上述写法和下面的写法等效：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fResult = f(); <span class="comment">// not a tail call</span></span><br><span class="line">    <span class="keyword">if</span> (fResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> fResult;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g(); <span class="comment">// tail call</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当f()的结果为falsey的时候，g()才是尾调用</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> f() &amp;&amp; g();</span><br><span class="line"></span><br><span class="line"><span class="comment">// g()有可能是尾调用，f()不是</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为上述写法和下面的写法等效：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fResult = f(); <span class="comment">// not a tail call</span></span><br><span class="line">    <span class="keyword">if</span> (fResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> g(); <span class="comment">// tail call</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当f()的结果为truthy的时候，g()才是尾调用</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> (f() , g());</span><br><span class="line"></span><br><span class="line"><span class="comment">// g()是尾调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为上述写法和下面的写法等效：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-尾调用优化"><a href="#2-尾调用优化" class="headerlink" title="2. 尾调用优化"></a>2. 尾调用优化</h4><p>函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> &#123; <span class="title">console</span>.<span class="title">log</span><span class="params">(111)</span>; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span> &#123; <span class="title">foo</span><span class="params">()</span>; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span> <span class="params">()</span> &#123; <span class="title">bar</span><span class="params">()</span>; &#125;</span></span><br><span class="line"></span><br><span class="line">baz();</span><br></pre></td></tr></table></figure></p><p><img src="http://image.liuxuan.site/blog/20180409/call_stack.png" alt="call stack"></p><p>造成这种结果是因为每个函数在调用另一个函数的时候，并没有 <strong>return</strong> 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。</p><p><strong>baz()</strong> 里面调用了 <strong>bar()</strong> 函数，并没有 <strong>return</strong> 该调用，所以在调用栈中保持自己的调用帧，同时 <strong>bar()</strong> 函数的调用帧在调用栈中生成，同理，<strong>bar()</strong> 函数又调用了 <strong>foo()</strong> 函数，最后执行到 <strong>foo()</strong> 函数的时候，没有再调用其他函数，这里没有显示声明 <strong>return</strong>，所以这里默认 <strong>return undefined</strong>。</p><p><strong>foo()</strong> 执行完了，销毁调用栈中自己的记录，依次销毁 <strong>bar()</strong> 和 <strong>baz()</strong> 的调用帧，最后完成整个流程。</p><p>如果对上面的例子做如下修改：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">foo</span> () &#123; console.log(111); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">bar</span> () &#123; <span class="keyword">return</span> <span class="type">foo()</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title">baz</span> () &#123; <span class="keyword">return</span> <span class="type">bar()</span>; &#125;</span><br><span class="line"></span><br><span class="line">baz();</span><br></pre></td></tr></table></figure></p><p>这里要注意：<strong>尾调用优化只在严格模式下有效。</strong></p><p>在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈：</p><ul><li>func.arguments: 表示对 func最近一次调用所包含的参数</li><li>func.caller: 引用对 func最近一次调用的那个函数</li></ul><p>在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。</p><p>如果尾调用优化生效，流程图就会变成这样：</p><p><img src="http://image.liuxuan.site/blog/20180409/call_stack_tail.png" alt="call stack"></p><p>我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。</p><p>这就叫做<strong>尾调用优化</strong>，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是<strong>尾调用优化的意义</strong>。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>先来看一下递归，当一个函数调用自身，就叫做递归。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。</p><p>那么什么是尾递归？<br>前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做<strong>尾递归</strong>。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">foo</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">foo()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><p>那么尾递归相比递归而言，有哪些不同呢？<br>我们通过下面这个求<strong>阶乘</strong>的例子来看一下：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">factorial</span> (<span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">num</span> === <span class="number">1</span>) <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">num</span> * <span class="built_in">factorial</span>(<span class="built_in">num</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">5</span>);            // <span class="number">120</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">10</span>);           // <span class="number">3628800</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">500000</span>);       // Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure></p><p>上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。</p><p>这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。</p><p>如果用尾递归来计算阶乘呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>, <span class="number">1</span>);               <span class="comment">// 3628800</span></span><br><span class="line">factorial(<span class="number">500000</span>, <span class="number">1</span>);           <span class="comment">// 分情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，虽然说这里启用了严格模式，但是经测试，在Chrome和Firefox下，还是会报栈溢出错误，并没有进行尾调用优化</span></span><br><span class="line"><span class="comment">// Safari浏览器进行了尾调用优化，factorial(500000, 1)结果为Infinity，因为结果超出了JS可表示的数字范围</span></span><br><span class="line"><span class="comment">// 如果在node v6版本下执行，需要加--harmony_tailcalls参数，node --harmony_tailcalls test.js</span></span><br><span class="line"><span class="comment">// node最新版本已经移除了--harmony_tailcalls功能</span></span><br></pre></td></tr></table></figure></p><p>通过尾递归，我们把复杂度从O(n)降低到了O(1)，如果数据足够大的话，会节省很多的计算时间。<br>由此可见，<strong>尾调用优</strong>化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。</p><h3 id="避免改写递归函数"><a href="#避免改写递归函数" class="headerlink" title="避免改写递归函数"></a>避免改写递归函数</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。<br>要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的factorial()函数改写一样。</p><p>这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？<br>解决这个问题的办法有两个：</p><h4 id="1-ES6参数默认值"><a href="#1-ES6参数默认值" class="headerlink" title="1. ES6参数默认值"></a>1. ES6参数默认值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);               <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure><h4 id="2-用一个符合语义的函数去调用改写后的尾递归函数"><a href="#2-用一个符合语义的函数去调用改写后的尾递归函数" class="headerlink" title="2. 用一个符合语义的函数去调用改写后的尾递归函数"></a>2. 用一个符合语义的函数去调用改写后的尾递归函数</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial (<span class="built_in">num</span>, total) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">num</span> === <span class="number">1</span>) <span class="built_in">return</span> total;</span><br><span class="line">    <span class="built_in">return</span> tailFactorial(<span class="built_in">num</span> - <span class="number">1</span>, <span class="built_in">num</span> * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="built_in">factorial</span> (<span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> tailFactorial(<span class="built_in">num</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">5</span>);                // <span class="number">120</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">10</span>);               // <span class="number">3628800</span></span><br></pre></td></tr></table></figure><p>上面这种写法其实有点类似于做了一个函数柯里化，但不完全符合柯里化的概念。<br><strong>函数柯里化</strong>是指把接受多个参数的函数转换为接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数。</p><p>概念看着很绕口，我们来个例子感受一下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(x, y, z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);        <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写为柯里化加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(z)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y + z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);        <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><p>可以看到，柯里化函数通过闭包找到父作用域里的变量，最后依次相加输出结果。<br>通过这个例子，可能看不出为什么要用柯里化，有什么好处，这个我们以后再谈，这里先引出一个概念。</p><p>是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p><p>如果用柯里化改写求阶乘的例子：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> <span class="params">(fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _fnArgLength = fn.length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrap</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = args;</span><br><span class="line">        <span class="keyword">var</span> _argLength = _args.length;</span><br><span class="line">        <span class="comment">// 如果传的是所有参数，直接返回fn调用</span></span><br><span class="line">        <span class="keyword">if</span> (_fnArgLength === _argLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">act</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">            _args = _args.concat(args);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_args.length === _fnArgLength) &#123;</span><br><span class="line">                <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, _args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> act;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> act;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span> <span class="params">(num, total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写</span></span><br><span class="line"><span class="keyword">var</span> factorial = curry(tailFactorial);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>)(<span class="number">1</span>);        <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>)(<span class="number">1</span>);       <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure></p><p>这是符合柯里化概念的写法，在阮一峰老师的文章中是这样写的：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span><span class="params">(fn, n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p><p>我个人认为，这种写法其实不是柯里化，因为并没有将多参数的tailFacrotial改写为接受单参数的形式，只是换了一种写法，和下面这样写意义是一样的：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">factorial</span> (<span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> tailFactorial(<span class="built_in">num</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tailFactorial (<span class="built_in">num</span>, total) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">num</span> === <span class="number">1</span>) <span class="built_in">return</span> total;</span><br><span class="line">    <span class="built_in">return</span> tailFactorial(<span class="built_in">num</span> - <span class="number">1</span>, <span class="built_in">num</span> * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">5</span>);                // <span class="number">120</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">10</span>);               // <span class="number">3628800</span></span><br></pre></td></tr></table></figure></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这篇文章我们主要讨论了尾调用优化和柯里化。<br>要注意的是，经过测试，Chrome和Firefox并没有对尾调用进行优化，Safari对尾调用进行了优化。<br>Node高版本也已经去除了通过–harmony_tailcalls参数启用尾调用优化。</p><p>有任何问题，欢迎大家留言讨论~~</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/04/tail-call.html</a><br><a href="https://juejin.im/post/5a4d898a518825698e7277d1" target="_blank" rel="noopener">https://juejin.im/post/5a4d898a518825698e7277d1</a><br><a href="https://github.com/lamdu/lamdu/issues/90" target="_blank" rel="noopener">https://github.com/lamdu/lamdu/issues/90</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180410/tail_call.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;label-statement&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;尾调用&quot;&gt;&lt;a href=&quot;#尾调用&quot; class=&quot;headerlink&quot; title=&quot;尾调用&quot;&gt;&lt;/a&gt;尾调用&lt;/h3&gt;&lt;h4 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h4&gt;&lt;p&gt;尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。&lt;/p&gt;
&lt;p&gt;注意这里函数的调用方式是无所谓的，以下方式均可：&lt;br&gt;&lt;figure class=&quot;highlight autoit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;函数调用:     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(···)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;方法调用:     obj.method(···)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;call&lt;/span&gt;调用:     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(···)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apply调用:    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(···)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;并且只有下列表达式会包含尾调用：&lt;br&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;条件操作符:      ? :&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;逻辑或:         ||&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;逻辑与:         &amp;amp;&amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;逗号:           ,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="尾调用" scheme="//blog.liuxuan.site/tags/%E5%B0%BE%E8%B0%83%E7%94%A8/"/>
    
      <category term="尾递归" scheme="//blog.liuxuan.site/tags/%E5%B0%BE%E9%80%92%E5%BD%92/"/>
    
      <category term="函数式" scheme="//blog.liuxuan.site/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="柯里化" scheme="//blog.liuxuan.site/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>搭建 karma + jasmine 测试环境</title>
    <link href="//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/"/>
    <id>//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/</id>
    <published>2018-04-03T02:36:00.000Z</published>
    <updated>2018-04-06T19:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/test_karma.jpg?imageView2/1/w/1000/h/400" alt="test-karma"></p><p>在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。</p><h3 id="什么是-karma"><a href="#什么是-karma" class="headerlink" title="什么是 karma"></a>什么是 karma</h3><p>karma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。</p><h3 id="安装-karma"><a href="#安装-karma" class="headerlink" title="安装 karma"></a>安装 karma</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm  install karma -D</span></span><br></pre></td></tr></table></figure><p>这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="keyword">node</span><span class="title">-modules</span>/.bin/karma init</span><br></pre></td></tr></table></figure><p>这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install karma-cli -g</span></span><br></pre></td></tr></table></figure></p><p>以后就可以在任何路径执行 <strong>karma start</strong> 并且运行的 karma 都是在当前项目下安装的版本。</p><a id="more"></a><p>在 init 时会让你选择一些配置项：</p><p><strong>test framework</strong><br>我这里选择的是jasmine，它是一款JavaScript断言测试库<br><strong>use Require.js</strong><br>根据个人情况，我选择的是no<br><strong>capture any browsers automatically</strong><br>选择浏览器，我选择的是无头浏览器PhantomJS<br><strong>location of your source files</strong><br>为空<br><strong>any of files included by the previous patterns be excluted</strong><br>为空<br><strong>karma to watch all files and run the tests on change</strong><br>是否监测，我选择的是no</p><p>在选择完所有配置项后，会自动生成karma.conf.js配置文件。</p><h3 id="根据配置项的选择安装插件"><a href="#根据配置项的选择安装插件" class="headerlink" title="根据配置项的选择安装插件"></a>根据配置项的选择安装插件</h3><p><strong>（1）</strong> 测试框架选择的是jasmine，安装步骤如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span><span class="keyword">jasmine-core </span>karma-<span class="keyword">jasmine </span>-D</span><br></pre></td></tr></table></figure></p><p>这里要装两个，一个是jasmine的核心，另一个是karma对jasmine的封装。</p><p><strong>（2）</strong> 浏览器选择的是PhantomJS，安装步骤如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install karma-phantomjs-launcher -D</span></span><br></pre></td></tr></table></figure></p><p><strong>（3）</strong> 如果涉及到对以ES6编写的代码进行测试，就要安装Babel及其相关插件：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span><span class="keyword">babel-cli </span><span class="keyword">babel-preset-env </span><span class="keyword">babel-plugin-transform-es2015-modules-umd </span>-D</span><br><span class="line">$ npm <span class="keyword">install </span>karma-<span class="keyword">babel-preprocessor </span>-D</span><br></pre></td></tr></table></figure></p><p><strong>（4）</strong> 安装生成代码覆盖率报告的插件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install karma-coverage -D</span></span><br></pre></td></tr></table></figure></p><h3 id="修改karma配置文件"><a href="#修改karma配置文件" class="headerlink" title="修改karma配置文件"></a>修改karma配置文件</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// karma.<span class="keyword">conf</span>.js</span><br><span class="line"></span><br><span class="line">module.exports = <span class="function"><span class="keyword">function</span><span class="params">(config)</span> &#123;</span></span><br><span class="line">  config.<span class="keyword">set</span>(&#123;</span><br><span class="line">    basePath: <span class="string">''</span>,</span><br><span class="line">    framework<span class="variable">s:</span> [<span class="string">'jasmine'</span>],</span><br><span class="line">    <span class="keyword">file</span><span class="variable">s:</span> [</span><br><span class="line">      <span class="string">'./src/**/*.js'</span>,</span><br><span class="line">      <span class="string">'./test/**/*.spec.js'</span></span><br><span class="line">    ],</span><br><span class="line">    exclude: [</span><br><span class="line">    ],</span><br><span class="line">    preprocessor<span class="variable">s:</span> &#123;</span><br><span class="line">      <span class="string">'./src/**/*.js'</span>: [<span class="string">'babel'</span>],</span><br><span class="line">      <span class="string">'./test/**/*.spec.js'</span>: [<span class="string">'babel'</span>, <span class="string">'coverage'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    reporter<span class="variable">s:</span> [<span class="string">'progress'</span>, <span class="string">'coverage'</span>],</span><br><span class="line">    coverageReporter: &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">'html'</span>,</span><br><span class="line">      dir: <span class="string">'coverage/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    por<span class="variable">t:</span> <span class="number">9876</span>,</span><br><span class="line">    color<span class="variable">s:</span> true,</span><br><span class="line">    logLeve<span class="variable">l:</span> config.LOG_INFO,</span><br><span class="line">    autoWatch: false,</span><br><span class="line">    browser<span class="variable">s:</span> [<span class="string">'PhantomJS'</span>],</span><br><span class="line">    singleRun: true,</span><br><span class="line">    concurrency: Infinity</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Babel配置文件：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">.babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-es2015-modules-umd"</span>],</span><br><span class="line">  <span class="string">"auxiliaryCommentBefore"</span>: <span class="string">"istanbul ignore next"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="写测试文件"><a href="#写测试文件" class="headerlink" title="写测试文件"></a>写测试文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PraiseButton.spec.js</span></span><br><span class="line"><span class="keyword">import</span> PraiseButton <span class="keyword">from</span> <span class="string">'../src/PraiseButton.js'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试点赞组件'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'addOne() 函数'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testPraiseButton = <span class="keyword">new</span> PraiseButton();</span><br><span class="line">    testPraiseButton.addOne();</span><br><span class="line"></span><br><span class="line">    expect(testPraiseButton.countNum).toBe(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> karma start</span></span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>按照上述步骤，大家应该可以配置好自己的 karma + jasmine 测试环境，如果遇到问题或者文中有写错的地方，欢迎大家来讨论。文章末尾是需要安装模块的链接，大家可以一键直达。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>karma官网<br><a href="https://karma-runner.github.io/2.0/intro/installation.html" target="_blank" rel="noopener">https://karma-runner.github.io/2.0/intro/installation.html</a><br>karma-cli<br><a href="https://www.npmjs.com/package/karma-cli" target="_blank" rel="noopener">https://www.npmjs.com/package/karma-cli</a><br>karma-jasmine<br><a href="https://www.npmjs.com/package/karma-jasmine" target="_blank" rel="noopener">https://www.npmjs.com/package/karma-jasmine</a><br>jasmine-core<br><a href="https://www.npmjs.com/package/jasmine-core" target="_blank" rel="noopener">https://www.npmjs.com/package/jasmine-core</a><br>karma-coverage<br><a href="https://www.npmjs.com/package/karma-coverage" target="_blank" rel="noopener">https://www.npmjs.com/package/karma-coverage</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/test_karma.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;test-karma&quot;&gt;&lt;/p&gt;
&lt;p&gt;在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。&lt;/p&gt;
&lt;h3 id=&quot;什么是-karma&quot;&gt;&lt;a href=&quot;#什么是-karma&quot; class=&quot;headerlink&quot; title=&quot;什么是 karma&quot;&gt;&lt;/a&gt;什么是 karma&lt;/h3&gt;&lt;p&gt;karma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。&lt;/p&gt;
&lt;h3 id=&quot;安装-karma&quot;&gt;&lt;a href=&quot;#安装-karma&quot; class=&quot;headerlink&quot; title=&quot;安装 karma&quot;&gt;&lt;/a&gt;安装 karma&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm  install karma -D&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ./&lt;span class=&quot;keyword&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;title&quot;&gt;-modules&lt;/span&gt;/.bin/karma init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm install karma-cli -g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以后就可以在任何路径执行 &lt;strong&gt;karma start&lt;/strong&gt; 并且运行的 karma 都是在当前项目下安装的版本。&lt;/p&gt;
    
    </summary>
    
      <category term="前端测试" scheme="//blog.liuxuan.site/categories/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="//blog.liuxuan.site/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="karma" scheme="//blog.liuxuan.site/tags/karma/"/>
    
      <category term="jasmine" scheme="//blog.liuxuan.site/tags/jasmine/"/>
    
      <category term="phantomJS" scheme="//blog.liuxuan.site/tags/phantomJS/"/>
    
      <category term="Babel" scheme="//blog.liuxuan.site/tags/Babel/"/>
    
      <category term="ES6" scheme="//blog.liuxuan.site/tags/ES6/"/>
    
      <category term="System" scheme="//blog.liuxuan.site/tags/System/"/>
    
      <category term="node" scheme="//blog.liuxuan.site/tags/node/"/>
    
      <category term="npm" scheme="//blog.liuxuan.site/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 07 - 标签声明（Label Statement）</title>
    <link href="//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/"/>
    <id>//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/</id>
    <published>2018-03-10T02:36:00.000Z</published>
    <updated>2018-04-21T15:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/label_statement.jpg?imageView2/1/w/1000/h/400" alt="label-statement"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>假设有这么一道题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br></pre></td></tr></table></figure></p><p>我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？</p><p>可能有的同学会想到这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">            <span class="keyword">if</span> (j === <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br></pre></td></tr></table></figure></p><p>这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？</p><a id="more"></a><p>再看一个例子，你也一定见到过这样的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设str是你通过ajax接收到的JSON串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"name": "liu", "age": 20&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">'('</span> + str + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></p><p>那么，你有没有想过 eval 里面为什么要加上括号呢？如果不加又是什么情况？（<em>提前剧透，不加括号这里会报错哦</em>）。</p><p><strong>接着往下看，当你读完这篇文章的时候，心中的疑惑会完全解开。</strong></p><h3 id="Label-Statement"><a href="#Label-Statement" class="headerlink" title="Label Statement"></a>Label Statement</h3><p>学过C语言的同学知道，C的语法中有一个语句叫：goto，同时老师也多次强调不让我们使用goto语句，因为会大大影响程序的<strong>可读性</strong>和<strong>可维护性</strong>。</p><p>我们先来看一段C语言的goto代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>, b=<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) &#123;</span><br><span class="line">        <span class="keyword">goto</span> aa;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">    aa: <span class="built_in">printf</span>(<span class="string">"s"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 a &lt; b 的时候，这里会打印字符串 “hello”，然后结束。<br>当 a &gt; b 的时候，由于goto语句的作用，就会跳过 print(“hello”)，直接跳到 aa 标签声明的代码块中，打印字符 “s”，然后结束。</p><p>这就是goto语句的作用，通过标签声明一个代码块，然后在任何地方都可以执行 goto ‘labe’ 来进行程序跳转。</p><p>显而易见，这样的写法，违背了程序顺序执行的原则，会跳来跳去，最后导致根本无法维护，所以，记住老师的话，<strong>不要使用 goto 语句</strong>。</p><p>那么，看完了C语言中的 goto 语句，和我们的 JavaScript 又有什么关系呢？<br>这就引出了今天的主题：Label Statement，它就是 JS 中的 goto 语句。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先明确一个原则，<strong>在JavaScript中，语句优先</strong>。<br>也就是说，如果一段代码既能够以语句的方式解析，也能用语法的方式解析，在JS中，会优先按语句来解析。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">a </span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，在JS中的执行结果是什么呢？<br><strong>大家思考2分钟….</strong></p><hr><hr><p>好，2分钟已过，大家有结果了吗？<br>千万不要在浏览器的控制台中去写这段代码，虽然结果和你开始想的结果一样，<br><strong>但是，它是错误的。</strong></p><p>这是在console控制台中执行的结果：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_console.png?imageView2/1/w/400" alt="label-console图片"></p><p>这是在watch中的执行结果：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_watch.png?imageView2/1/w/400" alt="clipboard.png"></p><p>可以看到两个结果是不一样的。<br>console是经过处理的这里不能相信，watch是直接JS的运行环境执行后的结果，是正确的。</p><p>为什么 { a : 1 } 结果会是 1 呢？</p><p>我换一个写法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">a </span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相信有的同学已经明白了，在JS中，{}既可以代表代码块，又可以作为Object的语法标志。<br>那么我们前面说过，<strong>JS是语句优先的，当一段代码既可以按照语句解析，又可以按照语法解析的时候，会优先按语句解析。</strong></p><p>当把{}当做是代码块的时候，里面的 a : 1，是不是很像C语言goto语句的标签声明呢？<br>开头我们提出的第一个问题，如果用这种方式来解决，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aa : &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">            <span class="keyword">if</span> (j === <span class="number">2</span>) <span class="keyword">break</span> aa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br></pre></td></tr></table></figure></p><p>aa是标签声明，包裹一个代码块，break 的作用是跳出当前的循环，本来是无法跳出外面那层for循环的，但是 break aa，这里跳出了整个代码块。</p><p><strong>当然，这种写法是完全不提倡的，这里只是用来说明JS中的Label Statement这个特性，大家千万不要这样写代码。</strong></p><p>再来看开头提出的第二个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设str是你通过ajax接收到的JSON串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"name": "liu", "age": 20&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">'('</span> + str + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></p><p>我们知道，eval(str)会把接收到的字符串在当前上下文中执行，如果不加括号：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">eval</span><span class="params">('&#123;<span class="string">"name"</span>: <span class="string">"liu"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;&#125;')</span></span></span><br></pre></td></tr></table></figure></p><p>这里的执行语句就会变成：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"liu"</span>, <span class="attr">"age"</span> : <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>{}按照语句解析，执行里面的逗号表达式，我们知道逗号表达式要求每一项都必须是表达式，输出最后一项的结果，而这里不满足要求，所以会报错。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_watch2.png?imageView2/1/w/400" alt="label-watch2"></p><p>但是加上括号就变成了这样：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"liu"</span>, <span class="string">"age"</span> : <span class="number">20</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>小括号可以把里面的内容当做表达式来解析，那么里面的内容就是一个对象了。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_watch3.png?imageView2/1/w/400" alt="label-watch2"></p><p>这也是立即执行函数的原理：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span> () &#123;</span><br><span class="line">    console.log(<span class="name">'IIFE'</span>)<span class="comment">;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>小括号把函数声明变成了函数表达式，后面再跟一个小括号表示调用。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这里通过几个例子，引出了 JavaScript 的标签声明语句（Label Statement），从而解释了一些我们常用写法的原理。</p><p><strong>以后万一有人问你为什么 eval() 解析JSON要加括号呢？</strong><br><strong>这回知道怎么说了吧。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/label_statement.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;label-statement&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;假设有这么一道题：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;done&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？&lt;/p&gt;
&lt;p&gt;可能有的同学会想到这样：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (j === &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;done&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="Label Statement" scheme="//blog.liuxuan.site/tags/Label-Statement/"/>
    
      <category term="C语言" scheme="//blog.liuxuan.site/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Goto语句" scheme="//blog.liuxuan.site/tags/Goto%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>HTML - 移动端 meta viewport</title>
    <link href="//blog.liuxuan.site/2017/12/10/html_meta_viewport/"/>
    <id>//blog.liuxuan.site/2017/12/10/html_meta_viewport/</id>
    <published>2017-12-10T02:36:00.000Z</published>
    <updated>2018-04-06T19:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/meta_viewport.jpg?imageView2/1/w/1000/h/400" alt="meta-viewport"></p><p>我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">user-scalable=0"&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 <strong>viewport 到底是什么</strong>。</p><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>在讨论 viewport 之前，我们需要理解一些单位的概念：</p><ul><li><strong>设备像素 / 物理像素（physical pixels）</strong><br>是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。</li></ul><a id="more"></a><ul><li><p><strong>CSS 像素（css pixel） / 密度独立像素（density independent pixels - dip）</strong><br>CSS 像素是 web 编程中的概念，是抽象的，不是实际存在的。它是独立于设备用于逻辑上衡量像素的单位，所以又叫密度独立像素。dip 有时候也缩写为 dp 。</p></li><li><p><strong>屏幕尺寸</strong><br>指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。</p></li><li><p><strong>屏幕像素密度（pixels per inch - ppi）</strong><br>指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的 ppi = √(1920^2+1080^2) / 5.5 ≈ 401ppi 。也就是说它每英寸可以显示 440 个物理像素点。</p></li><li><p><strong>设备像素比</strong><br>指物理像素和密度独立像素的比值。<br>window.devicePixelRatio = 物理像素 / dip。<br>可以通过 window.devicePixelRatio 获得，该属性被所有WebKit浏览器以及Opera所支持。</p></li></ul><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>viewport 是指 web 页面上用户的可见区域。</p><p>viewport 的大小是和设备相关的，在移动端例如手机上，viewport 的大小是比 PC 端要小的，一般无论手机还是平板，默认的 viewport 大小都是 980px 。<br>刚开始 web 页面仅仅是在 PC 端进行查看的，但是后来随着移动互联网的发展，越来越多的 web 访问是通过移动端进行的，但是因为 PC 的 viewport 要比移动端大，所以为了快速修复这个问题，移动端的浏览器默认只是把整个页面等比例缩小到移动端的 viewport 大小。</p><p>这样做的后果就是，用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。</p><p>那么回到我们最开始写的 meta 标签：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">user-scalable=0"&gt;</span></span><br></pre></td></tr></table></figure></p><p>device-width 是指这个设备最理想的 viewport 宽度。iPhone6 之前的 device-width 都是 320px ，iPhone6 是 375px ，iPhone6 Plus 是 414px ，<strong>而这个 device-width 是和 CSS像素（也叫密度独立像素 dip）是相同的</strong>。也就是说，web 页面中的 CSS像素的值等于 device-width 时，对应到手机上就是占满全屏的宽度。</p><p>安卓手机的 device-width 有320px、360px 和 384px 等等，不同的设备 device-width 是不一样的。</p><p>initial-scale=1.0 是指初始化的时候缩放大小是1，也就是不缩放。</p><p>user-scalable=0 是指禁止用户进行缩放。</p><p>maximum-scale=1.0 是指用户最大缩放大小是1，其实在禁止用户缩放以后，这一句可以省略。</p><p><strong>在设计人员为移动端设计页面的时候经常可以听到2倍图和3倍图这些词语，这又是什么意思呢，我们以 iPhone6 举例</strong>：</p><p>iPhone6 的分辨率（也就是物理像素）是 1334*750 像素，它的 device-width 是 375px 。</p><p>如果我们将屏幕横向分成 375 份，CSS 中 1px 占用的1份，因为屏幕就那么大，CSS中 width 等于 375px 时横向就会占满全屏，但是实际上<strong>存在的物理像素点横向是750个</strong> ，所以在我们写 CSS 时 1px 对应到屏幕上是占用了2个物理像素点。</p><p>如果我们不写 <strong><em>width=device-width</em></strong> 这一句的话，默认 viewport 宽是 980px 。那么把 iPhone6 的屏幕横向分成980份，CSS 中 1px 占用1份，但是真正的像素点横向只有750个，这就意味着，实际上渲染出来的宽度是 75/98 个像素大小（只是理论上）。</p><p>设计人员在设计原型图的时候以 750px 的宽度为基准，我们在写 CSS的时候缩写一半来使用，但是在渲染的时候 1px 等于 2px 的物理像素，所以整个图片还是按 750px 的宽度来显示的，不会失真。</p><p>如果设计人员以 375px 的宽度为基准，那么我们在使用的时候直接把设计图中的像素宽度用在 CSS 中，那么在渲染的时候，1px 等于 2px 的物理像素，相当于图片会放大2倍，就会产生失真。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在添加 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">  之后，移动端的 viewport 宽度会从默认的 980px 变成各个设备的 device-width 。</p><p>CSS 中的 100% 就等于 device-width 。 </p><p>知道了这些，我们就可以结合别的知识，为页面进行响应式布局了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/meta_viewport.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;meta-viewport&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：&lt;br&gt;&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;meta &lt;span class=&quot;attr&quot;&gt;name=&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content=&quot;width=device-width,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;initial-scale=1.0,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;maximum-scale=1.0,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;user-scalable=0&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 &lt;strong&gt;viewport 到底是什么&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;单位&quot;&gt;&lt;a href=&quot;#单位&quot; class=&quot;headerlink&quot; title=&quot;单位&quot;&gt;&lt;/a&gt;单位&lt;/h3&gt;&lt;p&gt;在讨论 viewport 之前，我们需要理解一些单位的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备像素 / 物理像素（physical pixels）&lt;/strong&gt;&lt;br&gt;是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML" scheme="//blog.liuxuan.site/categories/HTML/"/>
    
    
      <category term="HTML" scheme="//blog.liuxuan.site/tags/HTML/"/>
    
      <category term="meta" scheme="//blog.liuxuan.site/tags/meta/"/>
    
      <category term="viewport" scheme="//blog.liuxuan.site/tags/viewport/"/>
    
      <category term="pt" scheme="//blog.liuxuan.site/tags/pt/"/>
    
      <category term="dip" scheme="//blog.liuxuan.site/tags/dip/"/>
    
      <category term="ppi" scheme="//blog.liuxuan.site/tags/ppi/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 06 - 变量对象</title>
    <link href="//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/"/>
    <id>//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/</id>
    <published>2017-08-10T02:36:00.000Z</published>
    <updated>2018-04-21T15:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/variable_object.jpg?imageView2/1/w/1000/h/400" alt="variable-object"></p><p>上一节我们讨论了<a href="http://www.jianshu.com/p/05641baa5134" target="_blank" rel="noopener">执行上下文</a>，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。</p><p><strong>变量对象</strong>就是<strong>执行上下文</strong>和<strong>作用域链</strong>中间的桥梁。<br>剧透一下，神秘的 <strong>this</strong> 就存在于执行上下文环境之中！<br>当然，之后我会单独用几节来彻底讲明白 <strong>this 到底是什么</strong>（其实 this 很简单）。</p><p>接下来，我们进入正文。</p><h3 id="执行上下文包含什么"><a href="#执行上下文包含什么" class="headerlink" title="执行上下文包含什么"></a>执行上下文包含什么</h3><p>一个执行上下文我们可以抽象的理解为对象（object）。<br>每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。</p><p>我用一个结构图来说明：</p><p><img src="http://image.liuxuan.site/blog/20180324/variable_object.png" alt="执行上下文环境 object"></p><a id="more"></a><p><strong>Variable Object</strong> 就代表变量对象。<br><strong>Scope Chain</strong> 代表作用域链。<br><strong>thisValue</strong> 代表神秘的 this 。</p><p>作用域链和 this 留到后面再讲，今天我们先来弄明白<strong>变量对象</strong>。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><blockquote><p>A variable object is a scope of data related with the execution context. It’s a special object associated with the context and which stores variables and function declarations are being defined within the context.</p></blockquote><blockquote><p>变量对象(variable object) 是与执行上下文相关的数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</p></blockquote><p><strong>变量对象</strong>（Variable Object – 简写 VO）是一个抽象的概念，指代与执行上下文相关的特殊对象，它存储着在上下文中声明的：</p><ul><li><strong>变量</strong>（var）</li><li><strong>函数声明</strong> （function declaration，简写 FD）</li><li><strong>函数的形参</strong>（arguments）</li></ul><p>我们假设变量对象为一个普通 ECMAScript 对象：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">VO</span> = &#123;&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>就像前面讲过的，VO 是执行上下文的一个属性：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line"><span class="symbol">  VO:</span> &#123;</span><br><span class="line">    <span class="comment">// 上下文数据 （vars, FD, arguments）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为变量对象是一个抽象的概念，所以并不能通过变量对象的名称直接访问，但是却可以通过别的方法来间接访问变量对象，例如在全局上下文环境的变量对象会有一个属性 window (DOM 中) 可以引用变量对象自身，全局上下文环境的另一个属性 this 也指向全局上下文环境的变量对象。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">exp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>这里对应的变量对象是：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局上下文环境的变量对象</span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">   <span class="comment">// 一些全局环境初始化时系统自动创建的属性： Math、String、Date、parseInt等等</span></span><br><span class="line">   ···</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 全局上下文的变量对象中有一个属性可以访问到自身，在浏览器中这个属性是 window ，在 node 中这个属性是 global</span></span><br><span class="line"><span class="symbol">   window:</span> global</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自己定义的属性</span></span><br><span class="line"><span class="symbol">   a:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">   foo:</span> <span class="params">&lt;reference to function&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 函数上下文的变量对象</span></span><br><span class="line">VO(foo functionContext) = &#123;</span><br><span class="line"><span class="symbol">   num:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">   b:</span> <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>注意：函数表达式并不包括在变量对象中。</strong></p><h3 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h3><p>执行上下文包括：<strong>全局上下文、函数上下文和 eval() 上下文。</strong></p><h4 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h4><p>这里我们先来了解一下什么是全局对象：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局对象（<span class="keyword">global</span> <span class="keyword">object</span>）是指在进入任何执行上下文之前就已经创建了的对象。</span><br><span class="line">这个对象只有一份，它的属性在程序中的任何地方都可以访问，全局对象的生命周期终止于程序退出的那一刻。</span><br></pre></td></tr></table></figure></p><p>全局对象初始化时系统将创建并初始化一系列原始属性，例如：Math、String、Date、parseInt、window等等，之后是我们在全局上下文中自己定义的全局变量。在 DOM 中，全局对象的 window 属性可以引用全局对象自身，全局上下文环境的 this 属性也可以引用全局对象。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局执行上下文环境</span></span><br><span class="line">EC(globalContext) = &#123;</span><br><span class="line">   <span class="comment">// 全局对象（全局上下文环境的变量对象） </span></span><br><span class="line">   <span class="built_in">global</span>: &#123;</span><br><span class="line">      Math: &lt;<span class="params">...</span>&gt;,</span><br><span class="line">      <span class="built_in">String</span>: &lt;<span class="params">...</span>&gt;,</span><br><span class="line">      <span class="params">...</span></span><br><span class="line">      <span class="params">...</span></span><br><span class="line">      window: <span class="built_in">global</span>     <span class="comment">// 引用全局对象自身</span></span><br><span class="line">   &#125;,</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// this 属性</span></span><br><span class="line">   this: <span class="built_in">global</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 作用域链</span></span><br><span class="line">   <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);               <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);        <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);          <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>因此，在全局上下文环境中，变量对象用全局对象来表示。</p><h4 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h4><p>在函数上下文中，变量对象用活动对象 AO（Active Object）来表示。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">VO</span><span class="params">(functionContext)</span></span> = AO</span><br></pre></td></tr></table></figure></p><p>活动对象是在进入函数上下文时刻被创建的，它是通过函数的 arguments 属性进行初始化。arguments 也是一个对象。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">   arguments: &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>arguments 是活动对象的一个属性，它也是一个对象，包括以下属性：</p><ol><li>callee - 指向当前函数的引用</li><li>length - 真正传递的参数个数</li><li>properties-indexes - index 是字符串类型的整数，例如”1”: “aa”，类似于数组类型，也可以通过arguments[1]来访问，但是不能用数组的方法（push, pop等等）。另外，properties-indexes 的值和实际传递进来的参数之间是共享的，一个改变，另一个也随之改变。</li></ol><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 声明的函数参数数量</span></span><br><span class="line">   <span class="built_in">console</span>.log(foo.length);      <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实际传递进来的参数数量</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// arguments 的 callee 属性指向当前函数</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === foo)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 参数共享</span></span><br><span class="line">   <span class="built_in">console</span>.log(x === <span class="built_in">arguments</span>[<span class="number">0</span>]);      <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(x);      <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(x);   <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">   x = <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);    <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 但是注意，没有传递进来的参数 z ，和第3个索引值是不共享的</span></span><br><span class="line">   z = <span class="number">40</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);      <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(z);      <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><h3 id="代码是如何被处理的"><a href="#代码是如何被处理的" class="headerlink" title="代码是如何被处理的"></a>代码是如何被处理的</h3><p>在第1节中我们讲过<a href="http://www.jianshu.com/p/04fe77235dac" target="_blank" rel="noopener">js 代码的编译过程</a>，其中有一步叫作<strong>预编译</strong>，是说在代码执行前的几微秒会首先对代码进行编译，形成词法作用域，然后执行。</p><p>那么执行上下文的代码就就可以分成两个阶段来处理：</p><ol><li>进入执行上下文（预编译）</li><li>执行代码</li></ol><p>而变量对象的修改变化和这两个阶段是紧密相关的。<br>并且所有类型的执行上下文都会有这2个阶段。</p><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当引擎进入执行上下文时（代码还未执行），VO 里已经包含了一些属性：</p><ol><li><p><strong>函数的所有形参（如果是函数执行上下文）</strong><br>由名称和对应值组成的一个变量对象的属性被创建，如果没有传递对应的实参，那么由名称和 undefined 组成的一种变量对象的属性也会被创建。</p></li><li><p><strong>所有的函数声明（Function Declaration - FD）</strong><br>由名称和对应值（函数对象 function object）组成的一个变量对象的属性被创建，如果变量对象已经存在相同名称函数的属性，则完全替换这个属性。</p></li><li><p><strong>所有的变量声明（Variable Declaration - var）</strong><br>由名称和对应值（在预编译阶段所有变量值都是 undefined）组成的一个变量对象的属性被创建，如果变量名和已经声明的形参或者函数相同，则变量名不会干扰已经存在的这类属性，如果已经存在相同的变量名，则跳过当前声明的变量名。</p></li></ol><p><strong>注意：变量碰到相同名称的变量是忽略，函数碰到相同名称的函数是覆盖。</strong></p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span> <span class="title">_d</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   (<span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>当进入带有实参10的 foo 函数上下文时（预编译时，此时代码还没有执行），AO 结构如下：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AO(foo) = &#123;</span><br><span class="line"><span class="symbol">   a:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">   b:</span> undefined,</span><br><span class="line"></span><br><span class="line"><span class="symbol">   c:</span> undefined,</span><br><span class="line"><span class="symbol">   bar:</span> <span class="params">&lt;reference to FunctionDelcaration "bar"&gt;</span>,</span><br><span class="line"><span class="symbol">   d:</span> undefined </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，函数表达式 f 并不包含在活动对象 AO 内。<br>也就是说，只有函数声明会被包含在变量对象 VO 里面，函数表达式并不会影响变量对象。</p><p>行内函数表达式 _d 则只能在该函数内部可以使用， 也不会包含在 VO 内。</p><p>这之后，就会进入第2个阶段，代码执行阶段。</p><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>在这个阶段，AO/VO 已经有了属性（并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined）。</p><p>AO 在代码执行阶段被修改如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AO</span>[<span class="string">'c'</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="symbol">AO</span>[<span class="string">'d'</span>] = &lt;reference to <span class="symbol">FunctionDelcaration</span> <span class="string">"_d"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>再次要提醒大家，因为函数表达式 _d 已经保存到了声明的变量 d 上面，所以变量 d 仍然存在于 VO/AO 中。我们可以通 d() 来执行函数。但是函数表达式 f 却不存在于 VO/AO 中，也就是说，如果我们想尝试调用 f 函数，不管在函数定义前还是定义后，都会出现一个错误”f is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。</p><p>再来一个经典例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><p>这里为什么是这样的结果呢？</p><p>上边我们说过，在代码执行之前的预编译，会为变量对象生成一些属性，先是形参，再是函数声明，最后是变量，并且变量并不会影响同名的函数声明。</p><p>所以，在进入执行上下文时，AO/VO 结构如下：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">   <span class="keyword">x</span>: &lt;reference <span class="keyword">to</span> FunctionDeclaration <span class="string">"x"</span>&gt;</span><br><span class="line"></span><br><span class="line">   // 在碰到变量声明 <span class="keyword">x</span> 时，因为已经存在了函数声明 <span class="keyword">x</span> ，所以会忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>紧接着，在代码执行阶段，AO/VO 被修改如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AO</span>[<span class="string">'x'</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="symbol">AO</span>[<span class="string">'x'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p>希望大家可以好好理解变量对象，对于理解我们后边要讲的作用域链有很大的帮助。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>有一些文章说过：</p><blockquote><p>不管是使用 var 关键字（在全局上下文）还是不使用 var 关键字（在任何地方），都可以声明一个变量。</p></blockquote><p><strong>请记住，这是错误的观念。</strong></p><p><strong>任何时候，变量都只能通过使用 var 关键字来声明（ES6 之前）</strong>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面的赋值语句，仅仅是给全局对象创建了一个新属性（在在非严格模式，严格模式下会报错），但注意，它不是变量。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript 规范中变量的概念。</p><p>让我们通过一个例子来看一下两者的区别：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)<span class="comment">;        // undefined</span></span><br><span class="line">console.log(b)<span class="comment">;        // 报错，b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">b</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">var a = <span class="number">20</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>只要我们很好的理解了：变量对象、预编译阶段和执行代码阶段，就可以迅速的给出答案。</p><p>预编译（进入上下文）阶段：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">   a: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，因为 b 不是通过 var 声明的，所以这个阶段根本就没有 b ，b 只有在代码执行阶段才会出现。但是在这个例子中，还没有执行到 b 那就已经报错了。</p><p>我们稍微更改一下示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);             <span class="comment">// 10 代码执行阶段被创建</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b);        <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 20 代码执行阶段被修改</span></span><br></pre></td></tr></table></figure></p><p>关于变量，还有一个很重要的知识点。</p><p><strong>变量不能用 delete 操作符来删除。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);    <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> b);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);    <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：这个规则在 eval() 上下文中不起作用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节中我们讲了变量对象，下一节就是我们的重头戏 - <strong>作用域链</strong>。希望大家可以持续关注我，我们一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/variable_object.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;variable-object&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一节我们讨论了&lt;a href=&quot;http://www.jianshu.com/p/05641baa5134&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;执行上下文&lt;/a&gt;，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量对象&lt;/strong&gt;就是&lt;strong&gt;执行上下文&lt;/strong&gt;和&lt;strong&gt;作用域链&lt;/strong&gt;中间的桥梁。&lt;br&gt;剧透一下，神秘的 &lt;strong&gt;this&lt;/strong&gt; 就存在于执行上下文环境之中！&lt;br&gt;当然，之后我会单独用几节来彻底讲明白 &lt;strong&gt;this 到底是什么&lt;/strong&gt;（其实 this 很简单）。&lt;/p&gt;
&lt;p&gt;接下来，我们进入正文。&lt;/p&gt;
&lt;h3 id=&quot;执行上下文包含什么&quot;&gt;&lt;a href=&quot;#执行上下文包含什么&quot; class=&quot;headerlink&quot; title=&quot;执行上下文包含什么&quot;&gt;&lt;/a&gt;执行上下文包含什么&lt;/h3&gt;&lt;p&gt;一个执行上下文我们可以抽象的理解为对象（object）。&lt;br&gt;每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。&lt;/p&gt;
&lt;p&gt;我用一个结构图来说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180324/variable_object.png&quot; alt=&quot;执行上下文环境 object&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="执行上下文" scheme="//blog.liuxuan.site/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="变量对象" scheme="//blog.liuxuan.site/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Execution Context" scheme="//blog.liuxuan.site/tags/Execution-Context/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 05 - 执行上下文</title>
    <link href="//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/"/>
    <id>//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/</id>
    <published>2017-06-03T02:36:00.000Z</published>
    <updated>2018-04-21T15:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/execution_context.jpeg?imageView2/1/w/1000/h/400" alt="execution-context"></p><p>在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：<strong>执行上下文、变量对象和作用域链</strong>。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。</p><p>这一章我们就来讨论一下到底什么是<strong>执行上下文</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当 JS 引擎开始执行预编译生成的代码时，就会进入到一个<strong>执行上下文</strong>（Executable Code - 简称 <strong>EC</strong>）。</p><p>在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。</p><p>但是在逻辑上，我们可以将活动的执行上下文看成一个<strong>栈结构</strong>。栈底部永远是<strong>全局上下文（global context）</strong>，而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。</p><a id="more"></a><h3 id="可执行代码有几种"><a href="#可执行代码有几种" class="headerlink" title="可执行代码有几种"></a>可执行代码有几种</h3><p>前面说到当引擎执行到可执行代码的时候，就会将当前上下文压入上下文栈中。那么可执行的代码又分为几种？</p><p>在这里，我们先假设定义执行上下文栈是一个数组：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">EC</span> = []<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><strong>第一种可执行代码 – 全局代码：</strong><br>全局类型代码是在加载外部的 js 文件或者本地 <script></script> 标签中的代码。<br><strong>注意，在全局代码中，并不包含定义在全局环境 function 内的代码</strong>。</p><p>程序启动后进入初始化全局环境：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">EC</span> = [</span><br><span class="line">    globalContext</span><br><span class="line">]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><strong>第二种可执行代码 – 函数代码：</strong><br>当定义的函数被执行时，就进入了函数代码，当前函数上下文被压入 EC 栈中。<br><strong>注意，在函数代码中，也不包含定义在该函数内部环境 function 内的代码。</strong></p><p>例如：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>这个例子中的 EC 是什么样子的呢？</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 foo 函数</span></span><br><span class="line">EC = [</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 foo 内递归调用自己</span></span><br><span class="line">EC = [</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext - recursively,</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续递归调用自己</span></span><br><span class="line">EC = [</span><br><span class="line">  ......</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext - recursively2,</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext - recursively,</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归会不断调用下去，因为没有结束条件，所以这是一个死循环</span></span><br><span class="line"><span class="comment">// 所以，EC 只会不断增加新的上下文，但是却不会退出</span></span><br></pre></td></tr></table></figure><p>只有每次 <strong>return</strong> 的时候，才会退出当前执行上下文，相应上下文会从栈中弹出，栈指针会自动移动位置。</p><p><strong>注意，当函数没有明确指明 return 什么的时候，默认 return undefined</strong> 。 </p><p>如果有抛出的异常没有被截获的话，也有可能从一个或多个执行上下文中退出。当所有代码执行完以后，EC 中只会包含全局上下文（global context），当程序退出以后，全局上下文也会退出。</p><p><strong>第三种可执行代码 – eval 代码：</strong><br>eval 函数在调用的时候会产生上下文。<br>例如：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eval('var a = <span class="number">10</span>')<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">(<span class="name">function</span> foo () &#123;</span><br><span class="line">  eval('var b = <span class="number">20</span>')<span class="comment">;</span></span><br><span class="line">&#125;())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">alert(<span class="name">a</span>)<span class="comment">;    // 10</span></span><br><span class="line">alert(<span class="name">b</span>)<span class="comment">;    // ReferenceError，b is not defined</span></span><br></pre></td></tr></table></figure></p><p>这个例子中 EC 的变化如下：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var a = 10');</span></span><br><span class="line">EC = [</span><br><span class="line">  evalContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval 执行完毕</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数 foo</span></span><br><span class="line">EC = [</span><br><span class="line">  &lt;foo&gt; functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var b = 20');</span></span><br><span class="line">EC = [</span><br><span class="line">  evalContext,</span><br><span class="line">  &lt;foo&gt; functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval 执行完毕</span></span><br><span class="line">EC = [</span><br><span class="line">  &lt;foo&gt; functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 执行完毕</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>这就是一个典型的<strong>逻辑调用上下文栈</strong>。</p><p>在 setTimeout 和 setInterval 函数中的第一个参数也可以传入代码字符串，但是这个一般不会这么去用，所以这里也就不讨论了。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>执行上下文环境</strong>是我们了解<strong>变量对象</strong>和<strong>作用域链</strong>的基础，大家一定要好好理解（其实也并不难），下一节我们来讨论变量对象，相信会让大家有一定的收获。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/execution_context.jpeg?imageView2/1/w/1000/h/400&quot; alt=&quot;execution-context&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：&lt;strong&gt;执行上下文、变量对象和作用域链&lt;/strong&gt;。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。&lt;/p&gt;
&lt;p&gt;这一章我们就来讨论一下到底什么是&lt;strong&gt;执行上下文&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;当 JS 引擎开始执行预编译生成的代码时，就会进入到一个&lt;strong&gt;执行上下文&lt;/strong&gt;（Executable Code - 简称 &lt;strong&gt;EC&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。&lt;/p&gt;
&lt;p&gt;但是在逻辑上，我们可以将活动的执行上下文看成一个&lt;strong&gt;栈结构&lt;/strong&gt;。栈底部永远是&lt;strong&gt;全局上下文（global context）&lt;/strong&gt;，而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="执行上下文" scheme="//blog.liuxuan.site/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 04 - 提升</title>
    <link href="//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/"/>
    <id>//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/</id>
    <published>2017-05-10T02:36:00.000Z</published>
    <updated>2018-04-21T15:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/variable_lifting.jpg?imageView2/1/w/1000/h/400" alt="variable-lifting"></p><p>到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。</p><p>但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。</p><a id="more"></a><h3 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h3><p>先看代码：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = <span class="number">2</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var a<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.log(a)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>大家认为这里会输出什么？</p><p>有一些人认为是 undefined ，因为 <strong><em>var a;</em></strong> 是在 <strong><em>a = 2;</em></strong> 之后，所以会觉得 undefined 覆盖了 a 的值。但是，真正的结果是 2 。</p><p>再看一段代码：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var a = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">鉴于上一个例子，有些人会认为这里会输出 <span class="number">2</span> ，也有人认为由于 a 在使用前并没有声明，所以这里会报错。但是，这里的结果是 undefined 。</span><br><span class="line"></span><br><span class="line">之前讨论编译器的时候，我们知道 <span class="keyword">JS </span>引擎会在解释代码之前首先对其进行编译。编译阶段的第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</span><br><span class="line"></span><br><span class="line">因此，正确的思路是，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。</span><br><span class="line"></span><br><span class="line">当你看到 ***var a = <span class="number">2</span><span class="comment">;*** 时，JavaScript 实际上会将其看成两个声明：***var a;*** 和 ***a = 2;*** 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。</span></span><br><span class="line"></span><br><span class="line">所以，在第一个例子中，代码的等价形式是这样的：</span><br></pre></td></tr></table></figure></p><p>var a;</p><p>a = 2;</p><p>console.log(a);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二个例子中，代码的等价形式是这样的：</span><br></pre></td></tr></table></figure></p><p>var a;</p><p>console.log(a);</p><p>a = 2;<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个过程就好像是变量和函数声明从它们的代码中出现的位置被“移动”到了最上面。这个过程就叫作“提升”。</span><br><span class="line"></span><br><span class="line">*<span class="strong">*注意*</span><span class="strong">*，只有声明本身会被提升，而赋值操作和其他运行逻辑都会停留在原地，想象一下，如果提升会改变代码的执行顺序，那么会造成非常严重的破坏。</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">还有一点，函数声明会被提升，但是函数表达式不会被提升。</span></span><br></pre></td></tr></table></figure></p><p>foo();      // 报错，TypeError: foo is not a function，因为这里 foo 是 undefined，并不是一个函数</p><p>var foo = function foo() {<br>    // something else<br>}<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这段程序中的变量标识符 foo 被提升并分配给所在的作用域（在这里是全局作用域），因此 foo() 不会导致 <span class="built_in">ReferenceError</span> 。但是，foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会被赋值）。foo() 由于对 <span class="literal">undefined</span> 值进行函数调用而导致非法操作，所以会抛出 <span class="built_in">TypeError</span> 异常。</span><br><span class="line"></span><br><span class="line">同时，即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</span><br></pre></td></tr></table></figure></p><p>foo();<br>bar();</p><p>var foo = function bar () {<br>    // something else<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码经过提升后，实际上等价于：</span><br></pre></td></tr></table></figure></p><p>var foo;</p><p>foo();<br>bar();</p><p>foo = function () {<br>    var bar = …self…<br>    // something else<br>};<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 函数优先</span><br><span class="line">函数声明和变量声明都会被提升。但是一个值得注意的细节是，**函数声明会首先被提升，然后才是变量。**</span><br><span class="line"></span><br><span class="line">考虑如下代码：</span><br></pre></td></tr></table></figure></p><p>foo();      // 1</p><p>var foo;</p><p>function foo () {<br>   console.log(1);<br>}</p><p>foo = function () {<br>   console.log(2);<br>};<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里会输出 <span class="number">1</span> 而不是 <span class="number">2</span> 。这段代码其实等价于：</span><br></pre></td></tr></table></figure></p><p>function foo () {<br>   console.log(1);<br>}</p><p>foo();      // 1</p><p>foo = function () {<br>   console.log(2);<br>};<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***<span class="keyword">var</span> foo;*** 尽管出现在 function foo() <span class="meta">&#123;...&#125;</span> 声明之前，但是它是重复声明，所以会被编译器忽略，因为函数声明会被提升到变量声明之前。</span><br><span class="line"></span><br><span class="line">注意，尽管重复的 <span class="keyword">var</span> 声明会被忽略，但重复的函数声明却会覆盖前一个同名函数。</span><br></pre></td></tr></table></figure></p><p>foo();      // 3</p><p>function foo () {<br>   console.log(1);<br>}</p><p>var foo = function () {<br>   console.log(2);<br>};      </p><p>foo();        // 2</p><p>function foo () {<br>   cosole.log(3);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个例子充分说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。上面那个例子，等价于：</span><br></pre></td></tr></table></figure></p><p>function foo () {<br>   cosole.log(3);<br>}</p><p>foo();      // 3</p><p>foo = function () {<br>   console.log(2);<br>};      </p><p>foo();        // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还有一些人会犯如下错误：</span><br></pre></td></tr></table></figure></p><p>foo();      // 2</p><p>var a = true;</p><p>if (a) {<br>   function foo () {<br>      console.log(1);<br>   }<br>} else {<br>   function foo () {<br>      console.log(2);<br>   }<br>}<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为 <span class="keyword">if</span> 并没有块作用域，所以这里的函数声明会提升到其作用域最前边，而后一个 <span class="keyword">function</span> <span class="title">声明会覆盖前一个，所以这里结果是</span> 2 。这里代码等价如下：</span><br></pre></td></tr></table></figure></p><p>function foo () {<br>   console.log(2);<br>}</p><p>var a;</p><p>foo();      // 2</p><p>a = true;</p><p>if (a) {</p><p>} else {</p><p>}<br><code>`</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们习惯将 <strong><em>var a = 2;</em></strong> 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 <strong><em>var a;</em></strong> 和 <strong><em>a = 2;</em></strong> 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被处理（预编译）。可以将这个过程想象成所有的声明（变量和函数）都会被“移动”到各自的作用域的最顶端，这个过程叫作<strong>提升</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/variable_lifting.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;variable-lifting&quot;&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。&lt;/p&gt;
&lt;p&gt;但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="作用域" scheme="//blog.liuxuan.site/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
</feed>
