<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuxuan的博客</title>
  <icon>https://www.gravatar.com/avatar/19bc11b7d38a5520912b73217b1993fc</icon>
  <subtitle>苍山如海, 残阳如血</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//blog.liuxuan.site/"/>
  <updated>2018-04-06T18:39:57.000Z</updated>
  <id>//blog.liuxuan.site/</id>
  
  <author>
    <name>liuxuan</name>
    <email>619962351@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建 karma + jasmine 测试环境</title>
    <link href="//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/"/>
    <id>//blog.liuxuan.site/2018/04/03/front_end_test_karma_jasmine/</id>
    <published>2018-04-03T02:36:00.000Z</published>
    <updated>2018-04-06T18:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/test_karma.jpg?imageView2/1/w/1000/h/400" alt="test-karma"></p><p>在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。</p><h3 id="什么是-karma"><a href="#什么是-karma" class="headerlink" title="什么是 karma"></a>什么是 karma</h3><p>karma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。</p><h3 id="安装-karma"><a href="#安装-karma" class="headerlink" title="安装 karma"></a>安装 karma</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm  install karma -D</span></span><br></pre></td></tr></table></figure><p>这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="keyword">node</span><span class="title">-modules</span>/.bin/karma init</span><br></pre></td></tr></table></figure><p>这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install karma-cli -g</span></span><br></pre></td></tr></table></figure></p><p>以后就可以在任何路径执行 <strong>karma start</strong> 并且运行的 karma 都是在当前项目下安装的版本。</p><a id="more"></a><p>在 init 时会让你选择一些配置项：</p><p><strong>test framework</strong><br>我这里选择的是jasmine，它是一款JavaScript断言测试库<br><strong>use Require.js</strong><br>根据个人情况，我选择的是no<br><strong>capture any browsers automatically</strong><br>选择浏览器，我选择的是无头浏览器PhantomJS<br><strong>location of your source files</strong><br>为空<br><strong>any of files included by the previous patterns be excluted</strong><br>为空<br><strong>karma to watch all files and run the tests on change</strong><br>是否监测，我选择的是no</p><p>在选择完所有配置项后，会自动生成karma.conf.js配置文件。</p><h3 id="根据配置项的选择安装插件"><a href="#根据配置项的选择安装插件" class="headerlink" title="根据配置项的选择安装插件"></a>根据配置项的选择安装插件</h3><p><strong>（1）</strong> 测试框架选择的是jasmine，安装步骤如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span><span class="keyword">jasmine-core </span>karma-<span class="keyword">jasmine </span>-D</span><br></pre></td></tr></table></figure></p><p>这里要装两个，一个是jasmine的核心，另一个是karma对jasmine的封装。</p><p><strong>（2）</strong> 浏览器选择的是PhantomJS，安装步骤如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install karma-phantomjs-launcher -D</span></span><br></pre></td></tr></table></figure></p><p><strong>（3）</strong> 如果涉及到对以ES6编写的代码进行测试，就要安装Babel及其相关插件：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span><span class="keyword">babel-cli </span><span class="keyword">babel-preset-env </span><span class="keyword">babel-plugin-transform-es2015-modules-umd </span>-D</span><br><span class="line">$ npm <span class="keyword">install </span>karma-<span class="keyword">babel-preprocessor </span>-D</span><br></pre></td></tr></table></figure></p><p><strong>（4）</strong> 安装生成代码覆盖率报告的插件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install karma-coverage -D</span></span><br></pre></td></tr></table></figure></p><h3 id="修改karma配置文件"><a href="#修改karma配置文件" class="headerlink" title="修改karma配置文件"></a>修改karma配置文件</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// karma.<span class="keyword">conf</span>.js</span><br><span class="line"></span><br><span class="line">module.exports = <span class="function"><span class="keyword">function</span><span class="params">(config)</span> &#123;</span></span><br><span class="line">  config.<span class="keyword">set</span>(&#123;</span><br><span class="line">    basePath: <span class="string">''</span>,</span><br><span class="line">    framework<span class="variable">s:</span> [<span class="string">'jasmine'</span>],</span><br><span class="line">    <span class="keyword">file</span><span class="variable">s:</span> [</span><br><span class="line">      <span class="string">'./src/**/*.js'</span>,</span><br><span class="line">      <span class="string">'./test/**/*.spec.js'</span></span><br><span class="line">    ],</span><br><span class="line">    exclude: [</span><br><span class="line">    ],</span><br><span class="line">    preprocessor<span class="variable">s:</span> &#123;</span><br><span class="line">      <span class="string">'./src/**/*.js'</span>: [<span class="string">'babel'</span>],</span><br><span class="line">      <span class="string">'./test/**/*.spec.js'</span>: [<span class="string">'babel'</span>, <span class="string">'coverage'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    reporter<span class="variable">s:</span> [<span class="string">'progress'</span>, <span class="string">'coverage'</span>],</span><br><span class="line">    coverageReporter: &#123;</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">'html'</span>,</span><br><span class="line">      dir: <span class="string">'coverage/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    por<span class="variable">t:</span> <span class="number">9876</span>,</span><br><span class="line">    color<span class="variable">s:</span> true,</span><br><span class="line">    logLeve<span class="variable">l:</span> config.LOG_INFO,</span><br><span class="line">    autoWatch: false,</span><br><span class="line">    browser<span class="variable">s:</span> [<span class="string">'PhantomJS'</span>],</span><br><span class="line">    singleRun: true,</span><br><span class="line">    concurrency: Infinity</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Babel配置文件：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">.babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-es2015-modules-umd"</span>],</span><br><span class="line">  <span class="string">"auxiliaryCommentBefore"</span>: <span class="string">"istanbul ignore next"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="写测试文件"><a href="#写测试文件" class="headerlink" title="写测试文件"></a>写测试文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PraiseButton.spec.js</span></span><br><span class="line"><span class="keyword">import</span> PraiseButton <span class="keyword">from</span> <span class="string">'../src/PraiseButton.js'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试点赞组件'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'addOne() 函数'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testPraiseButton = <span class="keyword">new</span> PraiseButton();</span><br><span class="line">    testPraiseButton.addOne();</span><br><span class="line"></span><br><span class="line">    expect(testPraiseButton.countNum).toBe(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> karma start</span></span><br></pre></td></tr></table></figure><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>按照上述步骤，大家应该可以配置好自己的 karma + jasmine 测试环境，如果遇到问题或者文中有写错的地方，欢迎大家来讨论。文章末尾是需要安装模块的链接，大家可以一键直达。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>karma官网<br><a href="https://karma-runner.github.io/2.0/intro/installation.html" target="_blank" rel="noopener">https://karma-runner.github.io/2.0/intro/installation.html</a><br>karma-cli<br><a href="https://www.npmjs.com/package/karma-cli" target="_blank" rel="noopener">https://www.npmjs.com/package/karma-cli</a><br>karma-jasmine<br><a href="https://www.npmjs.com/package/karma-jasmine" target="_blank" rel="noopener">https://www.npmjs.com/package/karma-jasmine</a><br>jasmine-core<br><a href="https://www.npmjs.com/package/jasmine-core" target="_blank" rel="noopener">https://www.npmjs.com/package/jasmine-core</a><br>karma-coverage<br><a href="https://www.npmjs.com/package/karma-coverage" target="_blank" rel="noopener">https://www.npmjs.com/package/karma-coverage</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/test_karma.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;test-karma&quot;&gt;&lt;/p&gt;
&lt;p&gt;在前端开发的过程中，我们会写很多的功能函数，这样就会涉及到对这些功能函数进行单元测试，而karma就是一个很好用的可以在浏览器环境中进行测试的集成工具。&lt;/p&gt;
&lt;h3 id=&quot;什么是-karma&quot;&gt;&lt;a href=&quot;#什么是-karma&quot; class=&quot;headerlink&quot; title=&quot;什么是 karma&quot;&gt;&lt;/a&gt;什么是 karma&lt;/h3&gt;&lt;p&gt;karma 是由Angular团队开发的一款测试工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。&lt;/p&gt;
&lt;h3 id=&quot;安装-karma&quot;&gt;&lt;a href=&quot;#安装-karma&quot; class=&quot;headerlink&quot; title=&quot;安装 karma&quot;&gt;&lt;/a&gt;安装 karma&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm  install karma -D&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里安装到项目路径下就可以了（-D 是 –save-dev 的简写）。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ./&lt;span class=&quot;keyword&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;title&quot;&gt;-modules&lt;/span&gt;/.bin/karma init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里如果不想每次都执行本地路径下的 karma 命令，可以在全局安装 karma-cli&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm install karma-cli -g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以后就可以在任何路径执行 &lt;strong&gt;karma start&lt;/strong&gt; 并且运行的 karma 都是在当前项目下安装的版本。&lt;/p&gt;
    
    </summary>
    
      <category term="前端测试" scheme="//blog.liuxuan.site/categories/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="//blog.liuxuan.site/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="karma" scheme="//blog.liuxuan.site/tags/karma/"/>
    
      <category term="jasmine" scheme="//blog.liuxuan.site/tags/jasmine/"/>
    
      <category term="phantomJS" scheme="//blog.liuxuan.site/tags/phantomJS/"/>
    
      <category term="Babel" scheme="//blog.liuxuan.site/tags/Babel/"/>
    
      <category term="ES6" scheme="//blog.liuxuan.site/tags/ES6/"/>
    
      <category term="System" scheme="//blog.liuxuan.site/tags/System/"/>
    
      <category term="node" scheme="//blog.liuxuan.site/tags/node/"/>
    
      <category term="npm" scheme="//blog.liuxuan.site/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 07 - 标签声明（Label Statement）</title>
    <link href="//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/"/>
    <id>//blog.liuxuan.site/2018/03/10/javascript_07_label_statement/</id>
    <published>2018-03-10T02:36:00.000Z</published>
    <updated>2018-04-06T18:38:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/label_statement.jpg?imageView2/1/w/1000/h/400" alt="label-statement"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>假设有这么一道题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br></pre></td></tr></table></figure></p><p>我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？</p><p>可能有的同学会想到这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">            <span class="keyword">if</span> (j === <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br></pre></td></tr></table></figure></p><p>这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？</p><a id="more"></a><p>再看一个例子，你也一定见到过这样的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设str是你通过ajax接收到的JSON串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"name": "liu", "age": 20&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">'('</span> + str + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></p><p>那么，你有没有想过 eval 里面为什么要加上括号呢？如果不加又是什么情况？（<em>提前剧透，不加括号这里会报错哦</em>）。</p><p><strong>接着往下看，当你读完这篇文章的时候，心中的疑惑会完全解开。</strong></p><h3 id="Label-Statement"><a href="#Label-Statement" class="headerlink" title="Label Statement"></a>Label Statement</h3><p>学过C语言的同学知道，C的语法中有一个语句叫：goto，同时老师也多次强调不让我们使用goto语句，因为会大大影响程序的<strong>可读性</strong>和<strong>可维护性</strong>。</p><p>我们先来看一段C语言的goto代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>, b=<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) &#123;</span><br><span class="line">        <span class="keyword">goto</span> aa;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line">    </span><br><span class="line">    aa: <span class="built_in">printf</span>(<span class="string">"s"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 a &lt; b 的时候，这里会打印字符串 “hello”，然后结束。<br>当 a &gt; b 的时候，由于goto语句的作用，就会跳过 print(“hello”)，直接跳到 aa 标签声明的代码块中，打印字符 “s”，然后结束。</p><p>这就是goto语句的作用，通过标签声明一个代码块，然后在任何地方都可以执行 goto ‘labe’ 来进行程序跳转。</p><p>显而易见，这样的写法，违背了程序顺序执行的原则，会跳来跳去，最后导致根本无法维护，所以，记住老师的话，<strong>不要使用 goto 语句</strong>。</p><p>那么，看完了C语言中的 goto 语句，和我们的 JavaScript 又有什么关系呢？<br>这就引出了今天的主题：Label Statement，它就是 JS 中的 goto 语句。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先明确一个原则，<strong>在JavaScript中，语句优先</strong>。<br>也就是说，如果一段代码既能够以语句的方式解析，也能用语法的方式解析，在JS中，会优先按语句来解析。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">a </span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，在JS中的执行结果是什么呢？<br><strong>大家思考2分钟….</strong></p><hr><hr><p>好，2分钟已过，大家有结果了吗？<br>千万不要在浏览器的控制台中去写这段代码，虽然结果和你开始想的结果一样，<br><strong>但是，它是错误的。</strong></p><p>这是在console控制台中执行的结果：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_console.png?imageView2/1/w/400" alt="label-console图片"></p><p>这是在watch中的执行结果：</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_watch.png?imageView2/1/w/400" alt="clipboard.png"></p><p>可以看到两个结果是不一样的。<br>console是经过处理的这里不能相信，watch是直接JS的运行环境执行后的结果，是正确的。</p><p>为什么 { a : 1 } 结果会是 1 呢？</p><p>我换一个写法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">a </span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相信有的同学已经明白了，在JS中，{}既可以代表代码块，又可以作为Object的语法标志。<br>那么我们前面说过，<strong>JS是语句优先的，当一段代码既可以按照语句解析，又可以按照语法解析的时候，会优先按语句解析。</strong></p><p>当把{}当做是代码块的时候，里面的 a : 1，是不是很像C语言goto语句的标签声明呢？<br>开头我们提出的第一个问题，如果用这种方式来解决，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aa : &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">            <span class="keyword">if</span> (j === <span class="number">2</span>) <span class="keyword">break</span> aa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br></pre></td></tr></table></figure></p><p>aa是标签声明，包裹一个代码块，break 的作用是跳出当前的循环，本来是无法跳出外面那层for循环的，但是 break aa，这里跳出了整个代码块。</p><p><strong>当然，这种写法是完全不提倡的，这里只是用来说明JS中的Label Statement这个特性，大家千万不要这样写代码。</strong></p><p>再来看开头提出的第二个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设str是你通过ajax接收到的JSON串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'&#123;"name": "liu", "age": 20&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">'('</span> + str + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></p><p>我们知道，eval(str)会把接收到的字符串在当前上下文中执行，如果不加括号：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">eval</span><span class="params">('&#123;<span class="string">"name"</span>: <span class="string">"liu"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;&#125;')</span></span></span><br></pre></td></tr></table></figure></p><p>这里的执行语句就会变成：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"liu"</span>, <span class="attr">"age"</span> : <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>{}按照语句解析，执行里面的逗号表达式，我们知道逗号表达式要求每一项都必须是表达式，输出最后一项的结果，而这里不满足要求，所以会报错。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_watch2.png?imageView2/1/w/400" alt="label-watch2"></p><p>但是加上括号就变成了这样：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"liu"</span>, <span class="string">"age"</span> : <span class="number">20</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>小括号可以把里面的内容当做表达式来解析，那么里面的内容就是一个对象了。</p><p><img src="http://p54fus2hp.bkt.clouddn.com/blog/20180402/label_watch3.png?imageView2/1/w/400" alt="label-watch2"></p><p>这也是立即执行函数的原理：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span> () &#123;</span><br><span class="line">    console.log(<span class="name">'IIFE'</span>)<span class="comment">;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>小括号把函数声明变成了函数表达式，后面再跟一个小括号表示调用。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这里通过几个例子，引出了 JavaScript 的标签声明语句（Label Statement），从而解释了一些我们常用写法的原理。</p><p><strong>以后万一有人问你为什么 eval() 解析JSON要加括号呢？</strong><br><strong>这回知道怎么说了吧。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/label_statement.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;label-statement&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;假设有这么一道题：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;done&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我想要当 j = 2 的时候就退出所有的for语句，打印最后的 done ，你会怎么做？&lt;/p&gt;
&lt;p&gt;可能有的同学会想到这样：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (j === &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;done&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样可以实现，但是又多写了一个函数，那么有没有别的办法呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="Label Statement" scheme="//blog.liuxuan.site/tags/Label-Statement/"/>
    
      <category term="C语言" scheme="//blog.liuxuan.site/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Goto语句" scheme="//blog.liuxuan.site/tags/Goto%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>HTML - 移动端 meta viewport</title>
    <link href="//blog.liuxuan.site/2017/12/10/html_meta_viewport/"/>
    <id>//blog.liuxuan.site/2017/12/10/html_meta_viewport/</id>
    <published>2017-12-10T02:36:00.000Z</published>
    <updated>2018-04-06T18:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/meta_viewport.jpg?imageView2/1/w/1000/h/400" alt="meta-viewport"></p><p>我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">user-scalable=0"&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 <strong>viewport 到底是什么</strong>。</p><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>在讨论 viewport 之前，我们需要理解一些单位的概念：</p><ul><li><strong>设备像素 / 物理像素（physical pixels）</strong><br>是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。</li></ul><a id="more"></a><ul><li><p><strong>CSS 像素（css pixel） / 密度独立像素（density independent pixels - dip）</strong><br>CSS 像素是 web 编程中的概念，是抽象的，不是实际存在的。它是独立于设备用于逻辑上衡量像素的单位，所以又叫密度独立像素。dip 有时候也缩写为 dp 。</p></li><li><p><strong>屏幕尺寸</strong><br>指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。</p></li><li><p><strong>屏幕像素密度（pixels per inch - ppi）</strong><br>指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的 ppi = √(1920^2+1080^2) / 5.5 ≈ 401ppi 。也就是说它每英寸可以显示 440 个物理像素点。</p></li><li><p><strong>设备像素比</strong><br>指物理像素和密度独立像素的比值。<br>window.devicePixelRatio = 物理像素 / dip。<br>可以通过 window.devicePixelRatio 获得，该属性被所有WebKit浏览器以及Opera所支持。</p></li></ul><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p>viewport 是指 web 页面上用户的可见区域。</p><p>viewport 的大小是和设备相关的，在移动端例如手机上，viewport 的大小是比 PC 端要小的，一般无论手机还是平板，默认的 viewport 大小都是 980px 。<br>刚开始 web 页面仅仅是在 PC 端进行查看的，但是后来随着移动互联网的发展，越来越多的 web 访问是通过移动端进行的，但是因为 PC 的 viewport 要比移动端大，所以为了快速修复这个问题，移动端的浏览器默认只是把整个页面等比例缩小到移动端的 viewport 大小。</p><p>这样做的后果就是，用户看到的是一个缩小版的整个页面，字体、图标和内容等等都非常小，想要点击或者查看都需要去放大页面进行操作，放大页面之后就会出现横向滚动条，这对用户体验来说是非常不好的。</p><p>那么回到我们最开始写的 meta 标签：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">user-scalable=0"&gt;</span></span><br></pre></td></tr></table></figure></p><p>device-width 是指这个设备最理想的 viewport 宽度。iPhone6 之前的 device-width 都是 320px ，iPhone6 是 375px ，iPhone6 Plus 是 414px ，<strong>而这个 device-width 是和 CSS像素（也叫密度独立像素 dip）是相同的</strong>。也就是说，web 页面中的 CSS像素的值等于 device-width 时，对应到手机上就是占满全屏的宽度。</p><p>安卓手机的 device-width 有320px、360px 和 384px 等等，不同的设备 device-width 是不一样的。</p><p>initial-scale=1.0 是指初始化的时候缩放大小是1，也就是不缩放。</p><p>user-scalable=0 是指禁止用户进行缩放。</p><p>maximum-scale=1.0 是指用户最大缩放大小是1，其实在禁止用户缩放以后，这一句可以省略。</p><p><strong>在设计人员为移动端设计页面的时候经常可以听到2倍图和3倍图这些词语，这又是什么意思呢，我们以 iPhone6 举例</strong>：</p><p>iPhone6 的分辨率（也就是物理像素）是 1334*750 像素，它的 device-width 是 375px 。</p><p>如果我们将屏幕横向分成 375 份，CSS 中 1px 占用的1份，因为屏幕就那么大，CSS中 width 等于 375px 时横向就会占满全屏，但是实际上<strong>存在的物理像素点横向是750个</strong> ，所以在我们写 CSS 时 1px 对应到屏幕上是占用了2个物理像素点。</p><p>如果我们不写 <strong><em>width=device-width</em></strong> 这一句的话，默认 viewport 宽是 980px 。那么把 iPhone6 的屏幕横向分成980份，CSS 中 1px 占用1份，但是真正的像素点横向只有750个，这就意味着，实际上渲染出来的宽度是 75/98 个像素大小（只是理论上）。</p><p>设计人员在设计原型图的时候以 750px 的宽度为基准，我们在写 CSS的时候缩写一半来使用，但是在渲染的时候 1px 等于 2px 的物理像素，所以整个图片还是按 750px 的宽度来显示的，不会失真。</p><p>如果设计人员以 375px 的宽度为基准，那么我们在使用的时候直接把设计图中的像素宽度用在 CSS 中，那么在渲染的时候，1px 等于 2px 的物理像素，相当于图片会放大2倍，就会产生失真。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在添加 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">  之后，移动端的 viewport 宽度会从默认的 980px 变成各个设备的 device-width 。</p><p>CSS 中的 100% 就等于 device-width 。 </p><p>知道了这些，我们就可以结合别的知识，为页面进行响应式布局了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/meta_viewport.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;meta-viewport&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：&lt;br&gt;&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;meta &lt;span class=&quot;attr&quot;&gt;name=&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content=&quot;width=device-width,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;initial-scale=1.0,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;maximum-scale=1.0,&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;user-scalable=0&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。今天我们就花点时间来彻底搞明白 &lt;strong&gt;viewport 到底是什么&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;单位&quot;&gt;&lt;a href=&quot;#单位&quot; class=&quot;headerlink&quot; title=&quot;单位&quot;&gt;&lt;/a&gt;单位&lt;/h3&gt;&lt;p&gt;在讨论 viewport 之前，我们需要理解一些单位的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备像素 / 物理像素（physical pixels）&lt;/strong&gt;&lt;br&gt;是指屏幕的实际物理像素点，比如 iPhone6 Plus 是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML" scheme="//blog.liuxuan.site/categories/HTML/"/>
    
    
      <category term="HTML" scheme="//blog.liuxuan.site/tags/HTML/"/>
    
      <category term="meta" scheme="//blog.liuxuan.site/tags/meta/"/>
    
      <category term="viewport" scheme="//blog.liuxuan.site/tags/viewport/"/>
    
      <category term="pt" scheme="//blog.liuxuan.site/tags/pt/"/>
    
      <category term="dip" scheme="//blog.liuxuan.site/tags/dip/"/>
    
      <category term="ppi" scheme="//blog.liuxuan.site/tags/ppi/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 06 - 变量对象</title>
    <link href="//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/"/>
    <id>//blog.liuxuan.site/2017/08/10/javascript_06_variable_object/</id>
    <published>2017-08-10T02:36:00.000Z</published>
    <updated>2018-04-06T18:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/variable_object.jpg?imageView2/1/w/1000/h/400" alt="variable-object"></p><p>上一节我们讨论了<a href="http://www.jianshu.com/p/05641baa5134" target="_blank" rel="noopener">执行上下文</a>，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。</p><p><strong>变量对象</strong>就是<strong>执行上下文</strong>和<strong>作用域链</strong>中间的桥梁。<br>剧透一下，神秘的 <strong>this</strong> 就存在于执行上下文环境之中！<br>当然，之后我会单独用几节来彻底讲明白 <strong>this 到底是什么</strong>（其实 this 很简单）。</p><p>接下来，我们进入正文。</p><h3 id="执行上下文包含什么"><a href="#执行上下文包含什么" class="headerlink" title="执行上下文包含什么"></a>执行上下文包含什么</h3><p>一个执行上下文我们可以抽象的理解为对象（object）。<br>每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。</p><p>我用一个结构图来说明：</p><p><img src="http://image.liuxuan.site/blog/20180324/variable_object.png" alt="执行上下文环境 object"></p><a id="more"></a><p><strong>Variable Object</strong> 就代表变量对象。<br><strong>Scope Chain</strong> 代表作用域链。<br><strong>thisValue</strong> 代表神秘的 this 。</p><p>作用域链和 this 留到后面再讲，今天我们先来弄明白<strong>变量对象</strong>。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><blockquote><p>A variable object is a scope of data related with the execution context. It’s a special object associated with the context and which stores variables and function declarations are being defined within the context.</p></blockquote><blockquote><p>变量对象(variable object) 是与执行上下文相关的数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</p></blockquote><p><strong>变量对象</strong>（Variable Object – 简写 VO）是一个抽象的概念，指代与执行上下文相关的特殊对象，它存储着在上下文中声明的：</p><ul><li><strong>变量</strong>（var）</li><li><strong>函数声明</strong> （function declaration，简写 FD）</li><li><strong>函数的形参</strong>（arguments）</li></ul><p>我们假设变量对象为一个普通 ECMAScript 对象：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">VO</span> = &#123;&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>就像前面讲过的，VO 是执行上下文的一个属性：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line"><span class="symbol">  VO:</span> &#123;</span><br><span class="line">    <span class="comment">// 上下文数据 （vars, FD, arguments）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为变量对象是一个抽象的概念，所以并不能通过变量对象的名称直接访问，但是却可以通过别的方法来间接访问变量对象，例如在全局上下文环境的变量对象会有一个属性 window (DOM 中) 可以引用变量对象自身，全局上下文环境的另一个属性 this 也指向全局上下文环境的变量对象。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">exp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>这里对应的变量对象是：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局上下文环境的变量对象</span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">   <span class="comment">// 一些全局环境初始化时系统自动创建的属性： Math、String、Date、parseInt等等</span></span><br><span class="line">   ···</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 全局上下文的变量对象中有一个属性可以访问到自身，在浏览器中这个属性是 window ，在 node 中这个属性是 global</span></span><br><span class="line"><span class="symbol">   window:</span> global</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自己定义的属性</span></span><br><span class="line"><span class="symbol">   a:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">   foo:</span> <span class="params">&lt;reference to function&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 函数上下文的变量对象</span></span><br><span class="line">VO(foo functionContext) = &#123;</span><br><span class="line"><span class="symbol">   num:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">   b:</span> <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>注意：函数表达式并不包括在变量对象中。</strong></p><h3 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h3><p>执行上下文包括：<strong>全局上下文、函数上下文和 eval() 上下文。</strong></p><h4 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h4><p>这里我们先来了解一下什么是全局对象：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局对象（<span class="keyword">global</span> <span class="keyword">object</span>）是指在进入任何执行上下文之前就已经创建了的对象。</span><br><span class="line">这个对象只有一份，它的属性在程序中的任何地方都可以访问，全局对象的生命周期终止于程序退出的那一刻。</span><br></pre></td></tr></table></figure></p><p>全局对象初始化时系统将创建并初始化一系列原始属性，例如：Math、String、Date、parseInt、window等等，之后是我们在全局上下文中自己定义的全局变量。在 DOM 中，全局对象的 window 属性可以引用全局对象自身，全局上下文环境的 this 属性也可以引用全局对象。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局执行上下文环境</span></span><br><span class="line">EC(globalContext) = &#123;</span><br><span class="line">   <span class="comment">// 全局对象（全局上下文环境的变量对象） </span></span><br><span class="line">   <span class="built_in">global</span>: &#123;</span><br><span class="line">      Math: &lt;<span class="params">...</span>&gt;,</span><br><span class="line">      <span class="built_in">String</span>: &lt;<span class="params">...</span>&gt;,</span><br><span class="line">      <span class="params">...</span></span><br><span class="line">      <span class="params">...</span></span><br><span class="line">      window: <span class="built_in">global</span>     <span class="comment">// 引用全局对象自身</span></span><br><span class="line">   &#125;,</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// this 属性</span></span><br><span class="line">   this: <span class="built_in">global</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 作用域链</span></span><br><span class="line">   <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);               <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);        <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);          <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>因此，在全局上下文环境中，变量对象用全局对象来表示。</p><h4 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h4><p>在函数上下文中，变量对象用活动对象 AO（Active Object）来表示。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">VO</span><span class="params">(functionContext)</span></span> = AO</span><br></pre></td></tr></table></figure></p><p>活动对象是在进入函数上下文时刻被创建的，它是通过函数的 arguments 属性进行初始化。arguments 也是一个对象。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">   arguments: &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>arguments 是活动对象的一个属性，它也是一个对象，包括以下属性：</p><ol><li>callee - 指向当前函数的引用</li><li>length - 真正传递的参数个数</li><li>properties-indexes - index 是字符串类型的整数，例如”1”: “aa”，类似于数组类型，也可以通过arguments[1]来访问，但是不能用数组的方法（push, pop等等）。另外，properties-indexes 的值和实际传递进来的参数之间是共享的，一个改变，另一个也随之改变。</li></ol><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 声明的函数参数数量</span></span><br><span class="line">   <span class="built_in">console</span>.log(foo.length);      <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 实际传递进来的参数数量</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// arguments 的 callee 属性指向当前函数</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === foo)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 参数共享</span></span><br><span class="line">   <span class="built_in">console</span>.log(x === <span class="built_in">arguments</span>[<span class="number">0</span>]);      <span class="comment">// true</span></span><br><span class="line">   <span class="built_in">console</span>.log(x);      <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(x);   <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">   x = <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);    <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 但是注意，没有传递进来的参数 z ，和第3个索引值是不共享的</span></span><br><span class="line">   z = <span class="number">40</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);      <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(z);      <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><h3 id="代码是如何被处理的"><a href="#代码是如何被处理的" class="headerlink" title="代码是如何被处理的"></a>代码是如何被处理的</h3><p>在第1节中我们讲过<a href="http://www.jianshu.com/p/04fe77235dac" target="_blank" rel="noopener">js 代码的编译过程</a>，其中有一步叫作<strong>预编译</strong>，是说在代码执行前的几微秒会首先对代码进行编译，形成词法作用域，然后执行。</p><p>那么执行上下文的代码就就可以分成两个阶段来处理：</p><ol><li>进入执行上下文（预编译）</li><li>执行代码</li></ol><p>而变量对象的修改变化和这两个阶段是紧密相关的。<br>并且所有类型的执行上下文都会有这2个阶段。</p><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当引擎进入执行上下文时（代码还未执行），VO 里已经包含了一些属性：</p><ol><li><p><strong>函数的所有形参（如果是函数执行上下文）</strong><br>由名称和对应值组成的一个变量对象的属性被创建，如果没有传递对应的实参，那么由名称和 undefined 组成的一种变量对象的属性也会被创建。</p></li><li><p><strong>所有的函数声明（Function Declaration - FD）</strong><br>由名称和对应值（函数对象 function object）组成的一个变量对象的属性被创建，如果变量对象已经存在相同名称函数的属性，则完全替换这个属性。</p></li><li><p><strong>所有的变量声明（Variable Declaration - var）</strong><br>由名称和对应值（在预编译阶段所有变量值都是 undefined）组成的一个变量对象的属性被创建，如果变量名和已经声明的形参或者函数相同，则变量名不会干扰已经存在的这类属性，如果已经存在相同的变量名，则跳过当前声明的变量名。</p></li></ol><p><strong>注意：变量碰到相同名称的变量是忽略，函数碰到相同名称的函数是覆盖。</strong></p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span> <span class="title">_d</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">   (<span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>当进入带有实参10的 foo 函数上下文时（预编译时，此时代码还没有执行），AO 结构如下：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AO(foo) = &#123;</span><br><span class="line"><span class="symbol">   a:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol">   b:</span> undefined,</span><br><span class="line"></span><br><span class="line"><span class="symbol">   c:</span> undefined,</span><br><span class="line"><span class="symbol">   bar:</span> <span class="params">&lt;reference to FunctionDelcaration "bar"&gt;</span>,</span><br><span class="line"><span class="symbol">   d:</span> undefined </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意，函数表达式 f 并不包含在活动对象 AO 内。<br>也就是说，只有函数声明会被包含在变量对象 VO 里面，函数表达式并不会影响变量对象。</p><p>行内函数表达式 _d 则只能在该函数内部可以使用， 也不会包含在 VO 内。</p><p>这之后，就会进入第2个阶段，代码执行阶段。</p><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>在这个阶段，AO/VO 已经有了属性（并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined）。</p><p>AO 在代码执行阶段被修改如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AO</span>[<span class="string">'c'</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="symbol">AO</span>[<span class="string">'d'</span>] = &lt;reference to <span class="symbol">FunctionDelcaration</span> <span class="string">"_d"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>再次要提醒大家，因为函数表达式 _d 已经保存到了声明的变量 d 上面，所以变量 d 仍然存在于 VO/AO 中。我们可以通 d() 来执行函数。但是函数表达式 f 却不存在于 VO/AO 中，也就是说，如果我们想尝试调用 f 函数，不管在函数定义前还是定义后，都会出现一个错误”f is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。</p><p>再来一个经典例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);      <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><p>这里为什么是这样的结果呢？</p><p>上边我们说过，在代码执行之前的预编译，会为变量对象生成一些属性，先是形参，再是函数声明，最后是变量，并且变量并不会影响同名的函数声明。</p><p>所以，在进入执行上下文时，AO/VO 结构如下：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">   <span class="keyword">x</span>: &lt;reference <span class="keyword">to</span> FunctionDeclaration <span class="string">"x"</span>&gt;</span><br><span class="line"></span><br><span class="line">   // 在碰到变量声明 <span class="keyword">x</span> 时，因为已经存在了函数声明 <span class="keyword">x</span> ，所以会忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>紧接着，在代码执行阶段，AO/VO 被修改如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AO</span>[<span class="string">'x'</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="symbol">AO</span>[<span class="string">'x'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p><p>希望大家可以好好理解变量对象，对于理解我们后边要讲的作用域链有很大的帮助。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>有一些文章说过：</p><blockquote><p>不管是使用 var 关键字（在全局上下文）还是不使用 var 关键字（在任何地方），都可以声明一个变量。</p></blockquote><p><strong>请记住，这是错误的观念。</strong></p><p><strong>任何时候，变量都只能通过使用 var 关键字来声明（ES6 之前）</strong>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面的赋值语句，仅仅是给全局对象创建了一个新属性（在在非严格模式，严格模式下会报错），但注意，它不是变量。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript 规范中变量的概念。</p><p>让我们通过一个例子来看一下两者的区别：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)<span class="comment">;        // undefined</span></span><br><span class="line">console.log(b)<span class="comment">;        // 报错，b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">b</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">var a = <span class="number">20</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>只要我们很好的理解了：变量对象、预编译阶段和执行代码阶段，就可以迅速的给出答案。</p><p>预编译（进入上下文）阶段：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">   a: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，因为 b 不是通过 var 声明的，所以这个阶段根本就没有 b ，b 只有在代码执行阶段才会出现。但是在这个例子中，还没有执行到 b 那就已经报错了。</p><p>我们稍微更改一下示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);             <span class="comment">// 10 代码执行阶段被创建</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b);        <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 20 代码执行阶段被修改</span></span><br></pre></td></tr></table></figure></p><p>关于变量，还有一个很重要的知识点。</p><p><strong>变量不能用 delete 操作符来删除。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);    <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> b);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);    <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：这个规则在 eval() 上下文中不起作用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节中我们讲了变量对象，下一节就是我们的重头戏 - <strong>作用域链</strong>。希望大家可以持续关注我，我们一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/variable_object.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;variable-object&quot;&gt;&lt;/p&gt;
&lt;p&gt;上一节我们讨论了&lt;a href=&quot;http://www.jianshu.com/p/05641baa5134&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;执行上下文&lt;/a&gt;，那么在上下文中到底有什么内容，为什么它会和作用域链扯上关系，JS 解释器又是怎么找到我们声明的函数和变量，看完这一节，相信大家就不会再迷惑了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量对象&lt;/strong&gt;就是&lt;strong&gt;执行上下文&lt;/strong&gt;和&lt;strong&gt;作用域链&lt;/strong&gt;中间的桥梁。&lt;br&gt;剧透一下，神秘的 &lt;strong&gt;this&lt;/strong&gt; 就存在于执行上下文环境之中！&lt;br&gt;当然，之后我会单独用几节来彻底讲明白 &lt;strong&gt;this 到底是什么&lt;/strong&gt;（其实 this 很简单）。&lt;/p&gt;
&lt;p&gt;接下来，我们进入正文。&lt;/p&gt;
&lt;h3 id=&quot;执行上下文包含什么&quot;&gt;&lt;a href=&quot;#执行上下文包含什么&quot; class=&quot;headerlink&quot; title=&quot;执行上下文包含什么&quot;&gt;&lt;/a&gt;执行上下文包含什么&lt;/h3&gt;&lt;p&gt;一个执行上下文我们可以抽象的理解为对象（object）。&lt;br&gt;每一个执行上下文都有一些属性（又称为上下文状态），它们用来追踪关联代码的执行进度。&lt;/p&gt;
&lt;p&gt;我用一个结构图来说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180324/variable_object.png&quot; alt=&quot;执行上下文环境 object&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="执行上下文" scheme="//blog.liuxuan.site/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
      <category term="变量对象" scheme="//blog.liuxuan.site/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Execution Context" scheme="//blog.liuxuan.site/tags/Execution-Context/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 05 - 执行上下文</title>
    <link href="//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/"/>
    <id>//blog.liuxuan.site/2017/06/03/javascript_05_execution_context/</id>
    <published>2017-06-03T02:36:00.000Z</published>
    <updated>2018-04-06T18:37:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/execution_context.jpeg?imageView2/1/w/1000/h/400" alt="execution-context"></p><p>在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：<strong>执行上下文、变量对象和作用域链</strong>。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。</p><p>这一章我们就来讨论一下到底什么是<strong>执行上下文</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当 JS 引擎开始执行预编译生成的代码时，就会进入到一个<strong>执行上下文</strong>（Executable Code - 简称 <strong>EC</strong>）。</p><p>在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。</p><p>但是在逻辑上，我们可以将活动的执行上下文看成一个<strong>栈结构</strong>。栈底部永远是<strong>全局上下文（global context）</strong>，而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。</p><a id="more"></a><h3 id="可执行代码有几种"><a href="#可执行代码有几种" class="headerlink" title="可执行代码有几种"></a>可执行代码有几种</h3><p>前面说到当引擎执行到可执行代码的时候，就会将当前上下文压入上下文栈中。那么可执行的代码又分为几种？</p><p>在这里，我们先假设定义执行上下文栈是一个数组：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">EC</span> = []<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><strong>第一种可执行代码 – 全局代码：</strong><br>全局类型代码是在加载外部的 js 文件或者本地 <script></script> 标签中的代码。<br><strong>注意，在全局代码中，并不包含定义在全局环境 function 内的代码</strong>。</p><p>程序启动后进入初始化全局环境：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">EC</span> = [</span><br><span class="line">    globalContext</span><br><span class="line">]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><strong>第二种可执行代码 – 函数代码：</strong><br>当定义的函数被执行时，就进入了函数代码，当前函数上下文被压入 EC 栈中。<br><strong>注意，在函数代码中，也不包含定义在该函数内部环境 function 内的代码。</strong></p><p>例如：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>这个例子中的 EC 是什么样子的呢？</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 foo 函数</span></span><br><span class="line">EC = [</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 foo 内递归调用自己</span></span><br><span class="line">EC = [</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext - recursively,</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续递归调用自己</span></span><br><span class="line">EC = [</span><br><span class="line">  ......</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext - recursively2,</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext - recursively,</span><br><span class="line">  <span class="params">&lt;foo&gt;</span> functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归会不断调用下去，因为没有结束条件，所以这是一个死循环</span></span><br><span class="line"><span class="comment">// 所以，EC 只会不断增加新的上下文，但是却不会退出</span></span><br></pre></td></tr></table></figure><p>只有每次 <strong>return</strong> 的时候，才会退出当前执行上下文，相应上下文会从栈中弹出，栈指针会自动移动位置。</p><p><strong>注意，当函数没有明确指明 return 什么的时候，默认 return undefined</strong> 。 </p><p>如果有抛出的异常没有被截获的话，也有可能从一个或多个执行上下文中退出。当所有代码执行完以后，EC 中只会包含全局上下文（global context），当程序退出以后，全局上下文也会退出。</p><p><strong>第三种可执行代码 – eval 代码：</strong><br>eval 函数在调用的时候会产生上下文。<br>例如：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eval('var a = <span class="number">10</span>')<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">(<span class="name">function</span> foo () &#123;</span><br><span class="line">  eval('var b = <span class="number">20</span>')<span class="comment">;</span></span><br><span class="line">&#125;())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">alert(<span class="name">a</span>)<span class="comment">;    // 10</span></span><br><span class="line">alert(<span class="name">b</span>)<span class="comment">;    // ReferenceError，b is not defined</span></span><br></pre></td></tr></table></figure></p><p>这个例子中 EC 的变化如下：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var a = 10');</span></span><br><span class="line">EC = [</span><br><span class="line">  evalContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval 执行完毕</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数 foo</span></span><br><span class="line">EC = [</span><br><span class="line">  &lt;foo&gt; functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var b = 20');</span></span><br><span class="line">EC = [</span><br><span class="line">  evalContext,</span><br><span class="line">  &lt;foo&gt; functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval 执行完毕</span></span><br><span class="line">EC = [</span><br><span class="line">  &lt;foo&gt; functionContext,</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 执行完毕</span></span><br><span class="line">EC = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>这就是一个典型的<strong>逻辑调用上下文栈</strong>。</p><p>在 setTimeout 和 setInterval 函数中的第一个参数也可以传入代码字符串，但是这个一般不会这么去用，所以这里也就不讨论了。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>执行上下文环境</strong>是我们了解<strong>变量对象</strong>和<strong>作用域链</strong>的基础，大家一定要好好理解（其实也并不难），下一节我们来讨论变量对象，相信会让大家有一定的收获。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/execution_context.jpeg?imageView2/1/w/1000/h/400&quot; alt=&quot;execution-context&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我们前面理解了作用域之后，“作用域链”这个概念就产生了。那么作用域链是什么意思，它又是怎么形成的，跟哪些概念有关系，这就是我接下来几章想和大家探讨的内容：&lt;strong&gt;执行上下文、变量对象和作用域链&lt;/strong&gt;。根据顺序我们也可以看出来，想要理解作用域链，执行上下文是我们碰到的第一个坎。&lt;/p&gt;
&lt;p&gt;这一章我们就来讨论一下到底什么是&lt;strong&gt;执行上下文&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;当 JS 引擎开始执行预编译生成的代码时，就会进入到一个&lt;strong&gt;执行上下文&lt;/strong&gt;（Executable Code - 简称 &lt;strong&gt;EC&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;在 ECMA 标准规范里并没有从技术角度去定义 EC 的具体类型和结构，这个是在实现 ECMAScript 引擎时需要考虑的问题。&lt;/p&gt;
&lt;p&gt;但是在逻辑上，我们可以将活动的执行上下文看成一个&lt;strong&gt;栈结构&lt;/strong&gt;。栈底部永远是&lt;strong&gt;全局上下文（global context）&lt;/strong&gt;，而顶部就是当前活动的执行上下文。执行到当前代码时，上下文入栈，执行完毕后，上下文出栈。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="执行上下文" scheme="//blog.liuxuan.site/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 04 - 提升</title>
    <link href="//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/"/>
    <id>//blog.liuxuan.site/2017/05/10/javascript_04__variable_lifting/</id>
    <published>2017-05-10T02:36:00.000Z</published>
    <updated>2018-04-06T18:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/variable_lifting.jpg?imageView2/1/w/1000/h/400" alt="variable-lifting"></p><p>到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。</p><p>但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。</p><a id="more"></a><h3 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h3><p>先看代码：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = <span class="number">2</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var a<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.log(a)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>大家认为这里会输出什么？</p><p>有一些人认为是 undefined ，因为 <strong><em>var a;</em></strong> 是在 <strong><em>a = 2;</em></strong> 之后，所以会觉得 undefined 覆盖了 a 的值。但是，真正的结果是 2 。</p><p>再看一段代码：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var a = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">鉴于上一个例子，有些人会认为这里会输出 <span class="number">2</span> ，也有人认为由于 a 在使用前并没有声明，所以这里会报错。但是，这里的结果是 undefined 。</span><br><span class="line"></span><br><span class="line">之前讨论编译器的时候，我们知道 <span class="keyword">JS </span>引擎会在解释代码之前首先对其进行编译。编译阶段的第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</span><br><span class="line"></span><br><span class="line">因此，正确的思路是，包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。</span><br><span class="line"></span><br><span class="line">当你看到 ***var a = <span class="number">2</span><span class="comment">;*** 时，JavaScript 实际上会将其看成两个声明：***var a;*** 和 ***a = 2;*** 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。</span></span><br><span class="line"></span><br><span class="line">所以，在第一个例子中，代码的等价形式是这样的：</span><br></pre></td></tr></table></figure></p><p>var a;</p><p>a = 2;</p><p>console.log(a);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二个例子中，代码的等价形式是这样的：</span><br></pre></td></tr></table></figure></p><p>var a;</p><p>console.log(a);</p><p>a = 2;<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个过程就好像是变量和函数声明从它们的代码中出现的位置被“移动”到了最上面。这个过程就叫作“提升”。</span><br><span class="line"></span><br><span class="line">*<span class="strong">*注意*</span><span class="strong">*，只有声明本身会被提升，而赋值操作和其他运行逻辑都会停留在原地，想象一下，如果提升会改变代码的执行顺序，那么会造成非常严重的破坏。</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">还有一点，函数声明会被提升，但是函数表达式不会被提升。</span></span><br></pre></td></tr></table></figure></p><p>foo();      // 报错，TypeError: foo is not a function，因为这里 foo 是 undefined，并不是一个函数</p><p>var foo = function foo() {<br>    // something else<br>}<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这段程序中的变量标识符 foo 被提升并分配给所在的作用域（在这里是全局作用域），因此 foo() 不会导致 <span class="built_in">ReferenceError</span> 。但是，foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会被赋值）。foo() 由于对 <span class="literal">undefined</span> 值进行函数调用而导致非法操作，所以会抛出 <span class="built_in">TypeError</span> 异常。</span><br><span class="line"></span><br><span class="line">同时，即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</span><br></pre></td></tr></table></figure></p><p>foo();<br>bar();</p><p>var foo = function bar () {<br>    // something else<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码经过提升后，实际上等价于：</span><br></pre></td></tr></table></figure></p><p>var foo;</p><p>foo();<br>bar();</p><p>foo = function () {<br>    var bar = …self…<br>    // something else<br>};<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 函数优先</span><br><span class="line">函数声明和变量声明都会被提升。但是一个值得注意的细节是，**函数声明会首先被提升，然后才是变量。**</span><br><span class="line"></span><br><span class="line">考虑如下代码：</span><br></pre></td></tr></table></figure></p><p>foo();      // 1</p><p>var foo;</p><p>function foo () {<br>   console.log(1);<br>}</p><p>foo = function () {<br>   console.log(2);<br>};<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里会输出 <span class="number">1</span> 而不是 <span class="number">2</span> 。这段代码其实等价于：</span><br></pre></td></tr></table></figure></p><p>function foo () {<br>   console.log(1);<br>}</p><p>foo();      // 1</p><p>foo = function () {<br>   console.log(2);<br>};<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***<span class="keyword">var</span> foo;*** 尽管出现在 function foo() <span class="meta">&#123;...&#125;</span> 声明之前，但是它是重复声明，所以会被编译器忽略，因为函数声明会被提升到变量声明之前。</span><br><span class="line"></span><br><span class="line">注意，尽管重复的 <span class="keyword">var</span> 声明会被忽略，但重复的函数声明却会覆盖前一个同名函数。</span><br></pre></td></tr></table></figure></p><p>foo();      // 3</p><p>function foo () {<br>   console.log(1);<br>}</p><p>var foo = function () {<br>   console.log(2);<br>};      </p><p>foo();        // 2</p><p>function foo () {<br>   cosole.log(3);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个例子充分说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。上面那个例子，等价于：</span><br></pre></td></tr></table></figure></p><p>function foo () {<br>   cosole.log(3);<br>}</p><p>foo();      // 3</p><p>foo = function () {<br>   console.log(2);<br>};      </p><p>foo();        // 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还有一些人会犯如下错误：</span><br></pre></td></tr></table></figure></p><p>foo();      // 2</p><p>var a = true;</p><p>if (a) {<br>   function foo () {<br>      console.log(1);<br>   }<br>} else {<br>   function foo () {<br>      console.log(2);<br>   }<br>}<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为 <span class="keyword">if</span> 并没有块作用域，所以这里的函数声明会提升到其作用域最前边，而后一个 <span class="keyword">function</span> <span class="title">声明会覆盖前一个，所以这里结果是</span> 2 。这里代码等价如下：</span><br></pre></td></tr></table></figure></p><p>function foo () {<br>   console.log(2);<br>}</p><p>var a;</p><p>foo();      // 2</p><p>a = true;</p><p>if (a) {</p><p>} else {</p><p>}<br><code>`</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们习惯将 <strong><em>var a = 2;</em></strong> 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 <strong><em>var a;</em></strong> 和 <strong><em>a = 2;</em></strong> 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p><p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先被处理（预编译）。可以将这个过程想象成所有的声明（变量和函数）都会被“移动”到各自的作用域的最顶端，这个过程叫作<strong>提升</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/variable_lifting.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;variable-lifting&quot;&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，大家应该很熟悉作用域的概念了，以及根据声明的位置和方式将变量分配给作用域的相关原理了。函数作用域和块作用域的行为是一样的，可以总结为：任何声明在某个作用域内的变量，都将属于这个作用域。&lt;/p&gt;
&lt;p&gt;但是作用域同其中的变量声明出现的位置有某种微妙的关系，而这个细节就是我们这节要探讨的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="作用域" scheme="//blog.liuxuan.site/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 03 - 函数作用域和块作用域</title>
    <link href="//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/"/>
    <id>//blog.liuxuan.site/2017/04/10/javascript_03__function_scope/</id>
    <published>2017-04-10T02:36:00.000Z</published>
    <updated>2018-04-06T18:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/function_scope.png?imageView2/1/w/1000/h/400" alt="function-scope"></p><p>在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。</p><p>今天，我们就来深入研究一下<strong>函数作用域</strong>和<strong>块作用域</strong>。</p><h3 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h3><p>函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// something else</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// something else   </span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();      <span class="comment">// 报错，ReferenceError: bar is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);        <span class="comment">// 报错，原因同上</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在这段代码中，函数 foo 的作用域包含了标识符a、b、c 和 bar ，函数 bar 的作用域中又包含别的标识符。</p><p>由于标识符 a、b、c 和 bar都属于函数 foo 的作用域，所以在全局作用域中访问会报错，因为它们都没有定义，但是在函数 foo 内部，这些标识符都是可以访问的，这就是函数作用域。</p><h4 id="为什么要有这些作用域"><a href="#为什么要有这些作用域" class="headerlink" title="为什么要有这些作用域"></a>为什么要有这些作用域</h4><p>当我们用作用域把代码包起来的时候，其实就是对它们进行了“隐藏”，让我们对其有控制权，想让谁访问就可以让谁访问，想禁止访问也很容易。</p><p>想像一下，如果所有的变量和函数都在全局作用域中，当然我们可以在内部的嵌套作用域中访问它们，但是因为暴露了太多的变量或函数，它们可能被有意或者无意的篡改，以非预期的方式使用，这就导致我们的程序会出现各种各样的问题，严重会导致数据泄露，造成无法挽回的后果。</p><p>例如：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="number">2</span>,</span><br><span class="line">   getA: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">4</span>;</span><br><span class="line">obj.getA();      <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>这个例子中，我们可以任意修改对象 obj 内部的值，在某种情况下这并不是我们所期望的，采用函数作用域就可以解决这个问题，私有化变量 a 。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">     getA: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">     &#125;,</span><br><span class="line">     setA: <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> </span>&#123;</span><br><span class="line">        a = val;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">4</span>;</span><br><span class="line">obj.getA();      <span class="comment">// 2</span></span><br><span class="line">obj.setA(<span class="number">8</span>);</span><br><span class="line">obj.getA();      <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></p><p>这里通过立即执行函数（IIFE）返回一个对象，只能通过对象内的方法对变量 a 进行操作，其实这里有<strong>闭包</strong>的存在，这个我们在以后会深入讨论。</p><p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，冲突会导致变量的值被意外覆盖。</p><p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">      i = <span class="number">3</span>;        <span class="comment">// 修改了 for 循环所属作用域中的 i</span></span><br><span class="line">      <span class="built_in">console</span>.log(a + i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      bar(i * <span class="number">2</span>);      <span class="comment">// 这里因为 i 总会被设置为 3 ，导致无限循环</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>bar(…) 内部的赋值表达式 i = 3 意外的覆盖了声明在 foo(…) 内部 for 循环中的 i ，在这个例子中因为 i 始终被设置为 3 ，永远满足小于 10 这个条件，导致无限循环。</p><p>bar(…) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，<strong><em>var i = 3;</em></strong> 就可以满足这个要求。另外一种方法是采用一个完全不同的标识符名称，比如 <strong><em>var j = 3;</em></strong> 。但是软件设计在某种情况下可能自然而然的要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。</p><p>总结来说，作用域可以起到两个作用：</p><ul><li><strong>私有化变量或函数</strong></li><li><strong>规避同名冲突</strong></li></ul><h4 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h4><p>如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><p>函数声明举个例子：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是一个函数声明。</p><p>函数表达式分为匿名函数表达式和具名函数表达式。</p><p>对于函数表达式来说，最熟悉的场景可能就是回调参数了，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"I wait for one second."</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>这个叫作匿名函数表达式，因为 function ()… 没有名称标识符。函数表达式可以是匿名的，但是函数声明不可以省略函数名，在 javascript 中这是非法的。</p><p>匿名函数表达式书写简便，但是它也有几个缺点需要注意：</p><ol><li>匿名函数在浏览器栈追踪中不会显示出有意义的函数名，这会加大调试难度。</li><li>如果没有函数名，当函数需要引用自身的时候就只能使用已经不是标准的 arguments.callee 来引用，比如递归。在事件触发后的事件监听器中也有可能需要通过函数名来解绑自身。</li><li>匿名函数对代码的可读性和可理解性有一定的影响。一个有意义的函数名可以让代码不言自明。</li></ol><p>具名函数表达式又叫行内函数表达式，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timerHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"I wait for one second."</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>这样，在函数内部需要引用自身的时候就可以通过函数名来引用，当然要注意，这个函数名只能在这个函数内部使用，在函数外使用时未定义的。</p><h4 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h4><p>IIFE 全写是 Immediately Invoked Function Expression，立即执行函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(a);      <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个函数表达式，通过在末尾加上另一对 ( ) 括号可以立即执行这个函数，比如 (function () {})() 。第一个 ( ) 将函数变成函数表达式，第二个 ( ) 执行了这个函数。</p><p>也有另外一种立即执行函数的写法，(function () {}()) 也可以立即执行这个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(a);      <span class="comment">// 3</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>这两种写法功能是完全一样的，具体看大家使用。</p><p>IIFE 的另一种普遍的进阶用法是把它们当做函数调用并传递参数进去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(a);      <span class="comment">// 3</span></span><br><span class="line">   <span class="built_in">console</span>.log(global.a)      <span class="comment">// 2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递你需要的任何东西，并将变量命名为任何你觉得合适的文字。这对于改进代码风格是非常有帮助的。</p><p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖的异常（这并不常见）。将一个参数命名为 undefined ，但是并不传入任何值，这样就可以保证在代码块中 undefined 的标识符的值就是 undefined 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span> (<span class="params">undefined</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a;</span><br><span class="line">   <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Undefined is safe here."</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>ES5 及以前 JavaScript 中具有块作用域的只有 with 和 try…catch 语句，在 ES6 及以后的版本添加了具有块作用域的变量标识符 let 和 const 。</p><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="number">2</span>,</span><br><span class="line">   b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br><span class="line">   <span class="built_in">console</span>.log(b);      <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 报错，a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 报错，a is not defined</span></span><br></pre></td></tr></table></figure><p>用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。</p><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="literal">undefined</span>();      <span class="comment">// 非法操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);      <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(err);      <span class="comment">// 报错，err is not defined</span></span><br></pre></td></tr></table></figure><p>try/catch 中的 catch 分句会创建一个块作用域，其中的变量声明仅在 catch 内部有效。</p><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let 关键字可以将变量绑定到任意作用域中（通常是 {…} 内部）。换句话说，let 为其声明的变量隐式的劫持了所在的块作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br><span class="line">   <span class="built_in">console</span>.log(b);      <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 报错，a is not defined</span></span><br></pre></td></tr></table></figure></p><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些代码块作用域中有绑定的变量，并且习惯性的移动这些块或者将其包含到其他块中，就会导致代码混乱。</p><p>为块作用域显示的创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在代码的任意位置都可以使用 {…} 括号来为 let 创建一个用于绑定的块。</p><p>还有一点要注意的是，在使用 var 进行变量声明的时候会存在<strong>变量提升</strong>，提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会存在作用域提升，声明的变量在被运行之前，并不存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 报错， b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在浏览器中运行这段代码时，因为前面报错了，所以不会看到接下来打印的结果，但是理论上就是这样的结果</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p><strong>2.3.1</strong> 垃圾收集<br>另一个块作用域非常有用的原因和闭包及垃圾内存的回收机制有关。<br>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bigData = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">processData(bigData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'my_button'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p>这个按钮点击事件的回调函数中并不需要 bigData 这个非常占内存的数据，理论上来说，当 processData 函数处理完之后，这个占有大量空间的数据结构就可以被垃圾回收了。但是，由于这个事件回调函数形成了一个覆盖当前作用域的<strong>闭包</strong>，JavaScript 引擎极有可能依然保存着这个数据结构（取决于具体实现）。</p><p>使用块作用域可以解决这个问题，可以让引擎清楚的知道没有必要继续保存这个 bigData 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">let</span> bigData = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">   processData(bigData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'my_button'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p><strong>2.3.2 let 循环</strong><br>一个 let 可以发挥优势的典型例子就是 for 循环。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> lists = document.getElementsByTagName('<span class="built_in">li</span>');</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>, <span class="built_in">length</span> = lists.<span class="built_in">length</span>; i &lt; <span class="built_in">length</span>; i++) &#123;</span><br><span class="line">   console.<span class="built_in">log</span>(i);</span><br><span class="line">   lists[i].onclick = function () &#123;</span><br><span class="line">     console.<span class="built_in">log</span>(i);      // 点击每个 <span class="built_in">li</span> 元素的时候，都是相对应的 i 值，而不像用 <span class="built_in">var</span> 声明 i 的时候，因为没有块作用域，所以在回调函数通过闭包查找 i 的时候找到的都是最后的 i 值</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(i);      // 报错，i <span class="built_in">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p><p>for 循环头部的 let 不仅将 i 绑定到 fir 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保上一个循环迭代结束时的值重新进行赋值。</p><p>当然，我们在 for 循环中使用 var 时也可以通过立即执行函数形成一个新的闭包来解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lists = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = lists.length; i &lt; length; i++) &#123;</span><br><span class="line">   lists[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lists = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = lists.length; i &lt; length; i++) &#123;</span><br><span class="line">   (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      lists[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实原理无非就是，为每个迭代创建新的闭包，立即执行函数执行完后本来应该销毁变量，释放内存，但是因为这里有回调函数的存在，所以形成了闭包，然后通过形参进行同名变量覆盖，所以找到的 i 值就是每个迭代新闭包中的形参 i 。</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>除了 let 以外，ES6 还引入了 const ，同样可以用来创建作用域变量，但其值是固定的（常亮）。之后任何试图修改值的操作都会引起错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">const</span> b = <span class="number">3</span>;      <span class="comment">// 包含在 if 中的块作用域常亮</span></span><br><span class="line"></span><br><span class="line">   a = <span class="number">3</span>;      <span class="comment">// 正常</span></span><br><span class="line">   b = <span class="number">4</span>;      <span class="comment">// 报错，TypeError: Assignment to constant variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b);      <span class="comment">// 报错， b is not defined</span></span><br></pre></td></tr></table></figure></p><p>和 let 一样，const 声明的变量也不存在“<strong>变量提升</strong>”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数是 JavaScript 中最常见的作用域单元。块作用域指的是变量和函数不仅可以属于所处的函数作用域，也可以属于某个代码块。</p><p>本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p><p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用哪种作用域，创造可读、可维护的优良代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/function_scope.png?imageView2/1/w/1000/h/400&quot; alt=&quot;function-scope&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 ES5 及之前版本，JavaScript 只拥有函数作用域，没有块作用域（with 和 try…catch 除外）。在 ES6 中，JS 引入了块作用域，{ } 内是单独的一个作用域。采用 let 或者 const 声明的变量会挟持所在块的作用域，也就是说，这声明关键字会将变量绑定到所在的任意作用域中（通常是 {…} 内部）。&lt;/p&gt;
&lt;p&gt;今天，我们就来深入研究一下&lt;strong&gt;函数作用域&lt;/strong&gt;和&lt;strong&gt;块作用域&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;函数中的作用域&quot;&gt;&lt;a href=&quot;#函数中的作用域&quot; class=&quot;headerlink&quot; title=&quot;函数中的作用域&quot;&gt;&lt;/a&gt;函数中的作用域&lt;/h3&gt;&lt;p&gt;函数作用域的含义是指，属于这个函数的任何声明（变量或函数）都可以在这个函数的范围内使用及复用（包括这个函数嵌套内的作用域）。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// something else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// something else   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar();      &lt;span class=&quot;comment&quot;&gt;// 报错，ReferenceError: bar is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a, b, c);        &lt;span class=&quot;comment&quot;&gt;// 报错，原因同上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="作用域" scheme="//blog.liuxuan.site/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 02 - 词法作用域</title>
    <link href="//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/"/>
    <id>//blog.liuxuan.site/2017/03/05/javascript_02_static_scope/</id>
    <published>2017-03-05T02:36:00.000Z</published>
    <updated>2018-04-06T18:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/static_scope.jpg?imageView2/1/w/1000/h/400" alt="static-scope"></p><h3 id="两种作用域"><a href="#两种作用域" class="headerlink" title="两种作用域"></a>两种作用域</h3><p>“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p><p>作用域有两种主要工作模型：<strong>词法作用域</strong>和<strong>动态作用域</strong>。</p><p>大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。</p><h3 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h3><p>大部分标准语言编译器的第一个工作阶段叫作<strong>词法化</strong>。<br>简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。</p><a id="more"></a><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   foo1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo2();</span><br></pre></td></tr></table></figure></p><p>这里输出结果是多少呢？</p><p><strong>注意，这里结果打印的是 2</strong>。</p><p>可能会有一些同学认为是 10，那就是没有搞清楚<strong>词法作用域</strong>的概念。<br>前边介绍了，词法作用域只取决于代码书写时的位置，那么在这个例子中，函数 foo1 定义时的位置决定了它的作用域，通过下图理解：</p><p><img src="http://upload-images.jianshu.io/upload_images/2944582-d5f58c050ff5af04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="词法作用域"></p><p>foo1 和 foo2 都是分别定义在全局作用域中的函数，它们是并列的，所以在 foo1 的作用域链中并不包含 foo2 的作用域，虽然在 foo2 中调用了 foo1，但是 foo1 对变量 a 进行 RHS 查询时，在自己的作用域没有找到，引擎会去 foo1 的上级作用域（也就是全局作用域）中查找，而并不会去 foo2 的作用域中查找，最终在全局作用域中找到 a 的值为 2。</p><p><strong>总结来说，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p><h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p>JavaScript 中有 3 种方式可以用来“欺骗词法”，动态改变作用域。</p><p><strong>第一种： eval</strong></p><p>JavaScript 中 eval(…) 函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。</p><p>在执行 eval(…) 之后的代码时，引擎并不知道或在意前面的代码是以动态形式插入进来并对词法作用域环境进行修改的，引擎只会像往常一样正常进行词法作用域的查找。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">eval</span>(str);        <span class="comment">// "欺骗"词法</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">"var a = 10;"</span>);</span><br></pre></td></tr></table></figure></p><p><strong>如大家所想，输出结果为 10。</strong><br>因为 eval(“var a = 10;”) 在 foo 的作用域中新创建了一个同名变量 a，引擎在 foo 作用域中对 a 进行 RHS 查询，找到了新定义的 a，值为 10，所以不再向上查找全局作用域中的 a，所以导致输出结果为 10，这就是 eval(…) 的作用。</p><p>在<strong>严格模式</strong>下，eval(…) 在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">eval</span>(str);        <span class="comment">// eval() 有自己的作用域，所以并不会修改 foo 的词法作用域</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">"var a = 10;"</span>);</span><br></pre></td></tr></table></figure><p>这里输出结果为 2。</p><p>JavaScript 中还有一些功能和 eval(…) 类似的函数，例如 setTimeout(…) 和 setInterval(…) 的第一个参数可以是一个字符串，字符串的内容可以解释为一段动态生成的代码。这些功能已经过时并且不被提倡，最好不要使用它们。new Function(…) 函数的最后一个参数也可以接受代码字符串，并将其转化为动态生成的函数，也尽量避免使用。</p><p>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</p><p><strong>第二种： with</strong><br>with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="number">2</span>,</span><br><span class="line">   b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br><span class="line">   <span class="built_in">console</span>.log(b);      <span class="comment">// 3</span></span><br><span class="line">   c = <span class="number">4</span>;         </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c);          <span class="comment">// 4, c 被泄露到全局作用域上</span></span><br></pre></td></tr></table></figure></p><p>如上所示，我们对 c 进行 LHS 查询，因为在 with 引入的新作用域中没有找到 c，所以向上一级作用域（这里是全局作用域）查找，也没有找到，在非严格模式下，在全局对象中新建了一个属性 c 并赋值为 4。</p><p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。</p><p><strong>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会限制在这个块作用域中，而是被添加到 with 所处的函数作用域中。</strong></p><p>严格模式下，with 被完全禁止使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a: <span class="number">2</span>,</span><br><span class="line">   b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a);     </span><br><span class="line">   <span class="built_in">console</span>.log(b);      </span><br><span class="line">   c = <span class="number">4</span>;         </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure></p><p><img src="http://image.liuxuan.site/blog/20180324/global_scope.png" alt="严格模式下禁止使用with"></p><p><strong>第三种： try…catch</strong><br>try…catch 可以测试代码中的错误。try 部分包含需要运行的代码，而 catch 部分包含错误发生时运行的代码。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   foo();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err);   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 打印出 "ReferenceError: foo is not defined at &lt;anonymous&gt;:2:4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>当 try 中的代码出现错误时，就会进入 catch 块，此时会把异常对象添加到作用域链的最前端，类似于 with 一样，catch 中定义的局部变量也都会添加到包含 try…catch 的函数作用域（或全局作用域）中。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>JavaScript 引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数定义的位置，才能在执行过程中快速找到标识符。</p><p>但如果引擎在代码中发现了 eval(…)、with 和 try…catch ，它只能简单的假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(…) 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>最悲观的情况是如果出现了这些动态添加作用域的代码，所有的优化可能都是无意义的，因此最简单的做法就是完全不进行任何优化。</p><p>如果代码中大量使用 eval(…) 和 with，那么运行起来一定会变得非常缓慢。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>很多时候我们对代码的分析出错，就是源于对词法作用域的忽略，所以让我们重新审视代码，继续努力！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/static_scope.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;static-scope&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;两种作用域&quot;&gt;&lt;a href=&quot;#两种作用域&quot; class=&quot;headerlink&quot; title=&quot;两种作用域&quot;&gt;&lt;/a&gt;两种作用域&lt;/h3&gt;&lt;p&gt;“作用域”我们知道是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。&lt;/p&gt;
&lt;p&gt;作用域有两种主要工作模型：&lt;strong&gt;词法作用域&lt;/strong&gt;和&lt;strong&gt;动态作用域&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大多数语言采用的都是词法作用域，少数语言采用动态作用域（例如 Bash 脚本），这里我们主要讨论词法作用域。&lt;/p&gt;
&lt;h3 id=&quot;词法&quot;&gt;&lt;a href=&quot;#词法&quot; class=&quot;headerlink&quot; title=&quot;词法&quot;&gt;&lt;/a&gt;词法&lt;/h3&gt;&lt;p&gt;大部分标准语言编译器的第一个工作阶段叫作&lt;strong&gt;词法化&lt;/strong&gt;。&lt;br&gt;简单地说，词法作用域是由你在写代码时将变量和函数（块）作用域写在哪里来决定的。当然，也会有一些方法来动态修改作用域，后边我会介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="作用域" scheme="//blog.liuxuan.site/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS学习系列 01 - 编译原理和作用域</title>
    <link href="//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/"/>
    <id>//blog.liuxuan.site/2017/02/10/javascript_01_principles_of_compiler/</id>
    <published>2017-02-10T02:36:00.000Z</published>
    <updated>2018-04-06T18:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.liuxuan.site/blog/20180407/complie.jpg?imageView2/1/w/1000/h/400" alt="complie"></p><p>在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。</p><p>这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。</p><a id="more"></a><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>大家通常把 javascript 归类为一种“动态”或“解释执行”的语言，但事实上，它是一门编译语言，但和传统的编译语言不同，它不是提前编译的，编译结果也不能进行移植。</p><p>在传统编译语言中，程序在执行之前会经历三个步骤，统称为“编译”：</p><ul><li><strong>分词/词法分析</strong><br>这个过程会把字符串分解成有意义的代码块，这些代码块被称为<strong>词法单元</strong>。<br>例如 <strong><em>var a = 5;</em></strong> 这段程序通常会被分解成下面这些词法单元： var、a、=、5、; 。空格是否会被当成词法单元取决于空格在这门语言中是否有意义。 </li><li><strong>解析/语法分析</strong><br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。<br><strong><em>var a = 5;</em></strong> 的抽象语法树中可能如下图所示：<br><img src="http://image.liuxuan.site/blog/20180324/abstract_tree.png" alt="抽象语法树"></li><li><strong>代码生成</strong><br>将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。简单来说，就是通过某种方法可以将 <strong><em>var a = 5;</em></strong> 的 AST 转化为一组机器指令，用来创建一个叫做 a 的变量（包括分配内存等），并将一个值 5 存储在 a 中。</li></ul><p>比起那些编译过程只有三个步骤的语言的编译器来说，<strong>javascript 引擎要复杂的多</strong>。<br>例如，在词法分析和代码生成阶段有特定的步骤来对<strong>运行性能进行优化</strong>，包括对<strong>冗余元素进行优化</strong>等。</p><p>首先我们要清楚，javaScript 引擎不会有太多的时间来进行优化（相对于其它语言的编译器来说），因为与其它语言不同，javascript 的编译过程<strong>不是发生在构建之前的</strong>。</p><p>对于 javascript 来说，大部分情况下编译发生在<strong>代码执行前的几微秒（甚至更短）的时间</strong>内。在我们将要讨论的作用域背后，javascript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至重新编译）来保证性能最佳。</p><p>总结来说，任何 javascript 代码片段在执行前都要进行编译（<strong>预编译</strong>）。因此，javascript 编译器首先会对 <strong><em>var a = 5;</em></strong> 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。 </p><h3 id="三位好友"><a href="#三位好友" class="headerlink" title="三位好友"></a>三位好友</h3><p>要真正理解作用域，我们首先要知道 javascript 中有三位好朋友：</p><ul><li><strong>引擎</strong><br>从头到尾负责整个 javascript 程序的编译及执行过程。</li><li><strong>编译器</strong><br>负责语法分析及代码生成。</li><li><strong>作用域</strong><br>负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li></ul><p>当遇见 <strong><em>var a = 5;</em></strong> 这一段代码时，其实执行了两个步骤：</p><p>（1）<strong><em>var a;</em></strong> 编译器会询问作用域是否已经有一个该名称的变量存在于同一作用域的集合中。如果是，编译器会忽略该声明，继续进行编译，否则它会要求在当前作用域的集合中声明一个新的变量，并命名为 a 。<br>（2）<strong><em>a = 5;</em></strong> 编译器会为引擎生成运行时所需的代码，这些代码用来处理 <strong><em>a = 5;</em></strong> 这个赋值操作。引擎运行时会首先询问作用域，在当前作用域的集合中是否存在一个叫作 a 的变量，如果是，引擎就会使用这个变量。如果否，引擎会继续向父级作用域中查找，直到找到全局作用域，如果在全局作用域中仍没有找到 a ，那么在<strong>非严格模式</strong>下，引擎会为全局对象新建一个属性 a ，并将其赋值为5，在<strong>严格模式</strong>下，引擎会报错误 <strong>ReferenceError: a is not defined</strong>。</p><p><strong>总结来说</strong>，变量的赋值会执行两个操作，<strong>首先</strong>编译器会在当前作用域声明一个变量（如果之前没有声明过），<strong>然后</strong>在运行时引擎会在当前作用域中查找该变量（找不到就向上一级作用域查找），如果能够找到就会对它赋值。</p><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>前面说到引擎在为变量赋值的时候会在作用域中查找变量，但是执行怎样的查找，用什么方式，会对最终的查找结果造成影响。</p><p>在 <strong><em>var a = 5;</em></strong> 这个例子中，引擎会对 a 进行 LHS 查询，当然，另外一个查找类型叫作 RHS。</p><p><strong>对变量进行赋值所执行的查询叫 LHS。</strong><br><strong>找到并使用变量值所执行的查询叫 RHS。</strong></p><p>举个例子：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里隐式包含了 a = 2 这个赋值，所以对 a 进行了 LHS 查询</span></span><br><span class="line">   <span class="keyword">var</span> b = a;</span><br><span class="line">   <span class="comment">// 这里对 a 进行了 RHS 查询，找到 a 的值，然后对 b 进行 LHS 查询，把 2 赋值给 b</span></span><br><span class="line">   <span class="keyword">return</span> a + b; </span><br><span class="line">   <span class="comment">// 这里包含了对 a 和 b 进行的 RHS 查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 这里首先对 foo 进行 RHS 查询，找到它是一个函数，然后对 c 进行 LHS 查询把 foo 赋值给 c</span></span><br></pre></td></tr></table></figure></p><p><strong>所以上面的例子共包含 3 个 LHS 查询和 4 个 RHS 查询，你们都找对了吗？</strong></p><h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>);    <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>这里对 b 进行的 RHS 查询在 foo 作用域中无法找到，但可以在上一级作用域（这个例子中就是全局作用域）中找到。</p><p>总结来说，遍历嵌套作用域链的规则很简单：引擎从当前执行的作用域中开始查找变量，如果都找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>编译器、引擎和作用域是 javascript 代码执行的基础，掌握好这些会对我们深入学习 javascript 起到事半功倍的效果，我们的学习之路才刚刚开始，大家加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.liuxuan.site/blog/20180407/complie.jpg?imageView2/1/w/1000/h/400&quot; alt=&quot;complie&quot;&gt;&lt;/p&gt;
&lt;p&gt;在学习 javascript 的过程中，我们第一步最应该了解和掌握的就是作用域，与之相关还有程序是怎么编译的，变量是怎么查找的，js 引擎是什么，引擎和作用域的关系又是什么，这些是 javascript 这门语言最基础的地基，至于对象、函数、闭包、原型链、作用域链以及设计模式等等都是地基以上的建筑，只有地基打牢了，建筑才会稳。同样只有先把最基础的部分掌握了，之后的扩展学习才会更容易。&lt;/p&gt;
&lt;p&gt;这一节我要说的，就是作用域和编译原理，从这里开始，我会一点点的把深入学习 javascript 的过程中总结的知识点以及遇到的问题，一篇一篇的梳理出来，如果有志同道合的朋友，可以关注我这个系列，我们一起玩转 javascript。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="//blog.liuxuan.site/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="//blog.liuxuan.site/tags/Javascript/"/>
    
      <category term="编译原理" scheme="//blog.liuxuan.site/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
